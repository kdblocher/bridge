{"version":3,"sources":["workers/dds.worker.ts","workers/deal.worker.ts","workers/sat.worker.ts","workers/satisfies.worker.ts","webpack:///./src/workers/dds.worker.ts?517b","webpack:///./src/workers/deal.worker.ts?9d69","webpack:///./src/workers/sat.worker.ts?967e","webpack:///./src/workers/satisfies.worker.ts?62d8","serviceWorker.ts","lib/gen.ts","model/evaluation.ts","model/serialization.ts","parse/bid.peg.g.ts","lib/index.ts","model/deck.ts","model/bridge.ts","model/system/core.ts","model/system/satisfaction.ts","lib/object.ts","model/job.ts","lib/pool.ts","services/idb.ts","workers/index.ts","reducers/generator.ts","model/score.ts","model/analyze.ts","model/stats.ts","reducers/profile.ts","model/system.ts","model/system/expander.ts","parse/hand.peg.g.ts","parse/bid.ts","parse/hand.ts","parse/index.ts","reducers/selection.ts","reducers/settings.ts","lib/array.ts","model/system/validation.ts","reducers/system.ts","reducers/index.ts","app/store.ts","components/index.tsx","app/hooks.ts","components/Editor.tsx","components/core/BidPath.tsx","components/Errors.tsx","components/SelectionDetails.tsx","components/core/HandView.tsx","components/core/DoubleDummyResultView.tsx","components/core/Monad.tsx","components/SelectionGenerators.tsx","components/HandEditor.tsx","components/TestHands.tsx","components/Design.tsx","components/core/Fractional.tsx","components/core/Percentage.tsx","components/stats/StatsPath.tsx","components/stats/SolutionStats.tsx","components/core/StrainTableView.tsx","components/core/BidSelector.tsx","components/stats/ScoreComparison.tsx","components/stats/StatsDetails.tsx","components/Analyses.tsx","components/Jobs.tsx","components/Analyze.tsx","index.tsx"],"names":["inst","wrap","Worker","module","exports","f","this","Boolean","window","location","hostname","match","alternate","opener","responder","unfold","length","g","val","next","done","value","s","h","d","c","i","ASTKinds","assertUnreachable","x","Error","JSON","stringify","ordAscending","array","pipe","number","Ord","ord","contramap","indexOf","ordDescending","flow","reverse","suits","eqSuit","eq","eqStrict","ordSuitDescending","rankStrings","RankB","t","RankC","is","validate","r","eqRank","ordRankAscending","ordRankDescending","ranks","readonlyArray","mapWithIndex","idx","_","decode","right","honors","takeRight","rankFromString","findIndex","r2","string","Eq","equals","option","chain","lookup","eqCard","struct","suit","rank","ordCardDescending","getMonoid","concat","cards","RNEA","makeBy","Math","floor","getOrdGroupedHand","zeroGroupedHand","S","H","D","C","groupHandBySuits","hand","readonlySet","toReadonlyArray","fromReadonlyArray","fold","groupBy","readonlyRecord","map","union","getUnionMonoid","engine","MersenneTwister19937","autoSeed","newDeck","shuffle","directions","eqDirection","eqHand","RS","getEq","eqDeal","strains","eqStrain","ordStrain","minors","boneChart","dealer","deal","boardNumber","nonContractBids","eqNonContractBid","isNonContractBid","b","RA","elem","eqContractBid","level","strain","ordContractBid","levels","contractBids","apply","sequenceS","Apply","sort","isContractBid","eqBid","fromEquals","y","getHcp","modifier","foldMap","MonoidSum","max","zeroShape","sortShape","makeShape","counts","eqShape","zeroSpecificShape","getHandSpecificShape","semigroup","first","getHandShape","readonlyTuple","snd","suitCounts","getOrElse","constraintTrue","constant","type","predFalse","constFalse","quantifier","constTrue","ps","m","exists","P","getMonoidAny","forall","getMonoidAll","rangeCheck","range","between","min","isPointRange","isSuitRange","shape","suitCompare","op","left","lt","leq","geq","gt","getComparator","toRankSet","contextualConstraintTypes","separate","isContextualConstraint","E","satisfiesBasic","suitHonors","RR","O","cardSet","intersection","honorSet","isSubset","suitTop","filter","compare","minRank","count","handShape","record","isSpecificShape","ordBid","fromCompare","a","ordConstrainedBid","bid","relativePlayers","relativePartnerships","zeroPlayerContext","primarySuit","none","secondarySuit","playerContextL","Lens","fromProp","primarySuitL","secondarySuitL","zeroPartnershipContext","trumpSuit","partnershipContextL","trumpSuitL","rotateRecord","keys","zip","rotate","mapSnd","p","fromFoldable","Foldable","rotateContexts","context","pl","pt","modify","endomorphism","getSemigroup","identity","zeroContext","path","players","partnerships","contextL","bidL","pathL","playersL","partnershipsL","playerContextA","Optional","fromOptionProp","At","player","get","upsertAt","set","partnershipContextA","partnership","quantifierS","satisfies","traverseArray","ofS","of","satisfiesContextual","recur","constraints","existsS","constraint","not","at","composeLens","some","splitAt","bimap","tail","higher","lower","flatten","prepend","apSecond","gets","optionT","Functor","Do","apS","difference","otherSuit","satisfiesS","flap","satisfiesPath","evaluate","Gen","info","chainFirst","apFirst","boolean","MonoidAll","key","obj","DateNumberB","now","Date","getTime","getGenericProgress","job","details","progress","initProgress","unitsDone","updateDate","speed","updateProgress","M","lastUpdate","isNaN","isFinite","o","avg","alt","GenerationIdB","id","UuidTool","isUuid","newGenerationId","newUuid","AnalysisIdB","ConstrainedBidPathHashC","hash","getBidPathHash","cb","objectHash","initJobProgress","JobIdB","pool","ctor","doWork","input$","maxParallel","navigator","hardwareConcurrency","Observable","resultObserver","idleWorker$$","Subject","completed","sent","finished","workers","index","cachedWorker","factory","terminate","processing","sub","tap","worker","finalize","complete","forEach","mergeMap","item","from","subscribe","w","unsubscribe","serializedHandL","iso","decodedSerializedHandL","either","reverseGet","getUuidQuads","fromPredicate","Uuid","uuid","toBytes","takeLeft","byte","DealUuidB","reduce","replicate","directionIndex","every","dealUuidToDeal","encode","readonlyNonEmptyArray","card","fst","encodeDealAsUuid","foldMapWithIndex","trivial","direction","chunksOf","toArray","toString","serializedDealL","serializedBoardL","serializedContractBidL","parseInt","charAt","serializedBidL","SerializedBidPathB","split","serializedBidPathL","intersperse","Monoid","getDb","TE","tryCatch","deleteDB","openDB","upgrade","db","createObjectStore","createIndex","getByIndex","tryCatchK","getAllFromIndex","getBatchIdsByGenerationId","generationId","row","batchId","uniq","deleteByGenerationId","transaction","tran","objectStore","getAllKeys","delete","observeSolutions","deals","vulnerability","DDSWorker","getResult","ObE","board","observeValidation","paths","SATWorker","getPathIsSound","p0","len","Ob","slice","createSlice","name","initialState","jobs","reducers","scheduleJob","state","action","analysisId","estimatedUnitsInitial","payload","parameter","dependsOn","unitsInitial","startDate","completedDate","running","error","push","castDraft","startJob","find","j","jobId","completeJob","reducer","meta","splice","prepare","constVoid","removeJob","reportDeals","jobType","reportSatisfies","result","getUnionSemigroup","testedCount","satisfiesCount","reportSolutions","solutions","actions","generateDeals","memoize","findFirst","append","DealWorker","genDeals","observeDeals","err","concatWith","generateSatisfies","fromTaskEither","fromObservable","bindTo","bind","isRight","group","SatisfiesWorker","satisfiesBatch","taskEither","observeSatisfies","withJobType","action$","state$","generator","epics","ObO","EMPTY","contractPointMultiplier","contractModMultiplier","subtractBookTricks","tricks","making","contract","oddTricks","getOddTricks","fromEither","whenMaking","contractPoints","vulnerableMultiplier","isVulnerable","getModified","doubledPenalties","partScorePoints","score","scoreComponents","overtrickPoints","overtricks","getOrElseW","multiplier","slamPoints","modifierPoints","penaltyPoints","swap","undertricks","gamePoints","ScoreC","zeroScore","eqScore","traverseWithIndex","writer","getApplicative","tell","cs","pass","flattenNestedCounts","table","inner","outer","outerKey","innerKey","transpose","eqOptimalBid","initialContractBid","initialBids","getAllScores","eitherT","getDirectionScores","dir","vul","getIsVulnerable","SerializedKeyL","columns","sequenceT","aggregate","rollup","object","mapFst","head","toRow","ddt","getScores","ordScore","ordScores","tallyScore","results","orderedScores","tie","sumCompare","SemigroupSum","serializeOptimalBid","compareScores","scores","dirsAndBids","bids","tuple","fromEntries","getStats","aq","ct","totalRows","average","mean","stdev","analyses","selectedAnalysis","addAnalysis","analysis","generations","zeroAnalysis","deleteAnalysis","removeAnalysis","selectAnalysis","has","setAnalysisName","addJobToAnalysis","genJob","dealCount","solutionStats","satJob","generation","solveJob","RT","stats","bidPath","profile","id2","filterMap","selectAnalysisById","isNone","fromTask","observableEither","selectSelectedAnalysis","selectGenerationByAnalysis","forest","T","items","getPathForest","make","getAllLeafPaths","node","extendTreeWithSiblings","eqA","siblings","u","extendForestWithSiblings","withImplicitPasses","bs","syntax","collectErrors","traverse","TH","mapLeft","sequence","chainCollectedErrors","fa","getChain","isSuit","syntaxTrue","syntaxFalse","pathReversed","empty","traversed","labels","RM","pathReversedL","siblingsL","traversedL","labelsL","eqSyntacticBid","sb","otherwise","rights","takeLeftWhile","wrapShapes","syntaxBalanced","syntaxSemiBalanced","expandSpecifier","specifier","pure","expandOnce","Applicative","wilt","separated","these","fromOptions","connective","Monad","fromOption","definition","c0","labelDef","labelRef","sequenceArray","expand","modifyContext","modifiers","expandBid","e","reason","traversePeers","expandPeers","expandedBid","expandedChildForest","Digit","literal","kind","Number","Parser","input","pos","negating","memoSafe","$scope$Constraint$memo","Map","overallPos","line","offset","clear","$$dpth","$$cr","run","$scope$spec","$$res","matchBidSpec","match$EOF","Start","spec","$scope$bid","$scope$constraints","matchBid","matchBidSpecConstraintList","BidSpec","regexAccept","String","raw","matchConstraintList","BidSpecConstraintList","choice","matchBid_1","matchBid_2","matchContractBid","matchNonContractBid","$scope$level","$scope$specifier","matchDigit","matchStrainSpecifier","ContractBid","matchStrainSpecifier_1","matchStrainSpecifier_2","matchStrainSpecifier_3","matchStrainSpecifier_4","matchWildcard","matchMajor","matchMinor","matchStrain","$scope$v","Wildcard","v","Major","Minor","matchPass","Pass","matchStrain_1","matchStrain_2","matchSuit","matchNotrump","matchSuit_1","matchSuit_2","matchSuit_3","matchSuit_4","matchClub","matchDiamond","matchHeart","matchSpade","Club","Diamond","Heart","Spade","Notrump","Honor","loop","matchConstraintListItem","$scope$constraint","matchConstraint","ConstraintListItem","$scope$pos","mark","memo","undefined","reset","$scope$oldMemoSafe","lastRes","lastPos","res","matchConstraint_1","matchConstraint_2","matchConstraint_3","matchConstraint_4","matchConstraint_5","matchConstraint_6","matchConstraint_7","matchConstraint_8","matchConstraint_9","matchConstraint_10","matchConstraint_11","matchConstraint_12","matchConstraint_13","matchConstraint_14","matchConstraint_15","matchConstraint_16","matchConstraint_17","matchConstraint_18","end","matchConst","matchOr","matchAnd","matchNot","matchOtherwise","matchDistribution","matchSuitRange","matchSuitBound","matchSuitComparison","matchSuitHonors","matchSuitTop","matchSuitRank","matchSetTrump","matchPointRange","matchPointBound","matchOtherBid","matchLabelDef","matchLabelRef","matchConst_1","matchConst_2","matchTrue","matchFalse","True","False","$scope$left","$scope$right","Or","And","matchNot_$0","Not","matchNot_$0_1","matchNot_$0_2","Otherwise","$scope$lower","$scope$upper","matchNumber","PointRange","upper","$scope$value","$scope$qualifier","matchBoundQualifier","PointBound","qualifier","$scope$suit","matchSuitSpecifier","SuitRange","SuitBound","matchSuitSpecifier_1","matchSuitSpecifier_2","matchSuitSpecifier_3","matchSuitSpecifier_4","matchSuitSpecifier_5","matchSuitSpecifier_6","matchOtherMajor","matchOtherMinor","OtherMajor","OtherMinor","$scope$op","matchSuitComparisonOperator","SuitComparison","matchSuitComparisonOperator_1","matchSuitComparisonOperator_2","matchSuitComparisonOperator_3","matchSuitComparisonOperator_4","matchSuitComparisonOperator_5","SuitComparisonOperator_1","SuitComparisonOperator_2","SuitComparisonOperator_3","SuitComparisonOperator_4","SuitComparisonOperator_5","$scope$honors","matchHonor","SuitHonors","$scope$x","$scope$y","SuitTop","matchBoundQualifier_1","matchBoundQualifier_2","matchBoundQualifier_3","matchPlus","matchMinus","matchEquals","Plus","Minus","Equals","$scope$strain","OtherBid","matchDistribution_1","matchDistribution_2","matchDistribution_3","matchDistribution_4","matchDistribution_5","matchBalanced","matchSemiBalanced","matchUnbalanced","matchAnyShape","matchSpecificShape","Balanced","SemiBalanced","Unbalanced","AnyShape","$scope$S","$scope$H","$scope$D","$scope$C","SpecificShape","matchSuitRank_1","matchSuitRank_2","matchPrimary","matchSecondary","Primary","Secondary","SetTrump","$scope$label","matchLabel","LabelDef","label","LabelRef","Label","$scope$literal","mrk","ans","matchStart","ast","errs","rec","ErrorTracker","clearMemos","getErr","func","star","fn","fns","dpth","cr","reg","RegExp","lastIndex","tryConsume","substring","negated","exec","lineJmp","lind","oneg","rule","$scope$memoRes","$scope$result","et","$EOF","SyntaxErr","expmatches","mxpos","regexset","Set","pmatches","att","add","getConnectiveItems","AST","suitSpecifier","bindValueQualifier","constraintList","fromArray","parseBid","parse","Card","$scope$hand","matchHand","Hand","$scope$cards","matchCard","Suit","$scope$c","parseHand","handE","cur","convertErrors","FS","actual","DE","parseResultToEither","fromNullable","getDecoder","parser","decodeBid","bidSpec","constrainedBid","decodeHand","selectedBlockKey","setHands","hands","createAsyncThunk","rejectWithValue","l","N","W","genBoardFromHands","observable","toTask","genUntilCondition","limit","condition","tailRec","deck","genMatchingOf","partition","setSelectedBlockKey","setHand","genOnce","getHandsMatchingPath","genHandsNotMatchingAnyOf","predicate","openerMinHcp","genHandsMatchingExactlyOneOf","genHandsMatchingMoreThanOneOf","extraReducers","builder","addCase","fulfilled","selectBlockKey","toNullable","selectHand","implicitPass","generateCount","setInitial","Object","setProperty","values","bidPathSorted","forestSorted","tree","validateForest","eqBlockKey","decodedBidAdapter","createEntityAdapter","validatedPathAdapter","system","decodedBids","getInitialState","validatedPaths","setSystem","root","parents","curr","depth","buildForest","removeConstraintsByBlockKey","removeMany","ids","includes","cacheSystemConstraints","text","setMany","validateSystem","reportValidationResult","getValidationPathKeyByPath","replete","upsertOne","constrainedBidSelectors","getSelectors","getCachedBidByKey","constrainedBids","fromNullableK","selectById","b1","entities","b2","Semigroup","selectBidByKey","selectBidPathUpToKey","findFirstMap","zero","selectRules","selectCompleteSyntaxForest","lefts","options","selectExpandedConstraintForest","selectCompleteConstraintForest","bidForest","selectSystemWithErrors","selectPristineSystem","getRightOnly","selectValidConstrainedBidPaths","getRight","selectCompleteBidPathUpToKey","fromEitherK","cbPath","selectCompleteBidByKey","last","eqBidPath","selectErrorTree","pathForest","getLeft","errors","selectErrorsByKey","debounceTime","bp","selection","settings","rootEpic","combineEpics","generatorEpics","profileEpics","systemEpics","selectPathsSatisfyHands","epicMiddleware","createEpicMiddleware","store","configureStore","middleware","getDefaultMiddleware","App","className","style","display","float","to","target","rel","href","useAppDispatch","useDispatch","useAppSelector","useSelector","EditorDiv","styled","div","getDescriptorFromContentBlock","getKey","getText","getDepth","eqContentBlock","monoid","concatAll","getBlocks","editorState","getCurrentContent","getBlocksAsArray","Editor","useState","EditorState","createEmpty","setEditorState","blocks","setBlocks","dispatch","onChange","useCallback","setTimeout","localStorage","setItem","convertToRaw","newBlocks","same","removed","added","isEmpty","newSelectedBlockKey","getSelection","getFocusKey","useEffect","savedEditorState","getItem","createWithContent","convertFromRaw","RichUtils","toggleBlockType","keyBindingFn","keyCode","newEditorState","onTab","getDefaultKeyBinding","SuitSpan","span","ContractBidView","NonContractBidView","BidView","BidPath","GridContainer","ExpandErrorView","ValidationErrorView","BidErrorsView","ErrorGrid","ErrorForest","flattenedForest","useMemo","Errors","systemExists","isNonEmpty","isPristine","isSome","isLeft","draw","SelectionDetails","selected","syntacticBid","data","RankList","ol","RankListItem","li","RankView","SuitList","SuitListItem","SuitView","HandView","groupedHand","StrainSpan","DoubleDummyTableView","fontWeight","verticalAlign","round","DoubleDummyResultView","Option","onSuccess","children","onNone","GenerateOnce","Button","onClick","GenerateMatchZero","bidPaths","minHcp","setMinHcp","width","GenerateMatchOne","GenerateMatchMany","GenerateMatchSelected","SelectionGenerators","HandInput","setValue","storageKey","encodedHand","onSetHand","savedHand","placeholder","onBlur","HandCol","th","HandEditor","getResultCallback","TestHands","Design","Fractional","numerator","denominator","decimalPlaces","pow","Percentage","StatsPath","SolutionStats","StrainTableView","renderColHeader","renderRowHeader","renderCell","rows","BidSelectorButton","setSelected","minWidth","appearance","BidSelector","setSelectedBid","contractBidsEnabledByLevel","selectedBid","Columns","ScoreList","ul","ScoreComparison","contractBid","setBids","comparison","entries","Column","StatsDetails","onClose","solveCount","FlexList","FlexListItem","StatsPathItem","pathHash","solve","satisfiedDeals","compact","solution","getDealsWithSolutionsByPath","StatsModal","showDetails","setShowDetails","onShowClick","open","Dialog","modalType","onOpenChange","__","DialogTrigger","DialogSurface","DialogBody","DialogTitle","DialogActions","disableButtonEnhancement","StatsPathContainer","GenerationView","getHash","SelectedAnalysis","onGenerateDealsClick","NewAnalysis","onSubmitOrClose","onGoClick","defaultCount","setName","setCount","DialogContent","disabled","Analyses","newAnalysis","setNewAnalysis","DateView","date","_tag","JobList","JobListItem","ProgressView","start","timeRemaining","estimatedTimeRemaining","JobView","onRemoveClick","onStartClick","Jobs","Analyze","router","createBrowserRouter","element","basename","ReactDOM","render","StrictMode","FluentProvider","theme","teamsLightTheme","document","getElementById","serviceWorker","ready","then","registration","unregister","catch","console","message"],"mappings":"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","file":"static/js/main.76c61ef4.chunk.js","sourcesContent":["var wrap = require('comlink').wrap,Worker = require(\"!worker-loader?{}!/home/runner/work/bridge/bridge/node_modules/comlink-loader/dist/comlink-worker-loader.js!/home/runner/work/bridge/bridge/node_modules/react-scripts/node_modules/babel-loader/lib/index.js??ref--5-oneOf-2!/home/runner/work/bridge/bridge/src/workers/dds.worker.ts\"),inst;module.exports = function f() {if (this instanceof f) return wrap(Worker());return inst || (inst = wrap(Worker()));};","var wrap = require('comlink').wrap,Worker = require(\"!worker-loader?{}!/home/runner/work/bridge/bridge/node_modules/comlink-loader/dist/comlink-worker-loader.js!/home/runner/work/bridge/bridge/node_modules/react-scripts/node_modules/babel-loader/lib/index.js??ref--5-oneOf-2!/home/runner/work/bridge/bridge/src/workers/deal.worker.ts\"),inst;module.exports = function f() {if (this instanceof f) return wrap(Worker());return inst || (inst = wrap(Worker()));};","var wrap = require('comlink').wrap,Worker = require(\"!worker-loader?{}!/home/runner/work/bridge/bridge/node_modules/comlink-loader/dist/comlink-worker-loader.js!/home/runner/work/bridge/bridge/node_modules/react-scripts/node_modules/babel-loader/lib/index.js??ref--5-oneOf-2!/home/runner/work/bridge/bridge/src/workers/sat.worker.ts\"),inst;module.exports = function f() {if (this instanceof f) return wrap(Worker());return inst || (inst = wrap(Worker()));};","var wrap = require('comlink').wrap,Worker = require(\"!worker-loader?{}!/home/runner/work/bridge/bridge/node_modules/comlink-loader/dist/comlink-worker-loader.js!/home/runner/work/bridge/bridge/node_modules/react-scripts/node_modules/babel-loader/lib/index.js??ref--5-oneOf-2!/home/runner/work/bridge/bridge/src/workers/satisfies.worker.ts\"),inst;module.exports = function f() {if (this instanceof f) return wrap(Worker());return inst || (inst = wrap(Worker()));};","module.exports = function() {\n  return new Worker(__webpack_public_path__ + \"914bcd3dc772cf94f689.worker.js\");\n};","module.exports = function() {\n  return new Worker(__webpack_public_path__ + \"ff41cabfb8bba92e2f72.worker.js\");\n};","module.exports = function() {\n  return new Worker(__webpack_public_path__ + \"abf7c0d3b3e746af4876.worker.js\");\n};","module.exports = function() {\n  return new Worker(__webpack_public_path__ + \"226fbf730682b5acc887.worker.js\");\n};","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","export function* alternate<A>(opener: A, responder: A) {\n  while (true) { yield opener; yield responder }\n}\n\nexport const unfold = (length: number) => <A>(g: Generator<A>) : readonly A[] => {\n  const val = g.next()\n  return val.done || length === 0 ? [] : [val.value, ...unfold(length - 1)(g)]\n}\n\nexport function* take<T>(generator: Generator<T>, n: number) {\n  for (var i = 0; i < n; i++) {\n    let v = generator.next()\n    if (!v.done) {\n      yield v.value\n    } else {\n      break\n    }\n  }\n}","import { eq, number, option, ord, readonlyArray, readonlyRecord, readonlySet, readonlyTuple, semigroup } from 'fp-ts';\nimport { flow, pipe } from 'fp-ts/lib/function';\n\nimport { groupHandBySuits, Hand, ordCardDescending, Rank, Suit } from './deck';\n\nexport const getRankHcp = (rank: Rank) =>\n  Math.max(0, rank - 10)\n\nexport const getHcp =\n  flow(\n    readonlySet.toReadonlyArray(ordCardDescending),\n    readonlyArray.foldMap(number.MonoidSum)(c => getRankHcp(c.rank)))\n\nexport type AnyShape = readonly [number, number, number, number]\nexport const zeroShape: AnyShape = [0, 0, 0, 0]\nexport const sortShape = (s: AnyShape) => pipe(s, readonlyArray.sort(ord.reverse(number.Ord))) as AnyShape\nexport const makeShape = (...counts: AnyShape) =>\n  pipe(counts, sortShape)\nexport const eqShape : eq.Eq<AnyShape> =\n  eq.contramap(sortShape)(readonlyArray.getEq(number.Eq))\n\nexport type SpecificShape = Record<Suit, number>\nexport const makeSpecificShape = (s: number, h: number, d: number, c: number) : SpecificShape => ({\n  S: s,\n  H: h,\n  D: d,\n  C: c\n})\nexport const zeroSpecificShape = makeSpecificShape(0, 0, 0, 0)\n\nexport const getHandSpecificShape = (hand: Hand) : SpecificShape =>\n  pipe(hand,\n    groupHandBySuits,\n    readonlyRecord.map(x => x.length),\n    readonlyRecord.union(semigroup.first<number>())(zeroSpecificShape),\n    (suits: readonlyRecord.ReadonlyRecord<Suit, number>) => suits)\n\nexport const getHandShape = (hand: Hand) : AnyShape =>\n  pipe(hand,\n    getHandSpecificShape,\n    readonlyRecord.toReadonlyArray,\n    readonlyArray.map(readonlyTuple.snd),\n    suitCounts => readonlyArray.mapWithIndex((idx, _) =>\n      pipe(suitCounts, readonlyArray.lookup(idx), option.getOrElse(() => 0)))(zeroShape)) as AnyShape","import { array, either, option, ord, readonlyArray, readonlyNonEmptyArray, readonlyRecord, readonlySet, readonlyTuple, refinement, string } from 'fp-ts';\nimport { Either } from 'fp-ts/lib/Either';\nimport { flow, identity, pipe } from 'fp-ts/lib/function';\nimport { ReadonlyNonEmptyArray } from 'fp-ts/lib/ReadonlyNonEmptyArray';\nimport * as t from 'io-ts';\nimport * as D from 'io-ts/Decoder';\nimport * as E from 'io-ts/Encoder';\nimport * as iso from 'monocle-ts/Iso';\nimport { O } from 'ts-toolbelt';\nimport { Uuid, UuidLike, UuidTool } from 'uuid-tool';\n\nimport { decodeHand } from '../parse';\nimport { Bid, Board, ContractBid, Deal, directions, isNonContractBid, Strain } from './bridge';\nimport { Card, cards, eqCard, Hand, ordCardDescending } from './deck';\n\nexport type DecodedHand = ReturnType<typeof decodeHand>\nexport type SerializedHand = ReadonlyArray<Card>\nexport type DecodedSerializedHand = DecodedHand extends Either<infer L, unknown> ? either.Either<L, SerializedHand> : never\n\nexport const serializedHandL : iso.Iso<Hand, SerializedHand> = iso.iso(\n  readonlySet.toReadonlyArray(ordCardDescending),\n  readonlySet.fromReadonlyArray(eqCard)\n)\n\nconst liftEither = <E>() => <A, B>(i: iso.Iso<A, B>) => iso.iso<Either<E, A>, Either<E, B>>(either.map(i.get), either.map(i.reverseGet))\nexport const decodedSerializedHandL = liftEither<D.DecodeError>()(serializedHandL)\n\nexport const decodeUuid : D.Decoder<string, Uuid> = {\n  decode: flow(\n    either.fromPredicate(UuidTool.isUuid, s => D.error(s, \"Invalid uuid string\")),\n    either.map(s => new Uuid(s)))\n}\n\nconst MASK = 0b11 as const\nconst getUuidQuads = (uuid: UuidLike) => \n  pipe(new Uuid(uuid.id).toBytes(),\n    readonlyArray.takeLeft(13),\n    readonlyArray.chain(flow(byte =>\n      readonlyArray.unfold([byte, 4 as number] as const, ([byte, i]) =>\n        i === 0\n        ? option.none\n        : option.some([byte & MASK, [byte >> 2, i - 1]] as const)),\n        readonlyArray.reverse))) as ReadonlyNonEmptyArray<number>\n\nexport type SerializedDeal = t.Branded<UuidLike, { readonly Deal: unique symbol }>\nconst isDealUuid: refinement.Refinement<UuidLike, SerializedDeal> =\n  (uuid): uuid is SerializedDeal =>\n    pipe(uuid,\n      getUuidQuads,\n      readonlyArray.reduce(\n        array.replicate(4, 0 as number),\n        (counts, directionIndex) =>\n          { counts[directionIndex] += 1; return counts }),\n      readonlyArray.every(count => count === 13))\n\nconst DealUuidB = t.brand(t.type({ id: t.string }), isDealUuid, 'Deal')\n\nconst dealUuidToDeal: E.Encoder<Deal, SerializedDeal> = {\n  encode: flow(\n    getUuidQuads,\n    readonlyNonEmptyArray.zip(pipe(cards, readonlyNonEmptyArray.sort(ordCardDescending))),\n    readonlyNonEmptyArray.map(([idx, card]) => [directions[idx], card] as const),\n    readonlyNonEmptyArray.groupBy(readonlyTuple.fst),\n    readonlyRecord.map(flow(\n      readonlyNonEmptyArray.map(readonlyTuple.snd),\n      readonlySet.fromReadonlyArray(eqCard))))\n  }\n\ntype CardDirectionPair = readonly [Card, number]\nconst encodeDealAsUuid: E.Encoder<SerializedDeal, Deal> = {\n  encode: flow(\n    readonlyRecord.foldMapWithIndex(ord.trivial)(readonlyArray.getMonoid<CardDirectionPair>())((direction, cards) =>\n      pipe(cards,\n        readonlySet.toReadonlyArray<Card>(ord.trivial),\n        readonlyArray.map(c => [c, directions.indexOf(direction)]))),\n    readonlyArray.sort(ord.contramap((p: CardDirectionPair) => p[0])(ordCardDescending)),\n    readonlyArray.map(readonlyTuple.snd),\n    readonlyArray.chunksOf(4),\n    readonlyArray.map(readonlyArray.reduce(0, (byte, directionIndex) => (byte << 2) + directionIndex)),\n    readonlyArray.concat(readonlyArray.replicate(3, 0)),\n    readonlyArray.toArray,\n    x => (DealUuidB.decode({ id: new Uuid(x).toString() }) as either.Right<SerializedDeal>).right)\n  }\n\nexport const serializedDealL = iso.iso<Deal, SerializedDeal>(\n  encodeDealAsUuid.encode,\n  dealUuidToDeal.encode\n)\n\nexport type SerializedBoard = O.Update<Board, \"deal\", SerializedDeal>\nexport const serializedBoardL = iso.iso<Board, SerializedBoard>(\n  b => ({ ...b,\n    deal: serializedDealL.get(b.deal),\n  }),\n  b => ({ ...b,\n    deal: serializedDealL.reverseGet(b.deal),\n  })\n)\n\nexport type SerializedBidPath = t.Branded<string, { readonly BidPath: unique symbol }>\nexport const isBidPath: refinement.Refinement<string, SerializedBidPath> =\n  (s): s is SerializedBidPath =>\n    pipe(s,\n      string.split(\".\"),\n      readonlyArray.every(s => s.length === 2 || isNonContractBid(s)))\n\nexport const serializedContractBidL: iso.Iso<ContractBid, string> = iso.iso(\n  bid => `${bid.level}${bid.strain}`,\n  bid => ({\n    level: parseInt(bid.charAt(0)),\n    strain: bid.charAt(1) as Strain\n  })\n)\n\nexport const serializedBidL : iso.Iso<Bid, string> = iso.iso(\n  bid => isNonContractBid(bid) ? bid : serializedContractBidL.get(bid),\n  bid => isNonContractBid(bid) ? bid : serializedContractBidL.reverseGet(bid)\n)\n\nconst SerializedBidPathB = t.brand(t.string, isBidPath, \"BidPath\")\nexport const serializedBidPathL = iso.iso<readonlyNonEmptyArray.ReadonlyNonEmptyArray<Bid>, SerializedBidPath>(\n  flow(\n    readonlyArray.map(serializedBidL.get),\n    readonlyArray.intersperse(\".\"),\n    readonlyArray.foldMap(string.Monoid)(identity),\n    x => (SerializedBidPathB.decode(x) as either.Right<SerializedBidPath>).right),\n  flow(\n    string.split(\".\"),\n    readonlyNonEmptyArray.map(serializedBidL.reverseGet)))","/* AutoGenerated Code, changes may be overwritten\n* INPUT GRAMMAR:\n* Start := spec=BidSpec $\n* BidSpec := bid=Bid constraints=BidSpecConstraintList?\n* BidSpecConstraintList := ': ' constraints=ConstraintList\n* Bid := ContractBid | NonContractBid\n* ContractBid := level=Digit specifier=StrainSpecifier\n* StrainSpecifier := Wildcard | Major | Minor | Strain\n* Wildcard := v='X'\n* Major := v='M'\n* Minor := v='m'\n* NonContractBid := Pass\n* Pass := v='P'\n* Strain := Suit | Notrump\n* Suit := Club | Diamond | Heart | Spade\n* Club := v='C'\n* Diamond := v='D'\n* Heart := v='H'\n* Spade := v='S'\n* Notrump := v='N' 'T'?\n* Honor := v='[AKQJT]'\n* ConstraintList := ConstraintListItem+\n* ConstraintListItem := constraint=Constraint ' '?\n* Constraint :=\n*     Const\n*   | Or\n*   | And\n*   | Not\n*   | Otherwise\n*   | Distribution\n*   // | Response\n*   | SuitRange\n*   | SuitBound\n*   | SuitComparison\n*   | SuitHonors\n*   | SuitTop\n*   | SuitRank\n*   | SetTrump\n*   | PointRange\n*   | PointBound\n*   | OtherBid\n*   | LabelDef\n*   | LabelRef\n* Const := True | False\n* True := v='true'\n* False := v='false'\n* Or := left=Constraint ' or ' right=Constraint\n* And := '\\(' constraints=ConstraintList '\\)'\n* Not := {'not' | '!'} ' '? constraint=Constraint\n* Otherwise := v='else'\n* PointRange := lower=Number '-' upper=Number\n* PointBound := value=Number qualifier=BoundQualifier\n* SuitRange := lower=Digit '-' upper=Digit suit=SuitSpecifier\n* SuitBound := value=Number qualifier=BoundQualifier suit=SuitSpecifier\n* SuitSpecifier := Wildcard | Major | Minor | OtherMajor | OtherMinor | Suit\n* OtherMajor := v='oM'\n* OtherMinor := v='om'\n* SuitComparison := left=SuitSpecifier op=SuitComparisonOperator right=SuitSpecifier\n* SuitComparisonOperator := v='<=' | v='>=' | v='=' | v='<' | v='>'\n* SuitHonors := suit=SuitSpecifier honors=Honor+\n* SuitTop := suit=SuitSpecifier x='[0-5]' '/' y='[1-5]'\n* BoundQualifier := Plus | Minus | Equals\n* Plus := v='\\+'\n* Minus := v='\\-'\n* Equals := v='='\n* OtherBid := level=Number strain=Strain\n* Distribution := Balanced | SemiBalanced | Unbalanced | AnyShape | SpecificShape\n* Balanced := v='BAL'\n* SemiBalanced := v='semiBAL'\n* Unbalanced := v='unBAL'\n* AnyShape := v='[0-9]{4}' '\\*'\n* SpecificShape := S=Digit H=Digit D=Digit C=Digit\n* SuitRank := Primary | Secondary\n* Primary := suit=SuitSpecifier '1'\n* Secondary := suit=SuitSpecifier '2'\n* SetTrump := suit=SuitSpecifier '#'\n* // Response := ForceOneRound | ForceGame | ForceSlam | Relay\n* // ForceOneRound := v='F1'\n* // ForceGame := v='FG'\n* // ForceSlam := v='FS'\n* // Relay := '->' bid=OtherBid\n* LabelDef := '\\'' label=Label '\\': ' constraints=ConstraintList\n* LabelRef := '\\'' label=Label '\\''\n* Label := v='[0-9a-zA-z-_]+'\n* Digit := literal='[0-9]'\n*   .value = number { return parseInt(literal) }\n* Number := literal='[0-9]+'\n*   .value = number { return parseInt(literal) }\n*/\ntype Nullable<T> = T | null;\ntype $$RuleType<T> = () => Nullable<T>;\nexport interface ASTNodeIntf {\n    kind: ASTKinds;\n}\nexport enum ASTKinds {\n    Start = \"Start\",\n    BidSpec = \"BidSpec\",\n    BidSpecConstraintList = \"BidSpecConstraintList\",\n    Bid_1 = \"Bid_1\",\n    Bid_2 = \"Bid_2\",\n    ContractBid = \"ContractBid\",\n    StrainSpecifier_1 = \"StrainSpecifier_1\",\n    StrainSpecifier_2 = \"StrainSpecifier_2\",\n    StrainSpecifier_3 = \"StrainSpecifier_3\",\n    StrainSpecifier_4 = \"StrainSpecifier_4\",\n    Wildcard = \"Wildcard\",\n    Major = \"Major\",\n    Minor = \"Minor\",\n    NonContractBid = \"NonContractBid\",\n    Pass = \"Pass\",\n    Strain_1 = \"Strain_1\",\n    Strain_2 = \"Strain_2\",\n    Suit_1 = \"Suit_1\",\n    Suit_2 = \"Suit_2\",\n    Suit_3 = \"Suit_3\",\n    Suit_4 = \"Suit_4\",\n    Club = \"Club\",\n    Diamond = \"Diamond\",\n    Heart = \"Heart\",\n    Spade = \"Spade\",\n    Notrump = \"Notrump\",\n    Honor = \"Honor\",\n    ConstraintList = \"ConstraintList\",\n    ConstraintListItem = \"ConstraintListItem\",\n    Constraint_1 = \"Constraint_1\",\n    Constraint_2 = \"Constraint_2\",\n    Constraint_3 = \"Constraint_3\",\n    Constraint_4 = \"Constraint_4\",\n    Constraint_5 = \"Constraint_5\",\n    Constraint_6 = \"Constraint_6\",\n    Constraint_7 = \"Constraint_7\",\n    Constraint_8 = \"Constraint_8\",\n    Constraint_9 = \"Constraint_9\",\n    Constraint_10 = \"Constraint_10\",\n    Constraint_11 = \"Constraint_11\",\n    Constraint_12 = \"Constraint_12\",\n    Constraint_13 = \"Constraint_13\",\n    Constraint_14 = \"Constraint_14\",\n    Constraint_15 = \"Constraint_15\",\n    Constraint_16 = \"Constraint_16\",\n    Constraint_17 = \"Constraint_17\",\n    Constraint_18 = \"Constraint_18\",\n    Const_1 = \"Const_1\",\n    Const_2 = \"Const_2\",\n    True = \"True\",\n    False = \"False\",\n    Or = \"Or\",\n    And = \"And\",\n    Not = \"Not\",\n    Not_$0_1 = \"Not_$0_1\",\n    Not_$0_2 = \"Not_$0_2\",\n    Otherwise = \"Otherwise\",\n    PointRange = \"PointRange\",\n    PointBound = \"PointBound\",\n    SuitRange = \"SuitRange\",\n    SuitBound = \"SuitBound\",\n    SuitSpecifier_1 = \"SuitSpecifier_1\",\n    SuitSpecifier_2 = \"SuitSpecifier_2\",\n    SuitSpecifier_3 = \"SuitSpecifier_3\",\n    SuitSpecifier_4 = \"SuitSpecifier_4\",\n    SuitSpecifier_5 = \"SuitSpecifier_5\",\n    SuitSpecifier_6 = \"SuitSpecifier_6\",\n    OtherMajor = \"OtherMajor\",\n    OtherMinor = \"OtherMinor\",\n    SuitComparison = \"SuitComparison\",\n    SuitComparisonOperator_1 = \"SuitComparisonOperator_1\",\n    SuitComparisonOperator_2 = \"SuitComparisonOperator_2\",\n    SuitComparisonOperator_3 = \"SuitComparisonOperator_3\",\n    SuitComparisonOperator_4 = \"SuitComparisonOperator_4\",\n    SuitComparisonOperator_5 = \"SuitComparisonOperator_5\",\n    SuitHonors = \"SuitHonors\",\n    SuitTop = \"SuitTop\",\n    BoundQualifier_1 = \"BoundQualifier_1\",\n    BoundQualifier_2 = \"BoundQualifier_2\",\n    BoundQualifier_3 = \"BoundQualifier_3\",\n    Plus = \"Plus\",\n    Minus = \"Minus\",\n    Equals = \"Equals\",\n    OtherBid = \"OtherBid\",\n    Distribution_1 = \"Distribution_1\",\n    Distribution_2 = \"Distribution_2\",\n    Distribution_3 = \"Distribution_3\",\n    Distribution_4 = \"Distribution_4\",\n    Distribution_5 = \"Distribution_5\",\n    Balanced = \"Balanced\",\n    SemiBalanced = \"SemiBalanced\",\n    Unbalanced = \"Unbalanced\",\n    AnyShape = \"AnyShape\",\n    SpecificShape = \"SpecificShape\",\n    SuitRank_1 = \"SuitRank_1\",\n    SuitRank_2 = \"SuitRank_2\",\n    Primary = \"Primary\",\n    Secondary = \"Secondary\",\n    SetTrump = \"SetTrump\",\n    LabelDef = \"LabelDef\",\n    LabelRef = \"LabelRef\",\n    Label = \"Label\",\n    Digit = \"Digit\",\n    Number = \"Number\",\n    $EOF = \"$EOF\",\n}\nexport interface Start {\n    kind: ASTKinds.Start;\n    spec: BidSpec;\n}\nexport interface BidSpec {\n    kind: ASTKinds.BidSpec;\n    bid: Bid;\n    constraints: Nullable<BidSpecConstraintList>;\n}\nexport interface BidSpecConstraintList {\n    kind: ASTKinds.BidSpecConstraintList;\n    constraints: ConstraintList;\n}\nexport type Bid = Bid_1 | Bid_2;\nexport type Bid_1 = ContractBid;\nexport type Bid_2 = NonContractBid;\nexport interface ContractBid {\n    kind: ASTKinds.ContractBid;\n    level: Digit;\n    specifier: StrainSpecifier;\n}\nexport type StrainSpecifier = StrainSpecifier_1 | StrainSpecifier_2 | StrainSpecifier_3 | StrainSpecifier_4;\nexport type StrainSpecifier_1 = Wildcard;\nexport type StrainSpecifier_2 = Major;\nexport type StrainSpecifier_3 = Minor;\nexport type StrainSpecifier_4 = Strain;\nexport interface Wildcard {\n    kind: ASTKinds.Wildcard;\n    v: string;\n}\nexport interface Major {\n    kind: ASTKinds.Major;\n    v: string;\n}\nexport interface Minor {\n    kind: ASTKinds.Minor;\n    v: string;\n}\nexport type NonContractBid = Pass;\nexport interface Pass {\n    kind: ASTKinds.Pass;\n    v: string;\n}\nexport type Strain = Strain_1 | Strain_2;\nexport type Strain_1 = Suit;\nexport type Strain_2 = Notrump;\nexport type Suit = Suit_1 | Suit_2 | Suit_3 | Suit_4;\nexport type Suit_1 = Club;\nexport type Suit_2 = Diamond;\nexport type Suit_3 = Heart;\nexport type Suit_4 = Spade;\nexport interface Club {\n    kind: ASTKinds.Club;\n    v: string;\n}\nexport interface Diamond {\n    kind: ASTKinds.Diamond;\n    v: string;\n}\nexport interface Heart {\n    kind: ASTKinds.Heart;\n    v: string;\n}\nexport interface Spade {\n    kind: ASTKinds.Spade;\n    v: string;\n}\nexport interface Notrump {\n    kind: ASTKinds.Notrump;\n    v: string;\n}\nexport interface Honor {\n    kind: ASTKinds.Honor;\n    v: string;\n}\nexport type ConstraintList = ConstraintListItem[];\nexport interface ConstraintListItem {\n    kind: ASTKinds.ConstraintListItem;\n    constraint: Constraint;\n}\nexport type Constraint = Constraint_1 | Constraint_2 | Constraint_3 | Constraint_4 | Constraint_5 | Constraint_6 | Constraint_7 | Constraint_8 | Constraint_9 | Constraint_10 | Constraint_11 | Constraint_12 | Constraint_13 | Constraint_14 | Constraint_15 | Constraint_16 | Constraint_17 | Constraint_18;\nexport type Constraint_1 = Const;\nexport type Constraint_2 = Or;\nexport type Constraint_3 = And;\nexport type Constraint_4 = Not;\nexport type Constraint_5 = Otherwise;\nexport type Constraint_6 = Distribution;\nexport type Constraint_7 = SuitRange;\nexport type Constraint_8 = SuitBound;\nexport type Constraint_9 = SuitComparison;\nexport type Constraint_10 = SuitHonors;\nexport type Constraint_11 = SuitTop;\nexport type Constraint_12 = SuitRank;\nexport type Constraint_13 = SetTrump;\nexport type Constraint_14 = PointRange;\nexport type Constraint_15 = PointBound;\nexport type Constraint_16 = OtherBid;\nexport type Constraint_17 = LabelDef;\nexport type Constraint_18 = LabelRef;\nexport type Const = Const_1 | Const_2;\nexport type Const_1 = True;\nexport type Const_2 = False;\nexport interface True {\n    kind: ASTKinds.True;\n    v: string;\n}\nexport interface False {\n    kind: ASTKinds.False;\n    v: string;\n}\nexport interface Or {\n    kind: ASTKinds.Or;\n    left: Constraint;\n    right: Constraint;\n}\nexport interface And {\n    kind: ASTKinds.And;\n    constraints: ConstraintList;\n}\nexport interface Not {\n    kind: ASTKinds.Not;\n    constraint: Constraint;\n}\nexport type Not_$0 = Not_$0_1 | Not_$0_2;\nexport type Not_$0_1 = string;\nexport type Not_$0_2 = string;\nexport interface Otherwise {\n    kind: ASTKinds.Otherwise;\n    v: string;\n}\nexport interface PointRange {\n    kind: ASTKinds.PointRange;\n    lower: Number;\n    upper: Number;\n}\nexport interface PointBound {\n    kind: ASTKinds.PointBound;\n    value: Number;\n    qualifier: BoundQualifier;\n}\nexport interface SuitRange {\n    kind: ASTKinds.SuitRange;\n    lower: Digit;\n    upper: Digit;\n    suit: SuitSpecifier;\n}\nexport interface SuitBound {\n    kind: ASTKinds.SuitBound;\n    value: Number;\n    qualifier: BoundQualifier;\n    suit: SuitSpecifier;\n}\nexport type SuitSpecifier = SuitSpecifier_1 | SuitSpecifier_2 | SuitSpecifier_3 | SuitSpecifier_4 | SuitSpecifier_5 | SuitSpecifier_6;\nexport type SuitSpecifier_1 = Wildcard;\nexport type SuitSpecifier_2 = Major;\nexport type SuitSpecifier_3 = Minor;\nexport type SuitSpecifier_4 = OtherMajor;\nexport type SuitSpecifier_5 = OtherMinor;\nexport type SuitSpecifier_6 = Suit;\nexport interface OtherMajor {\n    kind: ASTKinds.OtherMajor;\n    v: string;\n}\nexport interface OtherMinor {\n    kind: ASTKinds.OtherMinor;\n    v: string;\n}\nexport interface SuitComparison {\n    kind: ASTKinds.SuitComparison;\n    left: SuitSpecifier;\n    op: SuitComparisonOperator;\n    right: SuitSpecifier;\n}\nexport type SuitComparisonOperator = SuitComparisonOperator_1 | SuitComparisonOperator_2 | SuitComparisonOperator_3 | SuitComparisonOperator_4 | SuitComparisonOperator_5;\nexport interface SuitComparisonOperator_1 {\n    kind: ASTKinds.SuitComparisonOperator_1;\n    v: string;\n}\nexport interface SuitComparisonOperator_2 {\n    kind: ASTKinds.SuitComparisonOperator_2;\n    v: string;\n}\nexport interface SuitComparisonOperator_3 {\n    kind: ASTKinds.SuitComparisonOperator_3;\n    v: string;\n}\nexport interface SuitComparisonOperator_4 {\n    kind: ASTKinds.SuitComparisonOperator_4;\n    v: string;\n}\nexport interface SuitComparisonOperator_5 {\n    kind: ASTKinds.SuitComparisonOperator_5;\n    v: string;\n}\nexport interface SuitHonors {\n    kind: ASTKinds.SuitHonors;\n    suit: SuitSpecifier;\n    honors: Honor[];\n}\nexport interface SuitTop {\n    kind: ASTKinds.SuitTop;\n    suit: SuitSpecifier;\n    x: string;\n    y: string;\n}\nexport type BoundQualifier = BoundQualifier_1 | BoundQualifier_2 | BoundQualifier_3;\nexport type BoundQualifier_1 = Plus;\nexport type BoundQualifier_2 = Minus;\nexport type BoundQualifier_3 = Equals;\nexport interface Plus {\n    kind: ASTKinds.Plus;\n    v: string;\n}\nexport interface Minus {\n    kind: ASTKinds.Minus;\n    v: string;\n}\nexport interface Equals {\n    kind: ASTKinds.Equals;\n    v: string;\n}\nexport interface OtherBid {\n    kind: ASTKinds.OtherBid;\n    level: Number;\n    strain: Strain;\n}\nexport type Distribution = Distribution_1 | Distribution_2 | Distribution_3 | Distribution_4 | Distribution_5;\nexport type Distribution_1 = Balanced;\nexport type Distribution_2 = SemiBalanced;\nexport type Distribution_3 = Unbalanced;\nexport type Distribution_4 = AnyShape;\nexport type Distribution_5 = SpecificShape;\nexport interface Balanced {\n    kind: ASTKinds.Balanced;\n    v: string;\n}\nexport interface SemiBalanced {\n    kind: ASTKinds.SemiBalanced;\n    v: string;\n}\nexport interface Unbalanced {\n    kind: ASTKinds.Unbalanced;\n    v: string;\n}\nexport interface AnyShape {\n    kind: ASTKinds.AnyShape;\n    v: string;\n}\nexport interface SpecificShape {\n    kind: ASTKinds.SpecificShape;\n    S: Digit;\n    H: Digit;\n    D: Digit;\n    C: Digit;\n}\nexport type SuitRank = SuitRank_1 | SuitRank_2;\nexport type SuitRank_1 = Primary;\nexport type SuitRank_2 = Secondary;\nexport interface Primary {\n    kind: ASTKinds.Primary;\n    suit: SuitSpecifier;\n}\nexport interface Secondary {\n    kind: ASTKinds.Secondary;\n    suit: SuitSpecifier;\n}\nexport interface SetTrump {\n    kind: ASTKinds.SetTrump;\n    suit: SuitSpecifier;\n}\nexport interface LabelDef {\n    kind: ASTKinds.LabelDef;\n    label: Label;\n    constraints: ConstraintList;\n}\nexport interface LabelRef {\n    kind: ASTKinds.LabelRef;\n    label: Label;\n}\nexport interface Label {\n    kind: ASTKinds.Label;\n    v: string;\n}\nexport class Digit {\n    public kind: ASTKinds.Digit = ASTKinds.Digit;\n    public literal: string;\n    public value: number;\n    constructor(literal: string){\n        this.literal = literal;\n        this.value = ((): number => {\n        return parseInt(literal)\n        })();\n    }\n}\nexport class Number {\n    public kind: ASTKinds.Number = ASTKinds.Number;\n    public literal: string;\n    public value: number;\n    constructor(literal: string){\n        this.literal = literal;\n        this.value = ((): number => {\n        return parseInt(literal)\n        })();\n    }\n}\nexport class Parser {\n    private readonly input: string;\n    private pos: PosInfo;\n    private negating: boolean = false;\n    private memoSafe: boolean = true;\n    constructor(input: string) {\n        this.pos = {overallPos: 0, line: 1, offset: 0};\n        this.input = input;\n    }\n    public reset(pos: PosInfo) {\n        this.pos = pos;\n    }\n    public finished(): boolean {\n        return this.pos.overallPos === this.input.length;\n    }\n    public clearMemos(): void {\n        this.$scope$Constraint$memo.clear();\n    }\n    protected $scope$Constraint$memo: Map<number, [Nullable<Constraint>, PosInfo]> = new Map();\n    public matchStart($$dpth: number, $$cr?: ErrorTracker): Nullable<Start> {\n        return this.run<Start>($$dpth,\n            () => {\n                let $scope$spec: Nullable<BidSpec>;\n                let $$res: Nullable<Start> = null;\n                if (true\n                    && ($scope$spec = this.matchBidSpec($$dpth + 1, $$cr)) !== null\n                    && this.match$EOF($$cr) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Start, spec: $scope$spec};\n                }\n                return $$res;\n            });\n    }\n    public matchBidSpec($$dpth: number, $$cr?: ErrorTracker): Nullable<BidSpec> {\n        return this.run<BidSpec>($$dpth,\n            () => {\n                let $scope$bid: Nullable<Bid>;\n                let $scope$constraints: Nullable<Nullable<BidSpecConstraintList>>;\n                let $$res: Nullable<BidSpec> = null;\n                if (true\n                    && ($scope$bid = this.matchBid($$dpth + 1, $$cr)) !== null\n                    && (($scope$constraints = this.matchBidSpecConstraintList($$dpth + 1, $$cr)) || true)\n                ) {\n                    $$res = {kind: ASTKinds.BidSpec, bid: $scope$bid, constraints: $scope$constraints};\n                }\n                return $$res;\n            });\n    }\n    public matchBidSpecConstraintList($$dpth: number, $$cr?: ErrorTracker): Nullable<BidSpecConstraintList> {\n        return this.run<BidSpecConstraintList>($$dpth,\n            () => {\n                let $scope$constraints: Nullable<ConstraintList>;\n                let $$res: Nullable<BidSpecConstraintList> = null;\n                if (true\n                    && this.regexAccept(String.raw`(?:: )`, $$dpth + 1, $$cr) !== null\n                    && ($scope$constraints = this.matchConstraintList($$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.BidSpecConstraintList, constraints: $scope$constraints};\n                }\n                return $$res;\n            });\n    }\n    public matchBid($$dpth: number, $$cr?: ErrorTracker): Nullable<Bid> {\n        return this.choice<Bid>([\n            () => this.matchBid_1($$dpth + 1, $$cr),\n            () => this.matchBid_2($$dpth + 1, $$cr),\n        ]);\n    }\n    public matchBid_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Bid_1> {\n        return this.matchContractBid($$dpth + 1, $$cr);\n    }\n    public matchBid_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Bid_2> {\n        return this.matchNonContractBid($$dpth + 1, $$cr);\n    }\n    public matchContractBid($$dpth: number, $$cr?: ErrorTracker): Nullable<ContractBid> {\n        return this.run<ContractBid>($$dpth,\n            () => {\n                let $scope$level: Nullable<Digit>;\n                let $scope$specifier: Nullable<StrainSpecifier>;\n                let $$res: Nullable<ContractBid> = null;\n                if (true\n                    && ($scope$level = this.matchDigit($$dpth + 1, $$cr)) !== null\n                    && ($scope$specifier = this.matchStrainSpecifier($$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.ContractBid, level: $scope$level, specifier: $scope$specifier};\n                }\n                return $$res;\n            });\n    }\n    public matchStrainSpecifier($$dpth: number, $$cr?: ErrorTracker): Nullable<StrainSpecifier> {\n        return this.choice<StrainSpecifier>([\n            () => this.matchStrainSpecifier_1($$dpth + 1, $$cr),\n            () => this.matchStrainSpecifier_2($$dpth + 1, $$cr),\n            () => this.matchStrainSpecifier_3($$dpth + 1, $$cr),\n            () => this.matchStrainSpecifier_4($$dpth + 1, $$cr),\n        ]);\n    }\n    public matchStrainSpecifier_1($$dpth: number, $$cr?: ErrorTracker): Nullable<StrainSpecifier_1> {\n        return this.matchWildcard($$dpth + 1, $$cr);\n    }\n    public matchStrainSpecifier_2($$dpth: number, $$cr?: ErrorTracker): Nullable<StrainSpecifier_2> {\n        return this.matchMajor($$dpth + 1, $$cr);\n    }\n    public matchStrainSpecifier_3($$dpth: number, $$cr?: ErrorTracker): Nullable<StrainSpecifier_3> {\n        return this.matchMinor($$dpth + 1, $$cr);\n    }\n    public matchStrainSpecifier_4($$dpth: number, $$cr?: ErrorTracker): Nullable<StrainSpecifier_4> {\n        return this.matchStrain($$dpth + 1, $$cr);\n    }\n    public matchWildcard($$dpth: number, $$cr?: ErrorTracker): Nullable<Wildcard> {\n        return this.run<Wildcard>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Wildcard> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:X)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Wildcard, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchMajor($$dpth: number, $$cr?: ErrorTracker): Nullable<Major> {\n        return this.run<Major>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Major> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:M)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Major, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchMinor($$dpth: number, $$cr?: ErrorTracker): Nullable<Minor> {\n        return this.run<Minor>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Minor> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:m)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Minor, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchNonContractBid($$dpth: number, $$cr?: ErrorTracker): Nullable<NonContractBid> {\n        return this.matchPass($$dpth + 1, $$cr);\n    }\n    public matchPass($$dpth: number, $$cr?: ErrorTracker): Nullable<Pass> {\n        return this.run<Pass>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Pass> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:P)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Pass, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchStrain($$dpth: number, $$cr?: ErrorTracker): Nullable<Strain> {\n        return this.choice<Strain>([\n            () => this.matchStrain_1($$dpth + 1, $$cr),\n            () => this.matchStrain_2($$dpth + 1, $$cr),\n        ]);\n    }\n    public matchStrain_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Strain_1> {\n        return this.matchSuit($$dpth + 1, $$cr);\n    }\n    public matchStrain_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Strain_2> {\n        return this.matchNotrump($$dpth + 1, $$cr);\n    }\n    public matchSuit($$dpth: number, $$cr?: ErrorTracker): Nullable<Suit> {\n        return this.choice<Suit>([\n            () => this.matchSuit_1($$dpth + 1, $$cr),\n            () => this.matchSuit_2($$dpth + 1, $$cr),\n            () => this.matchSuit_3($$dpth + 1, $$cr),\n            () => this.matchSuit_4($$dpth + 1, $$cr),\n        ]);\n    }\n    public matchSuit_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Suit_1> {\n        return this.matchClub($$dpth + 1, $$cr);\n    }\n    public matchSuit_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Suit_2> {\n        return this.matchDiamond($$dpth + 1, $$cr);\n    }\n    public matchSuit_3($$dpth: number, $$cr?: ErrorTracker): Nullable<Suit_3> {\n        return this.matchHeart($$dpth + 1, $$cr);\n    }\n    public matchSuit_4($$dpth: number, $$cr?: ErrorTracker): Nullable<Suit_4> {\n        return this.matchSpade($$dpth + 1, $$cr);\n    }\n    public matchClub($$dpth: number, $$cr?: ErrorTracker): Nullable<Club> {\n        return this.run<Club>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Club> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:C)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Club, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchDiamond($$dpth: number, $$cr?: ErrorTracker): Nullable<Diamond> {\n        return this.run<Diamond>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Diamond> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:D)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Diamond, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchHeart($$dpth: number, $$cr?: ErrorTracker): Nullable<Heart> {\n        return this.run<Heart>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Heart> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:H)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Heart, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchSpade($$dpth: number, $$cr?: ErrorTracker): Nullable<Spade> {\n        return this.run<Spade>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Spade> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:S)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Spade, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchNotrump($$dpth: number, $$cr?: ErrorTracker): Nullable<Notrump> {\n        return this.run<Notrump>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Notrump> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:N)`, $$dpth + 1, $$cr)) !== null\n                    && ((this.regexAccept(String.raw`(?:T)`, $$dpth + 1, $$cr)) || true)\n                ) {\n                    $$res = {kind: ASTKinds.Notrump, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchHonor($$dpth: number, $$cr?: ErrorTracker): Nullable<Honor> {\n        return this.run<Honor>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Honor> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:[AKQJT])`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Honor, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchConstraintList($$dpth: number, $$cr?: ErrorTracker): Nullable<ConstraintList> {\n        return this.loop<ConstraintListItem>(() => this.matchConstraintListItem($$dpth + 1, $$cr), false);\n    }\n    public matchConstraintListItem($$dpth: number, $$cr?: ErrorTracker): Nullable<ConstraintListItem> {\n        return this.run<ConstraintListItem>($$dpth,\n            () => {\n                let $scope$constraint: Nullable<Constraint>;\n                let $$res: Nullable<ConstraintListItem> = null;\n                if (true\n                    && ($scope$constraint = this.matchConstraint($$dpth + 1, $$cr)) !== null\n                    && ((this.regexAccept(String.raw`(?: )`, $$dpth + 1, $$cr)) || true)\n                ) {\n                    $$res = {kind: ASTKinds.ConstraintListItem, constraint: $scope$constraint};\n                }\n                return $$res;\n            });\n    }\n    public matchConstraint($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint> {\n        const fn = () => {\n            return this.choice<Constraint>([\n                () => this.matchConstraint_1($$dpth + 1, $$cr),\n                () => this.matchConstraint_2($$dpth + 1, $$cr),\n                () => this.matchConstraint_3($$dpth + 1, $$cr),\n                () => this.matchConstraint_4($$dpth + 1, $$cr),\n                () => this.matchConstraint_5($$dpth + 1, $$cr),\n                () => this.matchConstraint_6($$dpth + 1, $$cr),\n                () => this.matchConstraint_7($$dpth + 1, $$cr),\n                () => this.matchConstraint_8($$dpth + 1, $$cr),\n                () => this.matchConstraint_9($$dpth + 1, $$cr),\n                () => this.matchConstraint_10($$dpth + 1, $$cr),\n                () => this.matchConstraint_11($$dpth + 1, $$cr),\n                () => this.matchConstraint_12($$dpth + 1, $$cr),\n                () => this.matchConstraint_13($$dpth + 1, $$cr),\n                () => this.matchConstraint_14($$dpth + 1, $$cr),\n                () => this.matchConstraint_15($$dpth + 1, $$cr),\n                () => this.matchConstraint_16($$dpth + 1, $$cr),\n                () => this.matchConstraint_17($$dpth + 1, $$cr),\n                () => this.matchConstraint_18($$dpth + 1, $$cr),\n            ]);\n        };\n        const $scope$pos = this.mark();\n        const memo = this.$scope$Constraint$memo.get($scope$pos.overallPos);\n        if(memo !== undefined) {\n            this.reset(memo[1]);\n            return memo[0];\n        }\n        const $scope$oldMemoSafe = this.memoSafe;\n        this.memoSafe = false;\n        this.$scope$Constraint$memo.set($scope$pos.overallPos, [null, $scope$pos]);\n        let lastRes: Nullable<Constraint> = null;\n        let lastPos: PosInfo = $scope$pos;\n        for(;;) {\n            this.reset($scope$pos);\n            const res = fn();\n            const end = this.mark();\n            if(end.overallPos <= lastPos.overallPos)\n                break;\n            lastRes = res;\n            lastPos = end;\n            this.$scope$Constraint$memo.set($scope$pos.overallPos, [lastRes, lastPos]);\n        }\n        this.reset(lastPos);\n        this.memoSafe = $scope$oldMemoSafe;\n        return lastRes;\n    }\n    public matchConstraint_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_1> {\n        return this.matchConst($$dpth + 1, $$cr);\n    }\n    public matchConstraint_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_2> {\n        return this.matchOr($$dpth + 1, $$cr);\n    }\n    public matchConstraint_3($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_3> {\n        return this.matchAnd($$dpth + 1, $$cr);\n    }\n    public matchConstraint_4($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_4> {\n        return this.matchNot($$dpth + 1, $$cr);\n    }\n    public matchConstraint_5($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_5> {\n        return this.matchOtherwise($$dpth + 1, $$cr);\n    }\n    public matchConstraint_6($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_6> {\n        return this.matchDistribution($$dpth + 1, $$cr);\n    }\n    public matchConstraint_7($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_7> {\n        return this.matchSuitRange($$dpth + 1, $$cr);\n    }\n    public matchConstraint_8($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_8> {\n        return this.matchSuitBound($$dpth + 1, $$cr);\n    }\n    public matchConstraint_9($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_9> {\n        return this.matchSuitComparison($$dpth + 1, $$cr);\n    }\n    public matchConstraint_10($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_10> {\n        return this.matchSuitHonors($$dpth + 1, $$cr);\n    }\n    public matchConstraint_11($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_11> {\n        return this.matchSuitTop($$dpth + 1, $$cr);\n    }\n    public matchConstraint_12($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_12> {\n        return this.matchSuitRank($$dpth + 1, $$cr);\n    }\n    public matchConstraint_13($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_13> {\n        return this.matchSetTrump($$dpth + 1, $$cr);\n    }\n    public matchConstraint_14($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_14> {\n        return this.matchPointRange($$dpth + 1, $$cr);\n    }\n    public matchConstraint_15($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_15> {\n        return this.matchPointBound($$dpth + 1, $$cr);\n    }\n    public matchConstraint_16($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_16> {\n        return this.matchOtherBid($$dpth + 1, $$cr);\n    }\n    public matchConstraint_17($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_17> {\n        return this.matchLabelDef($$dpth + 1, $$cr);\n    }\n    public matchConstraint_18($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_18> {\n        return this.matchLabelRef($$dpth + 1, $$cr);\n    }\n    public matchConst($$dpth: number, $$cr?: ErrorTracker): Nullable<Const> {\n        return this.choice<Const>([\n            () => this.matchConst_1($$dpth + 1, $$cr),\n            () => this.matchConst_2($$dpth + 1, $$cr),\n        ]);\n    }\n    public matchConst_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Const_1> {\n        return this.matchTrue($$dpth + 1, $$cr);\n    }\n    public matchConst_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Const_2> {\n        return this.matchFalse($$dpth + 1, $$cr);\n    }\n    public matchTrue($$dpth: number, $$cr?: ErrorTracker): Nullable<True> {\n        return this.run<True>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<True> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:true)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.True, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchFalse($$dpth: number, $$cr?: ErrorTracker): Nullable<False> {\n        return this.run<False>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<False> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:false)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.False, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchOr($$dpth: number, $$cr?: ErrorTracker): Nullable<Or> {\n        return this.run<Or>($$dpth,\n            () => {\n                let $scope$left: Nullable<Constraint>;\n                let $scope$right: Nullable<Constraint>;\n                let $$res: Nullable<Or> = null;\n                if (true\n                    && ($scope$left = this.matchConstraint($$dpth + 1, $$cr)) !== null\n                    && this.regexAccept(String.raw`(?: or )`, $$dpth + 1, $$cr) !== null\n                    && ($scope$right = this.matchConstraint($$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Or, left: $scope$left, right: $scope$right};\n                }\n                return $$res;\n            });\n    }\n    public matchAnd($$dpth: number, $$cr?: ErrorTracker): Nullable<And> {\n        return this.run<And>($$dpth,\n            () => {\n                let $scope$constraints: Nullable<ConstraintList>;\n                let $$res: Nullable<And> = null;\n                if (true\n                    && this.regexAccept(String.raw`(?:\\()`, $$dpth + 1, $$cr) !== null\n                    && ($scope$constraints = this.matchConstraintList($$dpth + 1, $$cr)) !== null\n                    && this.regexAccept(String.raw`(?:\\))`, $$dpth + 1, $$cr) !== null\n                ) {\n                    $$res = {kind: ASTKinds.And, constraints: $scope$constraints};\n                }\n                return $$res;\n            });\n    }\n    public matchNot($$dpth: number, $$cr?: ErrorTracker): Nullable<Not> {\n        return this.run<Not>($$dpth,\n            () => {\n                let $scope$constraint: Nullable<Constraint>;\n                let $$res: Nullable<Not> = null;\n                if (true\n                    && this.matchNot_$0($$dpth + 1, $$cr) !== null\n                    && ((this.regexAccept(String.raw`(?: )`, $$dpth + 1, $$cr)) || true)\n                    && ($scope$constraint = this.matchConstraint($$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Not, constraint: $scope$constraint};\n                }\n                return $$res;\n            });\n    }\n    public matchNot_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Not_$0> {\n        return this.choice<Not_$0>([\n            () => this.matchNot_$0_1($$dpth + 1, $$cr),\n            () => this.matchNot_$0_2($$dpth + 1, $$cr),\n        ]);\n    }\n    public matchNot_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Not_$0_1> {\n        return this.regexAccept(String.raw`(?:not)`, $$dpth + 1, $$cr);\n    }\n    public matchNot_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Not_$0_2> {\n        return this.regexAccept(String.raw`(?:!)`, $$dpth + 1, $$cr);\n    }\n    public matchOtherwise($$dpth: number, $$cr?: ErrorTracker): Nullable<Otherwise> {\n        return this.run<Otherwise>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Otherwise> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:else)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Otherwise, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchPointRange($$dpth: number, $$cr?: ErrorTracker): Nullable<PointRange> {\n        return this.run<PointRange>($$dpth,\n            () => {\n                let $scope$lower: Nullable<Number>;\n                let $scope$upper: Nullable<Number>;\n                let $$res: Nullable<PointRange> = null;\n                if (true\n                    && ($scope$lower = this.matchNumber($$dpth + 1, $$cr)) !== null\n                    && this.regexAccept(String.raw`(?:-)`, $$dpth + 1, $$cr) !== null\n                    && ($scope$upper = this.matchNumber($$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.PointRange, lower: $scope$lower, upper: $scope$upper};\n                }\n                return $$res;\n            });\n    }\n    public matchPointBound($$dpth: number, $$cr?: ErrorTracker): Nullable<PointBound> {\n        return this.run<PointBound>($$dpth,\n            () => {\n                let $scope$value: Nullable<Number>;\n                let $scope$qualifier: Nullable<BoundQualifier>;\n                let $$res: Nullable<PointBound> = null;\n                if (true\n                    && ($scope$value = this.matchNumber($$dpth + 1, $$cr)) !== null\n                    && ($scope$qualifier = this.matchBoundQualifier($$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.PointBound, value: $scope$value, qualifier: $scope$qualifier};\n                }\n                return $$res;\n            });\n    }\n    public matchSuitRange($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitRange> {\n        return this.run<SuitRange>($$dpth,\n            () => {\n                let $scope$lower: Nullable<Digit>;\n                let $scope$upper: Nullable<Digit>;\n                let $scope$suit: Nullable<SuitSpecifier>;\n                let $$res: Nullable<SuitRange> = null;\n                if (true\n                    && ($scope$lower = this.matchDigit($$dpth + 1, $$cr)) !== null\n                    && this.regexAccept(String.raw`(?:-)`, $$dpth + 1, $$cr) !== null\n                    && ($scope$upper = this.matchDigit($$dpth + 1, $$cr)) !== null\n                    && ($scope$suit = this.matchSuitSpecifier($$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.SuitRange, lower: $scope$lower, upper: $scope$upper, suit: $scope$suit};\n                }\n                return $$res;\n            });\n    }\n    public matchSuitBound($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitBound> {\n        return this.run<SuitBound>($$dpth,\n            () => {\n                let $scope$value: Nullable<Number>;\n                let $scope$qualifier: Nullable<BoundQualifier>;\n                let $scope$suit: Nullable<SuitSpecifier>;\n                let $$res: Nullable<SuitBound> = null;\n                if (true\n                    && ($scope$value = this.matchNumber($$dpth + 1, $$cr)) !== null\n                    && ($scope$qualifier = this.matchBoundQualifier($$dpth + 1, $$cr)) !== null\n                    && ($scope$suit = this.matchSuitSpecifier($$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.SuitBound, value: $scope$value, qualifier: $scope$qualifier, suit: $scope$suit};\n                }\n                return $$res;\n            });\n    }\n    public matchSuitSpecifier($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitSpecifier> {\n        return this.choice<SuitSpecifier>([\n            () => this.matchSuitSpecifier_1($$dpth + 1, $$cr),\n            () => this.matchSuitSpecifier_2($$dpth + 1, $$cr),\n            () => this.matchSuitSpecifier_3($$dpth + 1, $$cr),\n            () => this.matchSuitSpecifier_4($$dpth + 1, $$cr),\n            () => this.matchSuitSpecifier_5($$dpth + 1, $$cr),\n            () => this.matchSuitSpecifier_6($$dpth + 1, $$cr),\n        ]);\n    }\n    public matchSuitSpecifier_1($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitSpecifier_1> {\n        return this.matchWildcard($$dpth + 1, $$cr);\n    }\n    public matchSuitSpecifier_2($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitSpecifier_2> {\n        return this.matchMajor($$dpth + 1, $$cr);\n    }\n    public matchSuitSpecifier_3($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitSpecifier_3> {\n        return this.matchMinor($$dpth + 1, $$cr);\n    }\n    public matchSuitSpecifier_4($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitSpecifier_4> {\n        return this.matchOtherMajor($$dpth + 1, $$cr);\n    }\n    public matchSuitSpecifier_5($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitSpecifier_5> {\n        return this.matchOtherMinor($$dpth + 1, $$cr);\n    }\n    public matchSuitSpecifier_6($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitSpecifier_6> {\n        return this.matchSuit($$dpth + 1, $$cr);\n    }\n    public matchOtherMajor($$dpth: number, $$cr?: ErrorTracker): Nullable<OtherMajor> {\n        return this.run<OtherMajor>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<OtherMajor> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:oM)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.OtherMajor, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchOtherMinor($$dpth: number, $$cr?: ErrorTracker): Nullable<OtherMinor> {\n        return this.run<OtherMinor>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<OtherMinor> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:om)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.OtherMinor, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchSuitComparison($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitComparison> {\n        return this.run<SuitComparison>($$dpth,\n            () => {\n                let $scope$left: Nullable<SuitSpecifier>;\n                let $scope$op: Nullable<SuitComparisonOperator>;\n                let $scope$right: Nullable<SuitSpecifier>;\n                let $$res: Nullable<SuitComparison> = null;\n                if (true\n                    && ($scope$left = this.matchSuitSpecifier($$dpth + 1, $$cr)) !== null\n                    && ($scope$op = this.matchSuitComparisonOperator($$dpth + 1, $$cr)) !== null\n                    && ($scope$right = this.matchSuitSpecifier($$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.SuitComparison, left: $scope$left, op: $scope$op, right: $scope$right};\n                }\n                return $$res;\n            });\n    }\n    public matchSuitComparisonOperator($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitComparisonOperator> {\n        return this.choice<SuitComparisonOperator>([\n            () => this.matchSuitComparisonOperator_1($$dpth + 1, $$cr),\n            () => this.matchSuitComparisonOperator_2($$dpth + 1, $$cr),\n            () => this.matchSuitComparisonOperator_3($$dpth + 1, $$cr),\n            () => this.matchSuitComparisonOperator_4($$dpth + 1, $$cr),\n            () => this.matchSuitComparisonOperator_5($$dpth + 1, $$cr),\n        ]);\n    }\n    public matchSuitComparisonOperator_1($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitComparisonOperator_1> {\n        return this.run<SuitComparisonOperator_1>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<SuitComparisonOperator_1> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:<=)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.SuitComparisonOperator_1, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchSuitComparisonOperator_2($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitComparisonOperator_2> {\n        return this.run<SuitComparisonOperator_2>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<SuitComparisonOperator_2> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:>=)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.SuitComparisonOperator_2, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchSuitComparisonOperator_3($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitComparisonOperator_3> {\n        return this.run<SuitComparisonOperator_3>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<SuitComparisonOperator_3> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:=)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.SuitComparisonOperator_3, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchSuitComparisonOperator_4($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitComparisonOperator_4> {\n        return this.run<SuitComparisonOperator_4>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<SuitComparisonOperator_4> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:<)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.SuitComparisonOperator_4, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchSuitComparisonOperator_5($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitComparisonOperator_5> {\n        return this.run<SuitComparisonOperator_5>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<SuitComparisonOperator_5> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:>)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.SuitComparisonOperator_5, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchSuitHonors($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitHonors> {\n        return this.run<SuitHonors>($$dpth,\n            () => {\n                let $scope$suit: Nullable<SuitSpecifier>;\n                let $scope$honors: Nullable<Honor[]>;\n                let $$res: Nullable<SuitHonors> = null;\n                if (true\n                    && ($scope$suit = this.matchSuitSpecifier($$dpth + 1, $$cr)) !== null\n                    && ($scope$honors = this.loop<Honor>(() => this.matchHonor($$dpth + 1, $$cr), false)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.SuitHonors, suit: $scope$suit, honors: $scope$honors};\n                }\n                return $$res;\n            });\n    }\n    public matchSuitTop($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitTop> {\n        return this.run<SuitTop>($$dpth,\n            () => {\n                let $scope$suit: Nullable<SuitSpecifier>;\n                let $scope$x: Nullable<string>;\n                let $scope$y: Nullable<string>;\n                let $$res: Nullable<SuitTop> = null;\n                if (true\n                    && ($scope$suit = this.matchSuitSpecifier($$dpth + 1, $$cr)) !== null\n                    && ($scope$x = this.regexAccept(String.raw`(?:[0-5])`, $$dpth + 1, $$cr)) !== null\n                    && this.regexAccept(String.raw`(?:/)`, $$dpth + 1, $$cr) !== null\n                    && ($scope$y = this.regexAccept(String.raw`(?:[1-5])`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.SuitTop, suit: $scope$suit, x: $scope$x, y: $scope$y};\n                }\n                return $$res;\n            });\n    }\n    public matchBoundQualifier($$dpth: number, $$cr?: ErrorTracker): Nullable<BoundQualifier> {\n        return this.choice<BoundQualifier>([\n            () => this.matchBoundQualifier_1($$dpth + 1, $$cr),\n            () => this.matchBoundQualifier_2($$dpth + 1, $$cr),\n            () => this.matchBoundQualifier_3($$dpth + 1, $$cr),\n        ]);\n    }\n    public matchBoundQualifier_1($$dpth: number, $$cr?: ErrorTracker): Nullable<BoundQualifier_1> {\n        return this.matchPlus($$dpth + 1, $$cr);\n    }\n    public matchBoundQualifier_2($$dpth: number, $$cr?: ErrorTracker): Nullable<BoundQualifier_2> {\n        return this.matchMinus($$dpth + 1, $$cr);\n    }\n    public matchBoundQualifier_3($$dpth: number, $$cr?: ErrorTracker): Nullable<BoundQualifier_3> {\n        return this.matchEquals($$dpth + 1, $$cr);\n    }\n    public matchPlus($$dpth: number, $$cr?: ErrorTracker): Nullable<Plus> {\n        return this.run<Plus>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Plus> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:\\+)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Plus, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchMinus($$dpth: number, $$cr?: ErrorTracker): Nullable<Minus> {\n        return this.run<Minus>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Minus> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:\\-)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Minus, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchEquals($$dpth: number, $$cr?: ErrorTracker): Nullable<Equals> {\n        return this.run<Equals>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Equals> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:=)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Equals, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchOtherBid($$dpth: number, $$cr?: ErrorTracker): Nullable<OtherBid> {\n        return this.run<OtherBid>($$dpth,\n            () => {\n                let $scope$level: Nullable<Number>;\n                let $scope$strain: Nullable<Strain>;\n                let $$res: Nullable<OtherBid> = null;\n                if (true\n                    && ($scope$level = this.matchNumber($$dpth + 1, $$cr)) !== null\n                    && ($scope$strain = this.matchStrain($$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.OtherBid, level: $scope$level, strain: $scope$strain};\n                }\n                return $$res;\n            });\n    }\n    public matchDistribution($$dpth: number, $$cr?: ErrorTracker): Nullable<Distribution> {\n        return this.choice<Distribution>([\n            () => this.matchDistribution_1($$dpth + 1, $$cr),\n            () => this.matchDistribution_2($$dpth + 1, $$cr),\n            () => this.matchDistribution_3($$dpth + 1, $$cr),\n            () => this.matchDistribution_4($$dpth + 1, $$cr),\n            () => this.matchDistribution_5($$dpth + 1, $$cr),\n        ]);\n    }\n    public matchDistribution_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Distribution_1> {\n        return this.matchBalanced($$dpth + 1, $$cr);\n    }\n    public matchDistribution_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Distribution_2> {\n        return this.matchSemiBalanced($$dpth + 1, $$cr);\n    }\n    public matchDistribution_3($$dpth: number, $$cr?: ErrorTracker): Nullable<Distribution_3> {\n        return this.matchUnbalanced($$dpth + 1, $$cr);\n    }\n    public matchDistribution_4($$dpth: number, $$cr?: ErrorTracker): Nullable<Distribution_4> {\n        return this.matchAnyShape($$dpth + 1, $$cr);\n    }\n    public matchDistribution_5($$dpth: number, $$cr?: ErrorTracker): Nullable<Distribution_5> {\n        return this.matchSpecificShape($$dpth + 1, $$cr);\n    }\n    public matchBalanced($$dpth: number, $$cr?: ErrorTracker): Nullable<Balanced> {\n        return this.run<Balanced>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Balanced> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:BAL)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Balanced, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchSemiBalanced($$dpth: number, $$cr?: ErrorTracker): Nullable<SemiBalanced> {\n        return this.run<SemiBalanced>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<SemiBalanced> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:semiBAL)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.SemiBalanced, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchUnbalanced($$dpth: number, $$cr?: ErrorTracker): Nullable<Unbalanced> {\n        return this.run<Unbalanced>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Unbalanced> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:unBAL)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Unbalanced, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchAnyShape($$dpth: number, $$cr?: ErrorTracker): Nullable<AnyShape> {\n        return this.run<AnyShape>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<AnyShape> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:[0-9]{4})`, $$dpth + 1, $$cr)) !== null\n                    && this.regexAccept(String.raw`(?:\\*)`, $$dpth + 1, $$cr) !== null\n                ) {\n                    $$res = {kind: ASTKinds.AnyShape, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchSpecificShape($$dpth: number, $$cr?: ErrorTracker): Nullable<SpecificShape> {\n        return this.run<SpecificShape>($$dpth,\n            () => {\n                let $scope$S: Nullable<Digit>;\n                let $scope$H: Nullable<Digit>;\n                let $scope$D: Nullable<Digit>;\n                let $scope$C: Nullable<Digit>;\n                let $$res: Nullable<SpecificShape> = null;\n                if (true\n                    && ($scope$S = this.matchDigit($$dpth + 1, $$cr)) !== null\n                    && ($scope$H = this.matchDigit($$dpth + 1, $$cr)) !== null\n                    && ($scope$D = this.matchDigit($$dpth + 1, $$cr)) !== null\n                    && ($scope$C = this.matchDigit($$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.SpecificShape, S: $scope$S, H: $scope$H, D: $scope$D, C: $scope$C};\n                }\n                return $$res;\n            });\n    }\n    public matchSuitRank($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitRank> {\n        return this.choice<SuitRank>([\n            () => this.matchSuitRank_1($$dpth + 1, $$cr),\n            () => this.matchSuitRank_2($$dpth + 1, $$cr),\n        ]);\n    }\n    public matchSuitRank_1($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitRank_1> {\n        return this.matchPrimary($$dpth + 1, $$cr);\n    }\n    public matchSuitRank_2($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitRank_2> {\n        return this.matchSecondary($$dpth + 1, $$cr);\n    }\n    public matchPrimary($$dpth: number, $$cr?: ErrorTracker): Nullable<Primary> {\n        return this.run<Primary>($$dpth,\n            () => {\n                let $scope$suit: Nullable<SuitSpecifier>;\n                let $$res: Nullable<Primary> = null;\n                if (true\n                    && ($scope$suit = this.matchSuitSpecifier($$dpth + 1, $$cr)) !== null\n                    && this.regexAccept(String.raw`(?:1)`, $$dpth + 1, $$cr) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Primary, suit: $scope$suit};\n                }\n                return $$res;\n            });\n    }\n    public matchSecondary($$dpth: number, $$cr?: ErrorTracker): Nullable<Secondary> {\n        return this.run<Secondary>($$dpth,\n            () => {\n                let $scope$suit: Nullable<SuitSpecifier>;\n                let $$res: Nullable<Secondary> = null;\n                if (true\n                    && ($scope$suit = this.matchSuitSpecifier($$dpth + 1, $$cr)) !== null\n                    && this.regexAccept(String.raw`(?:2)`, $$dpth + 1, $$cr) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Secondary, suit: $scope$suit};\n                }\n                return $$res;\n            });\n    }\n    public matchSetTrump($$dpth: number, $$cr?: ErrorTracker): Nullable<SetTrump> {\n        return this.run<SetTrump>($$dpth,\n            () => {\n                let $scope$suit: Nullable<SuitSpecifier>;\n                let $$res: Nullable<SetTrump> = null;\n                if (true\n                    && ($scope$suit = this.matchSuitSpecifier($$dpth + 1, $$cr)) !== null\n                    && this.regexAccept(String.raw`(?:#)`, $$dpth + 1, $$cr) !== null\n                ) {\n                    $$res = {kind: ASTKinds.SetTrump, suit: $scope$suit};\n                }\n                return $$res;\n            });\n    }\n    public matchLabelDef($$dpth: number, $$cr?: ErrorTracker): Nullable<LabelDef> {\n        return this.run<LabelDef>($$dpth,\n            () => {\n                let $scope$label: Nullable<Label>;\n                let $scope$constraints: Nullable<ConstraintList>;\n                let $$res: Nullable<LabelDef> = null;\n                if (true\n                    && this.regexAccept(String.raw`(?:\\')`, $$dpth + 1, $$cr) !== null\n                    && ($scope$label = this.matchLabel($$dpth + 1, $$cr)) !== null\n                    && this.regexAccept(String.raw`(?:\\': )`, $$dpth + 1, $$cr) !== null\n                    && ($scope$constraints = this.matchConstraintList($$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.LabelDef, label: $scope$label, constraints: $scope$constraints};\n                }\n                return $$res;\n            });\n    }\n    public matchLabelRef($$dpth: number, $$cr?: ErrorTracker): Nullable<LabelRef> {\n        return this.run<LabelRef>($$dpth,\n            () => {\n                let $scope$label: Nullable<Label>;\n                let $$res: Nullable<LabelRef> = null;\n                if (true\n                    && this.regexAccept(String.raw`(?:\\')`, $$dpth + 1, $$cr) !== null\n                    && ($scope$label = this.matchLabel($$dpth + 1, $$cr)) !== null\n                    && this.regexAccept(String.raw`(?:\\')`, $$dpth + 1, $$cr) !== null\n                ) {\n                    $$res = {kind: ASTKinds.LabelRef, label: $scope$label};\n                }\n                return $$res;\n            });\n    }\n    public matchLabel($$dpth: number, $$cr?: ErrorTracker): Nullable<Label> {\n        return this.run<Label>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Label> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:[0-9a-zA-z-_]+)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Label, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchDigit($$dpth: number, $$cr?: ErrorTracker): Nullable<Digit> {\n        return this.run<Digit>($$dpth,\n            () => {\n                let $scope$literal: Nullable<string>;\n                let $$res: Nullable<Digit> = null;\n                if (true\n                    && ($scope$literal = this.regexAccept(String.raw`(?:[0-9])`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = new Digit($scope$literal);\n                }\n                return $$res;\n            });\n    }\n    public matchNumber($$dpth: number, $$cr?: ErrorTracker): Nullable<Number> {\n        return this.run<Number>($$dpth,\n            () => {\n                let $scope$literal: Nullable<string>;\n                let $$res: Nullable<Number> = null;\n                if (true\n                    && ($scope$literal = this.regexAccept(String.raw`(?:[0-9]+)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = new Number($scope$literal);\n                }\n                return $$res;\n            });\n    }\n    public test(): boolean {\n        const mrk = this.mark();\n        const res = this.matchStart(0);\n        const ans = res !== null;\n        this.reset(mrk);\n        return ans;\n    }\n    public parse(): ParseResult {\n        const mrk = this.mark();\n        const res = this.matchStart(0);\n        if (res)\n            return {ast: res, errs: []};\n        this.reset(mrk);\n        const rec = new ErrorTracker();\n        this.clearMemos();\n        this.matchStart(0, rec);\n        const err = rec.getErr()\n        return {ast: res, errs: err !== null ? [err] : []}\n    }\n    public mark(): PosInfo {\n        return this.pos;\n    }\n    private loop<T>(func: $$RuleType<T>, star: boolean = false): Nullable<T[]> {\n        const mrk = this.mark();\n        const res: T[] = [];\n        for (;;) {\n            const t = func();\n            if (t === null) {\n                break;\n            }\n            res.push(t);\n        }\n        if (star || res.length > 0) {\n            return res;\n        }\n        this.reset(mrk);\n        return null;\n    }\n    private run<T>($$dpth: number, fn: $$RuleType<T>): Nullable<T> {\n        const mrk = this.mark();\n        const res = fn()\n        if (res !== null)\n            return res;\n        this.reset(mrk);\n        return null;\n    }\n    private choice<T>(fns: Array<$$RuleType<T>>): Nullable<T> {\n        for (const f of fns) {\n            const res = f();\n            if (res !== null) {\n                return res;\n            }\n        }\n        return null;\n    }\n    private regexAccept(match: string, dpth: number, cr?: ErrorTracker): Nullable<string> {\n        return this.run<string>(dpth,\n            () => {\n                const reg = new RegExp(match, \"y\");\n                const mrk = this.mark();\n                reg.lastIndex = mrk.overallPos;\n                const res = this.tryConsume(reg);\n                if(cr) {\n                    cr.record(mrk, res, {\n                        kind: \"RegexMatch\",\n                        // We substring from 3 to len - 1 to strip off the\n                        // non-capture group syntax added as a WebKit workaround\n                        literal: match.substring(3, match.length - 1),\n                        negated: this.negating,\n                    });\n                }\n                return res;\n            });\n    }\n    private tryConsume(reg: RegExp): Nullable<string> {\n        const res = reg.exec(this.input);\n        if (res) {\n            let lineJmp = 0;\n            let lind = -1;\n            for (let i = 0; i < res[0].length; ++i) {\n                if (res[0][i] === \"\\n\") {\n                    ++lineJmp;\n                    lind = i;\n                }\n            }\n            this.pos = {\n                overallPos: reg.lastIndex,\n                line: this.pos.line + lineJmp,\n                offset: lind === -1 ? this.pos.offset + res[0].length : (res[0].length - lind - 1)\n            };\n            return res[0];\n        }\n        return null;\n    }\n    private noConsume<T>(fn: $$RuleType<T>): Nullable<T> {\n        const mrk = this.mark();\n        const res = fn();\n        this.reset(mrk);\n        return res;\n    }\n    private negate<T>(fn: $$RuleType<T>): Nullable<boolean> {\n        const mrk = this.mark();\n        const oneg = this.negating;\n        this.negating = !oneg;\n        const res = fn();\n        this.negating = oneg;\n        this.reset(mrk);\n        return res === null ? true : null;\n    }\n    private memoise<K>(rule: $$RuleType<K>, memo: Map<number, [Nullable<K>, PosInfo]>): Nullable<K> {\n        const $scope$pos = this.mark();\n        const $scope$memoRes = memo.get($scope$pos.overallPos);\n        if(this.memoSafe && $scope$memoRes !== undefined) {\n        this.reset($scope$memoRes[1]);\n        return $scope$memoRes[0];\n        }\n        const $scope$result = rule();\n        if(this.memoSafe)\n        memo.set($scope$pos.overallPos, [$scope$result, this.mark()]);\n        return $scope$result;\n    }\n    private match$EOF(et?: ErrorTracker): Nullable<{kind: ASTKinds.$EOF}> {\n        const res: {kind: ASTKinds.$EOF} | null = this.finished() ? { kind: ASTKinds.$EOF } : null;\n        if(et)\n            et.record(this.mark(), res, { kind: \"EOF\", negated: this.negating });\n        return res;\n    }\n}\nexport function parse(s: string): ParseResult {\n    const p = new Parser(s);\n    return p.parse();\n}\nexport interface ParseResult {\n    ast: Nullable<Start>;\n    errs: SyntaxErr[];\n}\nexport interface PosInfo {\n    readonly overallPos: number;\n    readonly line: number;\n    readonly offset: number;\n}\nexport interface RegexMatch {\n    readonly kind: \"RegexMatch\";\n    readonly negated: boolean;\n    readonly literal: string;\n}\nexport type EOFMatch = { kind: \"EOF\"; negated: boolean };\nexport type MatchAttempt = RegexMatch | EOFMatch;\nexport class SyntaxErr {\n    public pos: PosInfo;\n    public expmatches: MatchAttempt[];\n    constructor(pos: PosInfo, expmatches: MatchAttempt[]) {\n        this.pos = pos;\n        this.expmatches = [...expmatches];\n    }\n    public toString(): string {\n        return `Syntax Error at line ${this.pos.line}:${this.pos.offset}. Expected one of ${this.expmatches.map(x => x.kind === \"EOF\" ? \" EOF\" : ` ${x.negated ? 'not ': ''}'${x.literal}'`)}`;\n    }\n}\nclass ErrorTracker {\n    private mxpos: PosInfo = {overallPos: -1, line: -1, offset: -1};\n    private regexset: Set<string> = new Set();\n    private pmatches: MatchAttempt[] = [];\n    public record(pos: PosInfo, result: any, att: MatchAttempt) {\n        if ((result === null) === att.negated)\n            return;\n        if (pos.overallPos > this.mxpos.overallPos) {\n            this.mxpos = pos;\n            this.pmatches = [];\n            this.regexset.clear()\n        }\n        if (this.mxpos.overallPos === pos.overallPos) {\n            if(att.kind === \"RegexMatch\") {\n                if(!this.regexset.has(att.literal))\n                    this.pmatches.push(att);\n                this.regexset.add(att.literal);\n            } else {\n                this.pmatches.push(att);\n            }\n        }\n    }\n    public getErr(): SyntaxErr | null {\n        if (this.mxpos.overallPos !== -1)\n            return new SyntaxErr(this.mxpos, this.pmatches);\n        return null;\n    }\n}","import { number, ord, readonlyNonEmptyArray } from 'fp-ts';\nimport { flow, pipe } from 'fp-ts/lib/function';\n\nexport const assertUnreachable = (x: never) => {\n  throw new Error (`shouldn't get here with ${JSON.stringify(x)}`)\n}\n\nexport const debug = <T>(x: T) => { debugger; return x }\n\nexport const ordAscending = <T>(array: readonlyNonEmptyArray.ReadonlyNonEmptyArray<T>) =>\n  pipe(number.Ord, ord.contramap<number, T>(x => array.indexOf(x)))\n\nexport const ordDescending = flow(ordAscending, ord.reverse)\n\n","import { either, eq, number, option, ord, readonlyArray, readonlyNonEmptyArray as RNEA, readonlyRecord, readonlySet, string } from 'fp-ts';\nimport { flow, pipe } from 'fp-ts/lib/function';\nimport * as t from 'io-ts';\nimport { MersenneTwister19937, shuffle } from 'random-js';\n\nimport { ordAscending, ordDescending } from '../lib';\n\nexport const suits = ['C', 'D', 'H', 'S'] as const\nexport type Suit = typeof suits[number]\nexport const eqSuit : eq.Eq<Suit> = eq.eqStrict\nexport const ordSuitDescending : ord.Ord<Suit> = ordDescending(suits)\nexport const ordSuitAscending : ord.Ord<Suit> = ordAscending(suits)\n\nexport const rankStrings = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'] as const\nexport type RankString = typeof rankStrings[number]\nconst RankB = t.brand(t.number, (i) : i is t.Branded<number, { readonly Rank: unique symbol }> => i >= 2 && i <= 14, 'Rank')\nexport const RankC = new t.Type('Rank', RankB.is, RankB.validate, r => rankStrings[r - 2])\nexport type Rank = t.TypeOf<typeof RankC>\nexport const eqRank : eq.Eq<Rank> = eq.eqStrict\nexport const ordRankAscending : ord.Ord<Rank> = number.Ord\nexport const ordRankDescending : ord.Ord<Rank> = pipe(ordRankAscending, ord.reverse)\nexport const ranks =\n  pipe(rankStrings,\n    readonlyArray.mapWithIndex((idx, _) =>\n      pipe(idx + 2,\n        RankC.decode,\n        x => (x as either.Right<Rank>).right)))\nexport const honors =\n  pipe(ranks, readonlyArray.takeRight(5))\nexport const rankFromString = (r: string) =>\n  pipe(rankStrings,\n    readonlyArray.findIndex(r2 => { return string.Eq.equals(r, r2) }),\n    option.chain(idx =>\n      pipe(ranks, readonlyArray.lookup(idx))))\n\nexport interface Card {\n  suit: Suit\n  rank: Rank\n}\nexport const eqCard : eq.Eq<Card> = eq.struct({\n  suit: eqSuit,\n  rank: eqRank\n})\nexport const ordCardDescending : ord.Ord<Card> = ord.getMonoid<Card>().concat(\n  pipe(ordSuitDescending, ord.contramap(c => c.suit)),\n  pipe(ordRankDescending, ord.contramap(c => c.rank))\n)\n\nexport const cards: RNEA.ReadonlyNonEmptyArray<Card> =\n  pipe(52, RNEA.makeBy(i => ({\n    suit: suits[Math.floor(i / 13)],\n    rank: (RankC.decode((i % 13) + 2) as either.Right<Rank>).right\n  })))\n\nexport type Hand = ReadonlySet<Card>\nexport type GroupedHand = readonlyRecord.ReadonlyRecord<Suit, ReadonlyArray<Rank>>\nexport const getOrdGroupedHand = <T>() =>\n  ord.contramap(([suit, _]: readonly [Suit, T]) => suit)(ordSuitDescending)\nexport const zeroGroupedHand : GroupedHand = ({\n  S: [],\n  H: [],\n  D: [],\n  C: [],\n})\n\nexport const groupHandBySuits = (hand: Hand) : GroupedHand =>\n  pipe(hand,\n    readonlySet.toReadonlyArray(ordCardDescending),\n    RNEA.fromReadonlyArray,\n    option.fold(() => zeroGroupedHand, flow(\n      RNEA.groupBy(c => c.suit),\n      readonlyRecord.map(RNEA.map(c => c.rank)),\n      readonlyRecord.union(readonlyArray.getUnionMonoid(eqRank))(zeroGroupedHand)\n    )))\n\nexport type Deck = RNEA.ReadonlyNonEmptyArray<Card>\n\nexport const engine = { engine: MersenneTwister19937.autoSeed() }\nexport const newDeck = () : Deck =>\n  shuffle(engine.engine, [...cards]) as unknown as Deck\n","import {\n  apply,\n  eq,\n  number,\n  ord,\n  readonlyArray as RA,\n  readonlyNonEmptyArray as RNEA,\n  readonlyRecord,\n  readonlySet as RS,\n  readonlyTuple as RT,\n  refinement,\n  string,\n} from \"fp-ts\";\nimport { flow, pipe } from \"fp-ts/lib/function\";\n\nimport { ordAscending } from \"../lib\";\nimport { Deck, eqCard, Hand, suits } from \"./deck\";\n\nexport const directions = [\"N\", \"E\", \"S\", \"W\"] as const;\nexport type Direction = (typeof directions)[number];\nexport const eqDirection: eq.Eq<Direction> = string.Eq;\nexport const ordDirection = ordAscending(directions);\n\nexport const partnerships = [\"NorthSouth\", \"EastWest\"] as const;\nexport type Partnership = (typeof partnerships)[number];\nexport const eqPartnership: eq.Eq<Partnership> = string.Eq;\nexport const ordPartnership = ordAscending(partnerships);\n\nexport const getPartnershipByDirection = (d: Direction): Partnership =>\n  d === \"N\" || d === \"S\" ? \"NorthSouth\" : \"EastWest\";\n\nexport type Deal = readonlyRecord.ReadonlyRecord<Direction, Hand>;\nexport type Player = {\n  direction: Direction;\n  hand: Hand;\n};\nexport const eqHand: eq.Eq<Hand> = RS.getEq(eqCard);\n\nexport const deal = (deck: Deck): Deal =>\n  pipe(\n    directions,\n    RNEA.zip(RNEA.chunksOf(13)(deck)),\n    RNEA.groupBy(RT.fst),\n    readonlyRecord.map(flow(RNEA.head, RT.snd, RS.fromReadonlyArray(eqCard))),\n    (x: readonlyRecord.ReadonlyRecord<Direction, Hand>) => x\n  );\nexport const eqDeal: eq.Eq<Deal> = readonlyRecord.getEq<Direction, Hand>(\n  eqHand\n);\n\nexport const vulnerabilities = [\n  \"Neither\",\n  \"NorthSouth\",\n  \"EastWest\",\n  \"Both\",\n] as const;\nexport type Vulnerability = (typeof vulnerabilities)[number];\n\nexport const getIsVulnerable = (dir: Direction, vul: Vulnerability) =>\n  !(vul === \"Neither\") &&\n  (vul === \"Both\" || getPartnershipByDirection(dir) === vul);\n\nexport const strains = [...suits, \"N\"] as const;\nexport type Strain = (typeof strains)[number];\nexport const eqStrain: eq.Eq<Strain> = eq.eqStrict;\nexport const ordStrain: ord.Ord<Strain> = ordAscending(strains);\n\nexport const minors: ReadonlyArray<Strain> = [\"C\", \"D\"];\nexport const majors: ReadonlyArray<Strain> = [\"H\", \"S\"];\n\nexport interface Board {\n  dealer: Direction;\n  deal: Deal;\n}\nexport const eqBoard: eq.Eq<Board> = eq.struct({\n  dealer: eqDirection,\n  deal: eqDeal,\n});\n\nexport interface BoardWithDetail extends Board {\n  number: number;\n  vulnerability: Vulnerability;\n}\n\nconst boneChart = (boardNumber: number): Vulnerability => {\n  switch ((boardNumber % 16) + 1) {\n    case 1:\n    case 8:\n    case 11:\n    case 14:\n      return \"Neither\";\n    case 2:\n    case 5:\n    case 12:\n    case 15:\n      return \"NorthSouth\";\n    case 3:\n    case 6:\n    case 9:\n    case 16:\n      return \"EastWest\";\n    case 4:\n    case 7:\n    case 10:\n    case 13:\n      return \"Both\";\n    default:\n      throw Error(\"Not possible\");\n  }\n};\n\nexport const makeBoard =\n  (number: number) =>\n  (deal: Deal): BoardWithDetail => ({\n    number,\n    dealer: directions[(number - 1) % directions.length],\n    deal,\n    vulnerability: boneChart(number),\n  });\n\nexport const nonContractBids = [\"Pass\", \"Double\", \"Redouble\"] as const;\nexport type NonContractBid = (typeof nonContractBids)[number];\nexport const eqNonContractBid: eq.Eq<NonContractBid> = string.Eq;\nexport const isNonContractBid = (b: unknown): b is NonContractBid =>\n  typeof b === \"string\" && pipe(nonContractBids, RA.elem<string>(string.Eq)(b));\n\nexport interface ContractBid {\n  level: number;\n  strain: Strain;\n}\nexport const eqContractBid: eq.Eq<ContractBid> = eq.struct({\n  level: number.Eq,\n  strain: string.Eq,\n});\nexport const ordContractBid: ord.Ord<ContractBid> = ord\n  .getMonoid<ContractBid>()\n  .concat(\n    pipe(\n      number.Ord,\n      ord.contramap((c) => c.level)\n    ),\n    pipe(\n      ordStrain,\n      ord.contramap((c) => c.strain)\n    )\n  );\nexport const levels = RNEA.makeBy((level) => level + 1)(7);\nexport const contractBids: ReadonlyArray<ContractBid> = pipe(\n  apply.sequenceS(RA.Apply)({\n    level: levels,\n    strain: strains,\n  }),\n  RA.sort(ordContractBid)\n);\n\nexport type Bid = NonContractBid | ContractBid;\nexport const isContractBid = (b: Bid): b is ContractBid => !isNonContractBid(b);\n\nexport const eqBid: eq.Eq<Bid> = eq.fromEquals(\n  (x, y) =>\n    (isNonContractBid(x) &&\n      isNonContractBid(y) &&\n      eqNonContractBid.equals(x, y)) ||\n    (!isNonContractBid(x) && !isNonContractBid(y) && eqContractBid.equals(x, y))\n);\n\nexport const isGameLevel = (bid: Bid) =>\n  isContractBid(bid) && ord.geq(ordContractBid)(bid, { level: 3, strain: \"N\" });\nexport const isSlamLevel = (bid: Bid) =>\n  isContractBid(bid) && ord.gt(ordContractBid)(bid, { level: 5, strain: \"N\" });\n\nexport const contractModifiers = [\"Undoubled\", \"Doubled\", \"Redoubled\"] as const;\nexport type ContractModifier = (typeof contractModifiers)[number];\nexport interface Contract extends ContractBid {\n  modifier: ContractModifier;\n}\nexport const eqContract: eq.Eq<Contract> = eq.struct({\n  level: number.Eq,\n  strain: string.Eq,\n  modifier: string.Eq,\n});\nexport const fromBid = (bid: ContractBid): Contract => ({\n  ...bid,\n  modifier: \"Undoubled\",\n});\n\nexport type Auction = RNEA.ReadonlyNonEmptyArray<Bid>;\nconst consecutivePasses = [\"Pass\", \"Pass\", \"Pass\"] as const;\nexport type NonPassAuction = Auction &\n  [...Auction, ...typeof consecutivePasses];\nconst passout = [\"Pass\", \"Pass\", \"Pass\", \"Pass\"] as const;\nexport type PassAuction = typeof passout;\nexport type CompletedAuction = NonPassAuction | PassAuction;\nexport const eqAuction: eq.Eq<Auction> = RNEA.getEq(eqBid);\nexport const isCompletedAuction: refinement.Refinement<\n  Auction,\n  CompletedAuction\n> = (a): a is CompletedAuction =>\n  a.length >= 4 &&\n  (eqAuction.equals(a, passout) ||\n    eqAuction.equals(\n      a.slice(a.length - 3) as unknown as Auction,\n      consecutivePasses\n    ));\n\nexport interface BoardWithAuction extends Board {\n  auction: Auction;\n}\nexport interface BoardWithCompletedAuction extends BoardWithAuction {\n  auction: CompletedAuction;\n}\n","import { either as E, endomorphism, eq, monoid, number, option as O, optionT, ord, predicate as P, readonlyArray as RA, readonlyNonEmptyArray as RNEA, readonlyRecord as RR, readonlySet, readonlyTuple, record, semigroup, state as S, string } from 'fp-ts';\nimport { eqStrict } from 'fp-ts/lib/Eq';\nimport { apply, constant, constFalse, constTrue, flow, identity, pipe } from 'fp-ts/lib/function';\nimport { At, Lens, Optional } from 'monocle-ts';\n\nimport { assertUnreachable } from '../../lib';\nimport { Bid, ContractBid, isContractBid, ordContractBid } from '../bridge';\nimport { eqRank, eqSuit, groupHandBySuits, Hand, honors, ordRankAscending, Rank, Suit, suits } from '../deck';\nimport { AnyShape, eqShape, getHandShape, getHandSpecificShape, getHcp, SpecificShape } from '../evaluation';\n\nexport interface ConstraintPointRange {\n  type: \"PointRange\"\n  min: number\n  max: number\n}\n\nexport interface ConstraintSuitRange {\n  type: \"SuitRange\"\n  suit: Suit\n  min: number\n  max: number\n}\n\nexport type SuitComparisonOperator = \"<\" | \"<=\" | \"=\" | \">=\" | \">\"\nexport interface ConstraintSuitComparison {\n  type: \"SuitComparison\"\n  left: Suit\n  right: Suit\n  op: SuitComparisonOperator\n}\n\nexport interface ConstraintSuitHonors {\n  type: \"SuitHonors\"\n  suit: Suit\n  honors: ReadonlyArray<Rank>\n}\n\nexport interface ConstraintSuitTop {\n  type: \"SuitTop\"\n  suit: Suit\n  count: number\n  minRank: Rank\n}\n\nexport interface ConstraintSuitPrimary {\n  type: \"SuitPrimary\"\n  suit: Suit\n}\nexport interface ConstraintSuitSecondary {\n  type: \"SuitSecondary\"\n  suit: Suit\n}\ntype ConstraintSuitRank = ConstraintSuitPrimary | ConstraintSuitSecondary\n\nexport interface ConstraintSetTrump {\n  type: \"SetTrump\"\n  suit: Suit\n}\n\ninterface ConstraintConstant {\n  type: \"Constant\",\n  value: boolean\n}\nexport const constraintTrue  = constant<Constraint>({ type: \"Constant\", value: true })\nexport const constraintFalse = constant<Constraint>({ type: \"Constant\", value: false })\n\ninterface ConstraintConjunction {\n  type: \"Conjunction\"\n  constraints: RNEA.ReadonlyNonEmptyArray<Constraint>\n}\ninterface ConstraintDisjunction {\n  type: \"Disjunction\"\n  constraints: RNEA.ReadonlyNonEmptyArray<Constraint>\n}\ninterface ConstraintNegation {\n  type: \"Negation\"\n  constraint: Constraint\n}\n\nexport interface ConstraintAnyShape {\n  type: \"AnyShape\"\n  counts: AnyShape\n}\n\nexport interface ConstraintSpecificShape {\n  type: \"SpecificShape\"\n  suits: SpecificShape\n}\n\n// interface ConstraintResponse {\n//   type: \"ForceOneRound\" | \"ForceGame\" | \"ForceSlam\"\n// }\n\n// interface ConstraintRelayResponse {\n//   type: \"Relay\"\n//   bid: ContractBid\n// }\n\n// export type ConstraintForce =\n//     ConstraintResponse\n//   | ConstraintRelayResponse\n\nexport type Constraint =\n  | ConstraintConstant\n  | ConstraintConjunction\n  | ConstraintDisjunction\n  | ConstraintNegation\n  | ConstraintPointRange\n  | ConstraintSuitRange\n  | ConstraintSuitComparison\n  | ConstraintSuitRank\n  | ConstraintSetTrump\n  | ConstraintSuitHonors\n  | ConstraintSuitTop\n  | ConstraintAnyShape\n  | ConstraintSpecificShape\n  // | ConstraintForce\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\nconst predFalse : P.Predicate<Hand> = constFalse\nconst predTrue : P.Predicate<Hand> = constTrue\nconst quantifier = <A>(ps: ReadonlyArray<P.Predicate<A>>) => (m: monoid.Monoid<P.Predicate<A>>) => \n  RA.foldMap(m)((x: P.Predicate<A>) => x)(ps)\nexport const exists = <A>(ps: ReadonlyArray<P.Predicate<A>>) => pipe(ps, quantifier, apply(P.getMonoidAny<A>()))\nexport const forall = <A>(ps: ReadonlyArray<P.Predicate<A>>) => pipe(ps, quantifier, apply(P.getMonoidAll<A>()))\n// const forall = <A>() => pipe(P.getMonoidAll<A>(), RA.foldMap, apply(identity))\n/* eslint-enable @typescript-eslint/no-unused-vars */\n\ninterface Range {\n  min: number\n  max: number\n}\n\nconst rangeCheck = (range: Range) =>\n  ord.between(number.Ord)(range.min, range.max)\n\nconst isPointRange =\n  flow(rangeCheck, P.contramap(getHcp))\n\nconst isSpecificShape = (shape: SpecificShape) =>\n  flow(getHandSpecificShape, suits => record.getEq(eqStrict).equals(suits, shape))\n\nconst isSuitRange = (range: Range) => (suit: Suit) =>\n  flow(getHandSpecificShape, shape =>\n    pipe(range, rangeCheck, apply(shape[suit])))\n\nconst getComparator = (op: SuitComparisonOperator) => {\n  switch (op) {\n    case \"<\" : return ord.lt(number.Ord)\n    case \"<=\": return ord.leq(number.Ord)\n    case \"=\" : return number.Eq.equals\n    case \">=\": return ord.geq(number.Ord)\n    case \">\" : return ord.gt(number.Ord)\n    default  : return assertUnreachable(op)\n  }\n}\n\nconst suitCompare = (op: SuitComparisonOperator) => (left: Suit, right: Suit) =>\n  flow(getHandSpecificShape,\n    shape => getComparator(op)(shape[left], shape[right]))\n\nconst suitPrimary = (suit: Suit) =>\n  pipe(suits,\n    RA.splitAt(suits.indexOf(suit)),\n    readonlyTuple.bimap(\n      flow(RA.tail,\n        O.fold(() => [],\n          RA.map(higher => suitCompare(\"<\")(higher, suit)))),\n      RA.map(lower => suitCompare(\"<=\")(lower, suit))),\n    RA.flatten,\n    RA.prepend(isSuitRange({ min: 5, max: 13 })(suit)),\n    forall)\n\nconst suitSecondary = (secondarySuit: Suit) => (primarySuit: Suit) =>\n  pipe(RA.Do,\n    RA.apS('suit', [secondarySuit, primarySuit]),\n    RA.apS('otherSuit', pipe(suits, RA.difference(eqSuit)([secondarySuit, primarySuit]))),\n    RA.filter(({ suit, otherSuit }) => !eqSuit.equals(suit, otherSuit)),\n    RA.map(({ suit, otherSuit }) => suitCompare(\">\")(suit, otherSuit)),\n    RA.concat([\n      isSuitRange({ min: 4, max: 13 })(secondarySuit),\n      suitCompare(\">=\")(primarySuit, secondarySuit)\n    ]),\n    forall)\n\nconst toRankSet = readonlySet.fromReadonlyArray(eqRank)\n\nconst suitHonors = (suitHonors: ConstraintSuitHonors) =>\n  flow(\n    groupHandBySuits,\n    RR.lookup(suitHonors.suit),\n    O.fold(constFalse, cards => {\n      const cardSet = pipe(cards,\n        toRankSet,\n        readonlySet.intersection(eqRank)(toRankSet(honors)))\n      const honorSet = pipe(suitHonors.honors, toRankSet)\n      return pipe(honorSet, readonlySet.isSubset(eqRank)(cardSet))\n    }))\n\nconst suitTop = (suitTop: ConstraintSuitTop) =>\n  flow(groupHandBySuits,\n    RR.lookup(suitTop.suit),\n    O.fold(constFalse, flow(\n      RA.filter(r => ordRankAscending.compare(r, suitTop.minRank) >= 0),\n      cards => cards.length >= suitTop.count)))\n\nconst isShape = (shape: AnyShape) =>\n  flow(getHandShape, handShape =>\n    eqShape.equals(shape, handShape))\n\nconst contextualConstraintTypes = [\n  \"Conjunction\",\n  \"Disjunction\",\n  \"Negation\",\n  // \"ForceOneRound\",\n  // \"ForceGame\",\n  // \"ForceSlam\",\n  // \"Relay\",\n  \"SuitPrimary\",\n  \"SuitSecondary\",\n  \"SetTrump\"\n] as const\n\ntype ContextualConstraintType = typeof contextualConstraintTypes[number]\ntype BasicConstraint = Exclude<Constraint, { type: ContextualConstraintType }>\ntype ContextualConstraint = Extract<Constraint, { type: ContextualConstraintType }>\n\nconst isContextualConstraint = (c: Constraint) : c is ContextualConstraint =>\n  RA.elem(string.Eq as eq.Eq<Constraint[\"type\"]>)(c.type)(contextualConstraintTypes)\n\nconst separate = (c: Constraint) : E.Either<ContextualConstraint, BasicConstraint> =>\n  isContextualConstraint(c) ? E.left(c) : E.right(c as BasicConstraint)\n    \nconst satisfiesBasic = (c: BasicConstraint): P.Predicate<Hand> => {\n  switch (c.type) {\n    case \"Constant\":\n      return constant(c.value)\n    case \"PointRange\":\n      return isPointRange(c)\n    case \"SuitRange\":\n      return isSuitRange(c)(c.suit)\n    case \"SuitComparison\":\n      return suitCompare(c.op)(c.left, c.right)\n    case \"SuitHonors\":\n      return suitHonors(c)\n    case \"SuitTop\":\n      return suitTop(c)\n    case \"AnyShape\":\n      return isShape(c.counts)\n    case \"SpecificShape\":\n      return isSpecificShape(c.suits)\n    default:\n      return assertUnreachable(c)\n  }\n}\n\nexport interface ConstrainedBid {\n  bid: Bid\n  constraint: Constraint\n}\nconst ordBid: ord.Ord<Bid> =\n  ord.fromCompare((a, b) =>\n    isContractBid(a) && !isContractBid(b) ? -1 :\n    isContractBid(b) && !isContractBid(a) ? 1 :\n    isContractBid(a) && isContractBid(b) ? ordContractBid.compare(a, b) :\n    0)\nexport const ordConstrainedBid = ord.contramap<Bid, ConstrainedBid>(b => b.bid)(ordBid)\n\nexport const relativePlayers = [\"Me\", \"LHO\", \"Partner\", \"RHO\"] as const\nexport type RelativePlayer = typeof relativePlayers[number]\n\nexport const relativePartnerships = [\"We\"] as const\nexport type RelativePartnership = typeof relativePartnerships[number]\nexport interface PlayerContext {\n  primarySuit: O.Option<Suit>\n  secondarySuit: O.Option<Suit>\n}\nexport const zeroPlayerContext: PlayerContext = {\n  primarySuit: O.none,\n  secondarySuit: O.none\n}\nexport const playerContextL = Lens.fromProp<PlayerContext>()\nexport const primarySuitL = playerContextL('primarySuit')\nexport const secondarySuitL = playerContextL('secondarySuit')\n\nexport interface PartnershipContext {\n  trumpSuit: O.Option<Suit>\n}\nexport const zeroPartnershipContext: PartnershipContext = {\n  trumpSuit: O.none,\n}\nexport const partnershipContextL = Lens.fromProp<PartnershipContext>()\nexport const trumpSuitL = partnershipContextL('trumpSuit')\n\nexport const rotateRecord = <K extends string>(keys: ReadonlyArray<K>) => <V>(r: RR.ReadonlyRecord<K, V>) : RR.ReadonlyRecord<K, V> =>\n  pipe(\n    RA.zip(pipe(keys, RA.rotate(1)), keys),\n    RA.map(readonlyTuple.mapSnd(p => r[p])),\n    RR.fromFoldable(semigroup.first<V>(), RA.Foldable))\n\n\nexport const rotateContexts = <PL, PT, X extends { players: RR.ReadonlyRecord<RelativePlayer, PL>, partnerships: RR.ReadonlyRecord<RelativePartnership, PT> }>(context: X): X => {\n  const pl = Lens.fromProp<X>()('players')\n  const pt = Lens.fromProp<X>()('partnerships')\n  return pipe(\n    [ pl.modify(flow(rotateRecord(relativePlayers), rotateRecord(relativePlayers))),\n      pt.modify(rotateRecord(relativePartnerships))\n    ],\n    RNEA.foldMap(endomorphism.getSemigroup<X>())(identity),\n    apply(context))\n  }\n\nexport interface BidContext {\n  bid: Bid,\n  path: ReadonlyArray<Bid>\n  // force: O.Option<ConstraintForce>\n  players: RR.ReadonlyRecord<RelativePlayer, PlayerContext>\n  partnerships: RR.ReadonlyRecord<RelativePartnership, PartnershipContext>\n}\nexport const zeroContext : BidContext = {\n  bid: {} as Bid,\n  path: [],\n  // force: O.none,\n  players: pipe(relativePlayers, RA.map(p => [p, zeroPlayerContext] as const), RR.fromFoldable(semigroup.first<PlayerContext>(), RA.Foldable)),\n  partnerships: pipe(relativePartnerships, RA.map(p => [p, zeroPartnershipContext] as const), RR.fromFoldable(semigroup.first<PartnershipContext>(), RA.Foldable)),\n}\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\nexport const contextL = Lens.fromProp<BidContext>()\nexport const bidL = contextL('bid')\nexport const pathL = contextL('path')\n// export const forceL = contextL('force')\nexport const playersL = contextL('players')\nexport const partnershipsL = contextL('partnerships')\nexport const contextO = Optional.fromOptionProp<BidContext>()\n// export const forceO = contextO('force')\nexport const playerContextA = new At<BidContext, RelativePlayer, PlayerContext>(player =>\n  new Lens(\n    flow(playersL.get, p => p[player]),\n    p => context => pipe(context, playersL.get, RR.upsertAt(player, p), playersL.set, apply(context))))\nexport const partnershipContextA = new At<BidContext, RelativePartnership, PartnershipContext>(partnership =>\n  new Lens(\n    flow(partnershipsL.get, p => p[partnership]),\n    p => context => pipe(context, partnershipsL.get, RR.upsertAt(partnership, p), partnershipsL.set, apply(context))))\n\nexport type ConstraintS<X, C> = S.State<X, C>\nexport type SatisfiesS<X, C, A> = (c: ConstraintS<X, C>) => S.State<X, P.Predicate<A>>\nconst quantifierS = <A>(quantifier: (c: ReadonlyArray<P.Predicate<A>>) => P.Predicate<A>) => <X, C>(satisfies: SatisfiesS<X, C, A>) =>\n  flow(\n    S.traverseArray(satisfies),\n    S.map(quantifier))\nconst existsS = <X, C, A>(satisfies: SatisfiesS<X, C, A>) => quantifierS<A>(exists)(satisfies)\nconst forallS = <X, C, A>(satisfies: SatisfiesS<X, C, A>) => quantifierS<A>(forall)(satisfies)\n\nexport const ofS = <A>(x: A) => S.of<BidContext, A>(x)\n\nconst satisfiesContextual = (recur: SatisfiesS<BidContext, Constraint, Hand>) : SatisfiesS<BidContext, ContextualConstraint, Hand> =>\n  S.chain(c => {\n    switch (c.type) {\n      case \"Conjunction\":\n        return pipe(c.constraints, RNEA.map(ofS), forallS(recur))\n      case \"Disjunction\":\n        return pipe(c.constraints, RNEA.map(ofS), existsS(recur))\n      case \"Negation\": \n        return pipe(c.constraint, ofS, recur, S.map(P.not))\n        \n      // case \"ForceOneRound\":\n      // case \"ForceGame\":\n      // case \"ForceSlam\":\n      // case \"Relay\":\n      //   return pipe(\n      //     S.modify<BidContext>(forceL.set(O.some(c))),\n      //     S.map(() => constTrue))\n\n      case \"SuitPrimary\":\n        return pipe(\n          S.modify<BidContext>(playerContextA.at(\"Me\").composeLens(primarySuitL).set(O.some(c.suit))),\n          S.map(() => suitPrimary(c.suit)))\n      case \"SuitSecondary\":\n        return pipe(\n          S.modify<BidContext>(playerContextA.at(\"Me\").composeLens(secondarySuitL).set(O.some(c.suit))),\n          S.apSecond(S.gets(playerContextA.at(\"Me\").composeLens(primarySuitL).get)),\n          optionT.map(S.Functor)(suitSecondary(c.suit)),\n          S.map(O.getOrElse(() => predFalse)))\n        \n      case \"SetTrump\":\n        return pipe(\n          S.modify<BidContext>(partnershipContextA.at(\"We\").composeLens(trumpSuitL).set(O.some(c.suit))),\n          S.map(() => constTrue))\n\n      default:\n        return assertUnreachable(c)\n    }\n  })\n\nexport const satisfiesS : SatisfiesS<BidContext, Constraint, Hand> = s =>\n  pipe(s,\n    S.map(separate),\n    S.chain(E.fold(\n      flow(S.of, satisfiesContextual(satisfiesS)),\n      flow(S.flap, f => f(ofS(satisfiesBasic))))))\n\nconst satisfiesWithContext = (x: Constraint) =>\n  pipe(x, S.of, satisfiesS)\n  \nexport const satisfies =\n  flow(satisfiesWithContext, S.evaluate(zeroContext))","import { boolean, option as O, readonlyArray as RA, readonlyNonEmptyArray as RNEA, state as S } from 'fp-ts';\nimport { identity, pipe } from 'fp-ts/lib/function';\n\nimport * as Gen from '../../lib/gen';\nimport { eqBid } from '../bridge';\nimport { Hand } from '../deck';\nimport { BidContext, bidL, ConstrainedBid, Constraint, constraintTrue, ofS, pathL, rotateContexts, satisfiesS, zeroContext } from './core';\n\n// const specialRelayCase = (s: S.State<BidContext, Constraint>) =>\n//   pipe(s,\n//     S.bindTo('constraint'),\n//     S.apS('force', S.gets(forceO.getOption)),\n//     S.apS('bid', S.gets(bidL.get)),\n//     S.map(info =>\n//       pipe(info.force,\n//         O.chain(O.fromPredicate(force =>\n//           info.constraint.type === \"Constant\" && !info.constraint.value && force.type === \"Relay\" && eqBid.equals(force.bid, info.bid))),\n//         O.fold(() => info.constraint, constraintTrue))))\n\nexport const satisfiesPath = (opener: Hand, responder: Hand) => (path: RNEA.ReadonlyNonEmptyArray<ConstrainedBid>) =>\n  pipe(\n    Gen.alternate(opener, responder),\n    Gen.unfold(path.length),\n    RA.zip(path),\n    S.traverseArray(([hand, info]) =>\n      pipe(\n        ofS(info.constraint),\n        S.chainFirst(() => S.modify(bidL.set(info.bid))),\n        // specialRelayCase,\n        satisfiesS,\n        S.flap(hand),\n        S.apFirst(S.modify(rotateContexts)),\n        S.apFirst(S.modify(pathL.modify(RA.prepend(info.bid)))))),\n    S.map(RA.foldMap(boolean.MonoidAll)(identity)),\n    S.evaluate(zeroContext))","import ts from 'ts-toolbelt';\n\ntype Key = ts.Any.Key\n\nexport const hasProperty = <X extends {}, Y extends PropertyKey>(obj: X, prop: Y): obj is X & Record<Y, unknown> =>\n  obj.hasOwnProperty(prop)\n\nexport const get =\n  <P extends Key>(key: P) =>\n  <T extends Record<P, T[P]>>(obj: T) =>\n    obj[key]\nexport const getN =\n  <P extends Key>(key: P) =>\n  <T extends Partial<Record<P, T[P]>>>(obj: T) =>\n    obj[key]\n\nexport const set =\n  <P extends Key>(key: P) =>\n  <T extends Record<P, T[P]>>(value: T[P]) =>\n  (obj: T) => {\n    obj[key] = value\n  }\nexport const update =\n  <P extends Key>(key: P) =>\n  <T extends Record<P, T[P]>>(value: T[P]) =>\n  (obj: T) => { \n    set(key)(value)(obj)\n    return value\n  }","import {\n  either,\n  magma,\n  number,\n  option as O,\n  readonlyRecord as RR,\n  semigroup,\n} from \"fp-ts\";\nimport { Right } from \"fp-ts/lib/Either\";\nimport { Lazy, pipe } from \"fp-ts/lib/function\";\nimport * as t from \"io-ts\";\nimport objectHash from \"object-hash\";\nimport { UuidTool } from \"uuid-tool\";\n\nimport { assertUnreachable } from \"../lib\";\nimport { get } from \"../lib/object\";\nimport { SatisfiesResult } from \"../workers\";\nimport { DoubleDummyResult } from \"../workers/dds.worker\";\nimport { SerializedBidPath, SerializedDeal } from \"./serialization\";\nimport { Stats } from \"./stats\";\nimport { Path, Paths } from \"./system\";\nimport { ConstrainedBid } from \"./system/core\";\n\nexport const DateNumberB = t.brand(\n  t.number,\n  (d): d is t.Branded<number, { readonly Date: unique symbol }> => true,\n  \"Date\"\n);\nexport type DateNumber = t.TypeOf<typeof DateNumberB>;\nexport const now: Lazy<DateNumber> = () =>\n  pipe(\n    new Date().getTime(),\n    DateNumberB.decode,\n    (x) => (x as either.Right<DateNumber>).right\n  );\n\nconst timeSpanC = t.tuple([DateNumberB, DateNumberB]);\nexport type TimeSpan = t.TypeOf<typeof timeSpanC>;\n\nexport interface ProgressData {\n  unitsDone: number;\n  updateDate: O.Option<DateNumber>;\n  speed: O.Option<number>;\n}\ninterface ProgressDataWithValue<T> extends ProgressData {\n  value: T;\n}\ntype Progress<T> = O.Option<ProgressDataWithValue<T>>;\n\nexport const getGenericProgress = (job: Job) =>\n  job.details.progress as O.Option<ProgressData>;\n\nexport const initProgress = <T>(value: T): Progress<T> =>\n  O.some({\n    unitsDone: 0,\n    updateDate: O.none,\n    speed: O.none,\n    value,\n  });\n\nconst SMOOTHING_FACTOR = 0.1;\nexport const updateProgress =\n  <T>(M: magma.Magma<T>) =>\n  (unitsDone: number) =>\n  (value: T) =>\n  (progress: Progress<T>): Progress<T> =>\n    pipe(\n      progress,\n      O.map((p) => {\n        const updateDate = now();\n        const speed = pipe(\n          p.updateDate,\n          O.map((lastUpdate) => (updateDate - lastUpdate) / unitsDone),\n          O.filter((x) => !isNaN(x) && isFinite(x))\n        );\n        return {\n          unitsDone: p.unitsDone + unitsDone,\n          updateDate: O.some(updateDate),\n          value: M.concat(p.value, value),\n          speed: pipe(\n            O.Do,\n            O.apS(\"avg\", p.speed),\n            O.apS(\"next\", speed),\n            O.map(\n              (o) => (1 - SMOOTHING_FACTOR) * o.avg + SMOOTHING_FACTOR * o.next\n            ),\n            O.filter((x) => !isNaN(x) && isFinite(x)),\n            O.alt(() => speed),\n            O.alt(() => p.speed)\n          ),\n        };\n      })\n    );\n\nexport const GenerationIdB = t.brand(\n  t.string,\n  (id): id is t.Branded<string, { readonly GenerationId: unique symbol }> =>\n    UuidTool.isUuid(id),\n  \"GenerationId\"\n);\nexport type GenerationId = t.TypeOf<typeof GenerationIdB>;\nexport const newGenerationId = () =>\n  (GenerationIdB.decode(UuidTool.newUuid()) as Right<GenerationId>).right;\n\nexport type Satisfies = RR.ReadonlyRecord<SerializedBidPath, number>;\nexport interface Generation {\n  id: GenerationId;\n  dealCount: number;\n  satisfies: O.Option<Satisfies>;\n  solutionStats: RR.ReadonlyRecord<SerializedBidPath, Stats>;\n}\nexport const zeroGeneration = (\n  id: GenerationId,\n  dealCount: number\n): Generation => ({\n  id,\n  dealCount,\n  satisfies: O.none,\n  solutionStats: {},\n});\n\nexport const AnalysisIdB = t.brand(\n  t.string,\n  (id): id is t.Branded<string, { readonly AnalysisId: unique symbol }> =>\n    UuidTool.isUuid(id),\n  \"AnalysisId\"\n);\nexport type AnalysisId = t.TypeOf<typeof AnalysisIdB>;\nexport const newAnalysisId = () =>\n  (AnalysisIdB.decode(UuidTool.newUuid()) as Right<AnalysisId>).right;\nexport interface Analysis {\n  id: AnalysisId;\n  name: string;\n  paths: Paths<ConstrainedBid>;\n  generations: ReadonlyArray<Generation>;\n}\n\nexport const zeroAnalysis = (\n  id: AnalysisId,\n  name: string,\n  paths: Paths<ConstrainedBid>\n): Analysis => ({\n  id,\n  name,\n  paths,\n  generations: [],\n});\n\nexport interface JobTypeGenerateDeals {\n  parameter: number\n  context: { generationId: GenerationId }\n  progress: Progress<number>\n}\nexport interface JobTypeSatisfies {\n  parameter: Paths<ConstrainedBid>\n  context: { generationId: GenerationId }\n  progress: Progress<Satisfies>\n}\nexport interface JobTypeSolve {\n  parameter: ReadonlyArray<SerializedDeal>\n  context: { generationId: GenerationId; bidPath: SerializedBidPath }\n  progress: Progress<Solution>\n}\nexport type JobDetailsMap = {\n  \"GenerateDeals\": JobTypeGenerateDeals\n  \"Satisfies\": JobTypeSatisfies\n  \"Solve\": JobTypeSolve\n}\nexport type Job<K extends keyof JobDetailsMap = keyof JobDetailsMap> = { [P in K]: {\n  id: JobId\n  analysisId: AnalysisId\n  dependsOn: ReadonlyArray<JobId>\n  unitsInitial: number\n  startDate: O.Option<DateNumber>\n  completedDate: O.Option<DateNumber>\n  running: boolean\n  error: O.Option<string>\n  type: P\n  details: JobDetailsMap[P]\n}}[K];\n\nconst zeroGenerateDealsProgress = () => initProgress(0);\nexport const updateGenerateDealsProgress = (deals: ReadonlyArray<any>) =>\n  updateProgress(number.MonoidSum)(deals.length)(deals.length);\n\nconst ConstrainedBidPathHashC = t.brand(\n  t.string,\n  (hash): hash is t.Branded<string, { readonly PathHash: unique symbol }> =>\n    true,\n  \"PathHash\"\n);\nexport type ConstrainedBidPathHash = t.TypeOf<typeof ConstrainedBidPathHashC>;\nexport const getBidPathHash = (cb: Path<ConstrainedBid>) =>\n  (\n    ConstrainedBidPathHashC.decode(\n      objectHash(cb)\n    ) as Right<ConstrainedBidPathHash>\n  ).right;\n\nconst zeroSatisfiesProgress = () => initProgress<Satisfies>({});\nexport const updateSatisfiesProgress = (result: SatisfiesResult) =>\n  updateProgress(RR.getUnionSemigroup(number.MonoidSum))(result.testedCount)({\n    [result.path]: result.satisfiesCount,\n  });\n\nexport type Solution = RR.ReadonlyRecord<\n  SerializedDeal[\"id\"],\n  DoubleDummyResult\n>\n\nconst zeroSolveProgress = () => initProgress<Solution>({});\nexport const updateSolveProgress = (solutions: Solution) =>\n  updateProgress(RR.getUnionSemigroup(semigroup.first<DoubleDummyResult>()))(\n    pipe(solutions, RR.keys, (keys) => keys.length)\n  )(solutions);\n\nexport const initJobProgress = <K extends keyof JobDetailsMap>(type: K): Job<K>[\"details\"][\"progress\"] => {\n  switch (type) {\n    case \"GenerateDeals\":\n      return zeroGenerateDealsProgress();\n    case \"Satisfies\":\n      return zeroSatisfiesProgress();\n    case \"Solve\":\n      return zeroSolveProgress();\n    default:\n      return assertUnreachable(type);\n  }\n};\n\nexport const JobIdB = t.brand(\n  t.string,\n  (id): id is t.Branded<string, { readonly JobId: unique symbol }> =>\n    UuidTool.isUuid(id),\n  \"JobId\"\n);\nexport type JobId = t.TypeOf<typeof JobIdB>;\nconst newJobId = () =>\n  (JobIdB.decode(UuidTool.newUuid()) as Right<JobId>).right;\n\nexport const zeroJob = <K extends keyof JobDetailsMap>(\n  analysisId: AnalysisId,\n  estimatedUnitsInitial: number,\n  type: K,\n  details: JobDetailsMap[K]\n): Job<K> => ({\n  id: newJobId(),\n  analysisId,\n  dependsOn: [],\n  unitsInitial: estimatedUnitsInitial,\n  startDate: O.none,\n  completedDate: O.none,\n  running: false,\n  error: O.none,\n  type,\n  details,\n});\n\nexport const unitsRemaining = (job: Job) =>\n  pipe(\n    job,\n    getGenericProgress,\n    O.fold(() => 0, get(\"unitsDone\")),\n    (done) => job.unitsInitial - done\n  );\n\nexport const percentageRemaining = (job: Job) =>\n  pipe(\n    job,\n    getGenericProgress,\n    O.fold(() => 0, get(\"unitsDone\")),\n    (done) => Math.floor((done * 100) / job.unitsInitial)\n  );\n\nexport const elapsedTime = (job: Job) =>\n  pipe(\n    O.Do,\n    O.apS(\"progress\", pipe(job, getGenericProgress)),\n    O.apS(\"start\", job.startDate),\n    O.bind(\"update\", ({ progress }) => progress.updateDate),\n    O.map((o): TimeSpan => [o.update, o.start])\n  );\n\nexport const estimatedTimeRemaining =\n  (unitsInitial: number) => (progress: ProgressData) =>\n    pipe(\n      progress.speed,\n      O.map((speed) => speed * (unitsInitial - progress.unitsDone))\n    );\n","import { readonlyArray } from 'fp-ts';\nimport { apply, pipe } from 'fp-ts/lib/function';\nimport { from, Observable, ObservableInput, Subject, zip } from 'rxjs';\nimport { finalize, mergeMap, tap } from 'rxjs/operators';\n\n// adapted from https://github.com/cloudnc/observable-webworker/blob/master/projects/observable-webworker/src/lib/from-worker-pool.ts\n\ninterface LazyWorker<W extends Worker> {\n  factory: () => W\n  terminate: () => void\n  processing: boolean\n  index: number\n}\n\nconst pool = <W extends Worker, I, O>(ctor: (index: number) => W, doWork: (worker: W) => (input: I) => Promise<O>) => (input$: ObservableInput<I>) => {\n  const maxParallel = navigator.hardwareConcurrency ? navigator.hardwareConcurrency - 1 : 1\n\n  return new Observable<O>(resultObserver => {\n    const idleWorker$$ = new Subject<LazyWorker<W>>()\n\n    let completed = 0\n    let sent = 0\n    let finished = false\n\n    const workers = readonlyArray.makeBy(maxParallel, (index): LazyWorker<W> => {\n      let cachedWorker: W | null = null\n      return {\n        factory: () => cachedWorker ?? (cachedWorker = ctor(index)),\n        terminate() {\n          if (!this.processing && cachedWorker) {\n            // try {\n            //   cachedWorker.terminate()\n            // } catch { }\n          }\n        },\n        processing: false,\n        index,\n      }\n    })\n\n    const processor$ = zip(idleWorker$$, input$).pipe(\n      tap(([worker]) => {\n        sent++\n        worker.processing = true\n      }),\n      finalize(() => {\n        idleWorker$$.complete()\n        finished = true\n        workers.forEach(worker => worker.terminate())\n      }),\n      mergeMap(([worker, item]) =>\n        pipe(worker.factory(),\n          doWork,\n          apply(item),\n          from,\n          finalize(() => {\n            completed++\n            worker.processing = false\n            if (!finished) {\n              idleWorker$$.next(worker)\n            } else {\n              worker.terminate()\n            }\n            if (finished && completed === sent) {\n              resultObserver.complete()\n            }\n          }),\n        )))\n\n    const sub = processor$.subscribe(resultObserver)\n    workers.forEach(w => idleWorker$$.next(w))\n    return () => sub.unsubscribe()\n  })\n}\n\nexport default pool","import { either, option as O, readonlyArray as RA, readonlyRecord as RR, semigroup, string, task, taskEither as TE } from 'fp-ts';\nimport { flow, pipe } from 'fp-ts/lib/function';\nimport { DBSchema, deleteDB, IDBPDatabase, IndexKey, IndexNames, openDB, StoreNames } from 'idb';\nimport { UuidTool } from 'uuid-tool';\n\nimport { ConstrainedBidPathHash, GenerationId } from '../model/job';\nimport { SerializedDeal } from '../model/serialization';\nimport { DoubleDummyResult, DoubleDummyTable } from '../workers/dds.worker';\n\ninterface DealDB extends DBSchema {\n  deal: {\n    key: SerializedDeal[\"id\"]\n    value: {\n      deal: SerializedDeal\n      batchId: string\n      generationId: GenerationId\n      solution?: DoubleDummyTable\n    },\n    indexes: {\n      'batch': string,\n      'generation': string\n    }\n  },\n  satisfies: {\n    key: [GenerationId, ConstrainedBidPathHash]\n    value: {\n      generationId: GenerationId\n      deals: ReadonlyArray<SerializedDeal>\n    },\n    indexes: {\n      'generation': string\n    }\n  }\n}\n\ntype DbError =\n  | \"OpenDatabaseFailed\"\n  | \"CommitRejected\"\n  | \"InsertError\"\n  | \"SelectError\"\n  | \"DeleteError\"\n  | \"RecordNotFound\"\n\nexport const deleteDb = \n  TE.tryCatch(() => deleteDB('bridge'), (): DbError => \"DeleteError\")\n\nconst getDb =\n  TE.tryCatch(() =>\n    openDB<DealDB>('bridge', 1, {\n      upgrade: (db) => {\n        const deal = db.createObjectStore(\"deal\")\n        deal.createIndex('batch', 'batchId')\n        deal.createIndex('generation', 'generationId')\n        const satisfies = db.createObjectStore(\"satisfies\")\n        satisfies.createIndex('generation', 'generationId')\n      }\n    }),\n    (): DbError => \"OpenDatabaseFailed\")\n\nexport const insertDeals = (generationId: GenerationId) => (deals: ReadonlyArray<SerializedDeal>) =>\n  pipe(getDb,\n    TE.map(db => db.transaction('deal', 'readwrite')),\n    TE.chainFirst(tran => {\n      const batchId = UuidTool.newUuid()\n      return pipe(deals, TE.traverseArray(deal =>\n        TE.tryCatch(\n          () => tran.store.put({\n            deal,\n            generationId,\n            batchId\n          }, deal.id),\n          (): DbError => \"InsertError\")))\n    }),\n    TE.chain(tran => TE.tryCatch(() => tran.done, (): DbError => \"CommitRejected\")))\n\nexport const insertSolutions = (solutions: ReadonlyArray<DoubleDummyResult>) =>\n  pipe(getDb,\n    TE.map(db => db.transaction('deal', 'readwrite')),\n    TE.bindTo('tran'),\n    TE.chainFirst(({ tran }) => pipe(solutions,\n      TE.traverseArray(s => pipe(s,\n        TE.tryCatchK(s => tran.store.get(s.board.deal.id), (): DbError => \"SelectError\"),\n        TE.chain(flow(either.fromNullable(\"RecordNotFound\" as DbError), task.of)),\n        TE.map(row => { row.solution = s.results; return row }),\n        TE.chain(TE.tryCatchK(row => tran.store.put(row, row.deal.id), (): DbError => \"InsertError\")))))),\n    TE.chain(({ tran }) => TE.tryCatch(() => tran.done, (): DbError => \"CommitRejected\")))\n\nexport const insertSatisfies = (generationId: GenerationId, hash: ConstrainedBidPathHash) => (deals: ReadonlyArray<SerializedDeal>) =>\n  pipe(getDb,\n    TE.map(db => db.transaction('satisfies', 'readwrite')),\n    TE.bindTo('tran'),\n    TE.bind('existingDeals', ({ tran }) => pipe(\n      TE.tryCatch(() => tran.store.get([generationId, hash]), (): DbError => \"SelectError\"),\n      TE.map(flow(O.fromNullable, O.fold(() => [], r => r.deals))))),\n    TE.chainFirst(({ tran, existingDeals }) =>\n      TE.tryCatch(() => tran.store.put({\n        generationId,\n        deals: pipe(existingDeals, RA.concat(deals))\n      }, [generationId, hash]), (): DbError => \"InsertError\")),\n    TE.chain(({ tran }) => TE.tryCatch(() => tran.done, (): DbError => \"CommitRejected\")))\n\nconst getByIndex = <I extends IndexNames<DealDB, 'deal'>>(idx: I) => (id: string) =>\n  TE.tryCatchK((db: IDBPDatabase<DealDB>) => db.getAllFromIndex('deal', idx, id as any), (): DbError => \"SelectError\")\n\nexport const getDealsByGenerationId = (generationId: GenerationId) =>\n  pipe(getDb,\n    TE.chain(getByIndex('generation')(generationId)),\n    TE.map(RA.map(row => row.deal)))\n\nexport const getBatchIdsByGenerationId = (generationId: GenerationId) =>\n  pipe(getDb,\n    TE.chain(getByIndex('generation')(generationId)),\n    TE.map(flow(\n      RA.map(row => row.batchId),\n      RA.uniq(string.Eq))))\n\nexport const getDealsByBatchId = (batchId: string) =>\n  pipe(getDb,\n    TE.chain(getByIndex('batch')(batchId)),\n    TE.map(RA.map(row => row.deal)))\n\ninterface DealWithSolution {\n  deal: SerializedDeal\n  solution: O.Option<DoubleDummyTable>\n}\nexport const getDealsWithSolutionsByPath = (generationId: GenerationId, hash: ConstrainedBidPathHash) =>\n  pipe(getDb,\n    TE.chain(db => TE.of(db.transaction(['deal', 'satisfies'], 'readonly'))),\n    TE.bindTo('tran'),\n    TE.bind('satisfiedDeals', ({ tran }) => pipe(\n      TE.tryCatch(() => tran.objectStore('satisfies').get([generationId, hash]), (): DbError => \"SelectError\"),\n      TE.map(flow(\n        O.fromNullable,\n        O.fold(() => [], x => x.deals))))),\n    TE.bind('deals', ({ tran, satisfiedDeals }) => pipe(satisfiedDeals,\n      TE.traverseArray(TE.tryCatchK(key => tran.objectStore('deal').get(key.id), (): DbError => \"SelectError\")),\n      TE.map(flow(\n        RA.map(O.fromNullable),\n        RA.compact,\n        RA.foldMap(RR.getUnionMonoid(semigroup.first<DealWithSolution>()))(row => ({\n          [row.deal.id]: {\n            deal: row.deal,\n            solution: O.fromNullable(row.solution)\n          }\n        })))))),\n    TE.chainFirst(({ tran }) => TE.tryCatch(() => tran.done, (): DbError => \"CommitRejected\")),\n    TE.map(({ deals }): RR.ReadonlyRecord<SerializedDeal[\"id\"], DealWithSolution> => deals))\n\nexport const deleteByGenerationId = (generationId: GenerationId) =>\n  pipe(getDb,\n    TE.chain(db => TE.of(db.transaction(['deal', 'satisfies'], 'readwrite'))),\n    TE.chainFirst(tran => pipe(\n      TE.tryCatch(() => tran.objectStore('deal').index('generation').getAllKeys(generationId), (): DbError => \"SelectError\"),\n      TE.chain(TE.traverseArray(TE.tryCatchK(key => tran.objectStore('deal').delete(key), (): DbError => \"DeleteError\"))))),\n    TE.chainFirst(tran => pipe(\n      TE.tryCatch(() => tran.objectStore('satisfies').index('generation').getAllKeys(generationId), (): DbError => \"SelectError\"),\n      TE.chain(TE.traverseArray(TE.tryCatchK(key => { return tran.objectStore('satisfies').delete(key) }, (): DbError => \"DeleteError\"))))),\n    TE.chain(tran => TE.tryCatch(() => tran.done, (): DbError => \"CommitRejected\")))","/* eslint-disable import/no-webpack-loader-syntax */\n\nimport DDSWorker from 'comlink-loader!./dds.worker'; // inline loader\nimport DealWorker from 'comlink-loader!./deal.worker'; // inline loader\nimport SATWorker from 'comlink-loader!./sat.worker';\nimport SatisfiesWorker from 'comlink-loader!./satisfies.worker';\nimport { either as E, readonlyArray as RA, readonlyNonEmptyArray as RNEA, taskEither } from 'fp-ts';\nimport { observable as Ob, observableEither as ObE } from 'fp-ts-rxjs';\nimport { pipe } from 'fp-ts/lib/function';\nimport { from, groupBy, Observable } from 'rxjs';\n\nimport { get } from '../lib/object';\nimport pool from '../lib/pool';\nimport { Bid, makeBoard } from '../model/bridge';\nimport { GenerationId, Solution } from '../model/job';\nimport { SerializedBidPath, serializedBidPathL, serializedBoardL, SerializedDeal, serializedDealL } from '../model/serialization';\nimport { Path, Paths } from '../model/system';\nimport { ConstrainedBid } from '../model/system/core';\nimport { getBatchIdsByGenerationId } from '../services/idb';\n\nconst BATCH_SIZE = 500\nexport const observeDeals = (generationId: GenerationId) => (count: number) =>\n  pipe(\n    RA.replicate(count / BATCH_SIZE, BATCH_SIZE),\n    RA.append(count % BATCH_SIZE),\n    pool(() => new DealWorker(), w => b => w.genDeals(b, generationId)))\n\nexport interface SatisfiesBatchResult {\n  satisfiesCount: number\n  testedCount: number\n}\nexport interface SatisfiesResult extends SatisfiesBatchResult {\n  path: SerializedBidPath\n}\nexport const observeSatisfies = (generationId: GenerationId) => (paths: Paths<ConstrainedBid>) =>\n  pipe(generationId,\n    getBatchIdsByGenerationId,\n    ObE.fromTaskEither,\n    ObE.chain(x => ObE.fromObservable(from(x))),\n    ObE.bindTo('batchId'),\n    ObE.bind('path', () => ObE.fromObservable(from(paths))),\n    groupBy(E.isRight),\n    Ob.chain(group =>\n      group.key\n      ? pipe(group, Ob.map(r => r.right),\n          pool(() => new SatisfiesWorker(), w => ({ batchId, path }) =>\n            pipe(\n              () => w.satisfiesBatch(path, batchId, generationId),\n              taskEither.map((result): SatisfiesResult => ({ ...result,\n                path: pipe(path, RNEA.map(cb => cb.bid), serializedBidPathL.get),\n              })))\n            ()))\n      : group))\n\nexport const observeSolutions = (deals: ReadonlyArray<SerializedDeal>) =>\n  pipe(deals,\n    RA.mapWithIndex((i, d) => pipe(d,\n      serializedDealL.reverseGet,\n      makeBoard(i),\n      serializedBoardL.get)),\n    pool(() => new DDSWorker(), w => b => w.getResult(b)),\n    ObE.bimap(() => \"\", (x): Solution => ({\n      [x.board.deal.id]: x\n    })))\n\ntype ValidationResult = readonly [Path<Bid>, boolean]\nexport const observeValidation = (paths: ReadonlyArray<Path<ConstrainedBid>>) : Observable<ValidationResult> =>\n  pipe(paths,\n    pool(() => new SATWorker(), w => async p =>\n      pipe(await w.getPathIsSound(p),\n        E.fold(p0 => p0.length, () => p.length),\n        len => pipe(p,\n          RA.mapWithIndex(i => [\n            pipe(p, RNEA.map(get('bid')), RA.takeLeft(i + 1)) as Path<Bid>,\n            i < len] as const)))),\n    Ob.chain(x => from(x)))","import { option as O, readonlyArray as RA } from 'fp-ts';\nimport { observable as Ob, observableEither as ObE, observableOption as ObO } from 'fp-ts-rxjs';\nimport { constVoid, flow, pipe } from 'fp-ts/lib/function';\nimport { castDraft } from 'immer';\nimport { WritableDraft } from 'immer/dist/internal';\nimport memoize from 'proxy-memoize';\nimport { Epic, StateObservable } from 'redux-observable';\nimport { concatWith, EMPTY, Observable, of } from 'rxjs';\n\nimport { AnyAction, createSlice, PayloadAction } from '@reduxjs/toolkit';\n\nimport { RootState } from '../app/store';\nimport { AnalysisId, GenerationId, initJobProgress, Job, JobDetailsMap, JobId, JobTypeGenerateDeals, JobTypeSatisfies, JobTypeSolve, now, Solution, updateGenerateDealsProgress, updateSatisfiesProgress, updateSolveProgress, zeroJob } from '../model/job';\nimport { SerializedDeal } from '../model/serialization';\nimport { Paths } from '../model/system';\nimport { ConstrainedBid } from '../model/system/core';\nimport { observeDeals, observeSatisfies, observeSolutions, SatisfiesResult } from '../workers';\n\nconst name = 'generator'\ninterface State {\n  jobs: ReadonlyArray<Job>\n  completed: ReadonlyArray<Job>\n}\nconst initialState: State = {\n  jobs: [],\n  completed: []\n}\n\ninterface ScheduleJobPayload<T extends keyof JobDetailsMap, P extends JobDetailsMap[T]> {\n  analysisId: AnalysisId\n  type: T\n  parameter: P[\"parameter\"]\n  context: P[\"context\"]\n  estimatedUnitsInitial: number\n}\n\nconst slice = createSlice({\n  name,\n  initialState,\n  reducers: {\n    scheduleJob: <K extends keyof JobDetailsMap, D extends JobDetailsMap[K]>(state: WritableDraft<State>, action: PayloadAction<ScheduleJobPayload<K, D>>) => {\n      const job = zeroJob<K>(\n        action.payload.analysisId,\n        action.payload.estimatedUnitsInitial,\n        action.payload.type,\n        {\n          parameter: action.payload.parameter,\n          context: action.payload.context,\n          progress: O.none\n        } as D\n      )\n      state.jobs.push(castDraft(job) as WritableDraft<Job>)\n    },\n    startJob: (state, action: PayloadAction<{ jobId: JobId, type: Job[\"type\"] }>) => {\n      const job = state.jobs.find(j => j.id === action.payload.jobId)\n      if (job) {\n        job.details.progress = pipe(action.payload.type, initJobProgress, castDraft)\n        job.startDate = O.some(now())\n        job.running = true\n      }\n    },\n    completeJob: {\n      reducer: (state, action: PayloadAction<void, string, JobId, O.Option<string>>) => {\n        pipe(state.jobs,\n          RA.findIndex(j => j.id === action.meta),\n          O.map(idx => {\n            const job = state.jobs[idx]\n            job.completedDate = O.some(now())\n            job.running = false\n            job.error = action.error\n            state.completed.push(job)\n            state.jobs.splice(idx, 1)\n            return job\n          }))\n      },\n      prepare: (jobId: JobId, error: O.Option<string>) => ({ payload: constVoid(), meta: jobId, error })\n    },\n    removeJob: (state, action: PayloadAction<JobId>) => {\n      pipe(state.jobs,\n        RA.findIndex(j => j.id === action.payload),\n        O.map(idx => state.jobs.splice(idx, 1)))\n      pipe(state.completed,\n        RA.findIndex(j => j.id === action.payload),\n        O.map(idx => state.completed.splice(idx, 1)))\n    },\n    reportDeals: (state, action: PayloadAction<{ jobId: JobId, value: ReadonlyArray<SerializedDeal> }>) => {\n      const jobType = state.jobs.find(j => j.id === action.payload.jobId)?.details as JobTypeGenerateDeals\n      if (jobType) {\n        jobType.progress = pipe(jobType.progress, updateGenerateDealsProgress(action.payload.value))\n      }\n    },\n    reportSatisfies: (state, action: PayloadAction<{ jobId: JobId, value: SatisfiesResult }>) => {\n      const jobType = state.jobs.find(j => j.id === action.payload.jobId)?.details as JobTypeSatisfies\n      if (jobType) {\n        jobType.progress = pipe(jobType.progress, updateSatisfiesProgress(action.payload.value))\n      }\n    },\n    reportSolutions: (state, action: PayloadAction<{ jobId: JobId, value: Solution }>) => {\n      const jobType = state.jobs.find(j => j.id === action.payload.jobId)?.details as JobTypeSolve\n      if (jobType) {\n        jobType.progress = pipe(jobType.progress, updateSolveProgress(action.payload.value))\n      }\n    }\n  }\n})\n\nexport const { scheduleJob, startJob, completeJob, removeJob, reportDeals, reportSatisfies, reportSolutions } = slice.actions\nexport default slice.reducer\n\ninterface JobIndex {\n  state: State\n  jobId: JobId\n}\nexport const selectJobById = memoize((idx: JobIndex) =>\n  pipe(idx.state.jobs,\n    RA.findFirst(j => j.id === idx.jobId)))\n\nconst generateDeals = (jobId: JobId, generationId: GenerationId, count: number) =>\n  pipe(observeDeals(generationId)(count),\n    ObE.map(deals => reportDeals({ jobId, value: deals })),\n    ObE.getOrElse((err): Observable<AnyAction> =>\n      of(completeJob(jobId, O.some(err)))),\n    concatWith([completeJob(jobId, O.none)]))\n\nconst generateSatisfies = (jobId: JobId, generationId: GenerationId, paths: Paths<ConstrainedBid>) =>\n  pipe(observeSatisfies(generationId)(paths),\n    ObE.map(result => reportSatisfies({ jobId, value: result })),\n    ObE.getOrElse((err): Observable<AnyAction> =>\n      of(completeJob(jobId, O.some(err)))),\n    concatWith([completeJob(jobId, O.none)]))\n\nconst generateSolutions = (jobId: JobId, generationId: GenerationId, deals: ReadonlyArray<SerializedDeal>) =>\n  pipe(observeSolutions(deals),\n    ObE.map(result => reportSolutions({ jobId, value: result })),\n    ObE.getOrElse((err): Observable<AnyAction> =>\n      of(completeJob(jobId, O.some(err)))),\n    concatWith([completeJob(jobId, O.none)]))\n\nconst withJobType = <T extends keyof JobDetailsMap>(type: T) => (action$: Observable<AnyAction>, state$: StateObservable<RootState>) =>\n  action$.pipe(\n    Ob.filter(startJob.match),\n    Ob.map(a => a.payload),\n    Ob.filter(p => p.type === type),\n    Ob.map(p =>\n      pipe(state$.value.generator.jobs,\n        RA.findFirst(j => j.id === p.jobId),\n        O.map(x => x as Job<T>))))\n\nexport const epics : ReadonlyArray<Epic<AnyAction, AnyAction, RootState>> = [\n  flow(withJobType(\"GenerateDeals\"),\n    ObO.fold(() => EMPTY, job => generateDeals(job.id, job.details.context.generationId, job.details.parameter))),\n  flow(withJobType(\"Satisfies\"),\n    ObO.fold(() => EMPTY, job => generateSatisfies(job.id, job.details.context.generationId, job.details.parameter))),\n  flow(withJobType(\"Solve\"),\n    ObO.fold(() => EMPTY, job => generateSolutions(job.id, job.details.context.generationId, job.details.parameter)))\n]","import { either, eq, number, option, ord, readonlyArray, readonlyRecord, writer } from 'fp-ts';\nimport { constant, flow, identity, pipe } from 'fp-ts/lib/function';\nimport * as t from 'io-ts';\nimport { assertUnreachable } from '../lib';\nimport { Contract, ContractModifier, eqStrain, minors, Strain } from './bridge';\n\n\nexport interface ScoreInfo {\n  contract: Contract\n  tricks: number\n  isVulnerable: boolean\n}\n\ntype ScoreComponent = (info: ScoreInfo) => number\n\nconst contractPointMultiplier = (strain: Strain) => \n  pipe(minors, readonlyArray.elem(eqStrain)(strain)) ? 20 : 30\n\nconst contractModMultiplier = (modifier: ContractModifier) => {\n  switch (modifier) {\n    case \"Undoubled\": return 1\n    case \"Doubled\"  : return 2\n    case \"Redoubled\": return 4\n    default: return assertUnreachable(modifier)\n  }\n}\n\nconst contractFirstTrickModifier = (strain: Strain) =>\n  strain === \"N\" ? 10 : 0\n\nconst subtractBookTricks = (tricks: number) =>\n  tricks - 6\n\nexport const making = (contract: Contract, tricks: number) =>\n  pipe(\n    tricks,\n    subtractBookTricks,\n    either.fromPredicate(\n      oddTricks => oddTricks >= contract.level,\n      oddTricks => contract.level - oddTricks))\n\nconst getOddTricks =\n  flow(making, option.fromEither)\n\nconst getOvertricks = (contract: Contract, tricks: number) =>\n  pipe(making(contract, tricks),\n    option.fromEither,\n    option.map(oddTricks => oddTricks - contract.level))\n\nconst getUndertricks = (contract: Contract, tricks: number) =>\n  pipe(making(contract, tricks),\n    either.swap,\n    option.fromEither)\n\nconst whenMaking = (f: (oddTricks: number) => number) => (info: ScoreInfo) =>\n  pipe(getOddTricks(info.contract, info.tricks),\n    option.fold(constant(0), f))\n\nconst contractPoints: ScoreComponent = info =>\n  pipe(info, whenMaking(() =>\n    contractModMultiplier(info.contract.modifier) *\n    ((info.contract.level * contractPointMultiplier(info.contract.strain)) + contractFirstTrickModifier(info.contract.strain))))\n\nconst vulnerableMultiplier = (isVulnerable: boolean) =>\n  50 * (isVulnerable ? 2 : 1)\n\nconst getModified = (modifier: ContractModifier) : option.Option<\"Doubled\" | \"Redoubled\"> =>\n  modifier === \"Undoubled\" ? option.none : option.some(modifier)\n\nconst overtrickBonus = (isVulnerable: boolean, modifier: ContractModifier) => \n  pipe(modifier,\n    getModified,\n    option.map(contractModMultiplier),\n    option.map(x => x * vulnerableMultiplier(isVulnerable)))\n\nconst overtrickPoints: ScoreComponent = info =>\n  pipe(getOvertricks(info.contract, info.tricks),\n    option.fold(constant(0), overtricks =>\n      pipe(\n        overtrickBonus(info.isVulnerable, info.contract.modifier),\n        option.getOrElseW(() => contractPointMultiplier(info.contract.strain)),\n        multiplier => overtricks * multiplier)))\n\nconst slamPoints: ScoreComponent = info =>\n  pipe(info, whenMaking(oddTricks =>\n    (info.isVulnerable ? 1.5 : 1) *\n    (info.contract.level === 6 && oddTricks >= 6 ? 500 :\n      info.contract.level === 7 && oddTricks >= 7 ? 1000 : 0)))\n\nconst modifierPoints: ScoreComponent = info =>\n  pipe(info, whenMaking(() => {\n    switch (info.contract.modifier) {\n      case \"Undoubled\": return 0\n      case \"Doubled\"  : return 50\n      case \"Redoubled\": return 100\n      default: return assertUnreachable(info.contract.modifier)\n    }\n  }))\n\nconst doubledPenalties = [100, 200, 200, ...readonlyArray.replicate(10, 300)]\n\nconst penaltyPoints: ScoreComponent = info =>\n  pipe(getUndertricks(info.contract, info.tricks),\n    option.fold(constant(0), undertricks =>\n      pipe(info.contract.modifier,\n        getModified,\n        option.fold(\n          () => undertricks * vulnerableMultiplier(info.isVulnerable),\n          flow(contractModMultiplier,\n            multiplier => (multiplier / 2) * pipe(\n              doubledPenalties,\n              readonlyArray.takeLeft(undertricks + (info.isVulnerable ? 1 : 0)),\n              readonlyArray.foldMap(number.MonoidSum)(identity)))),\n        x => -x)))\n\nconst partScorePoints: ScoreComponent =\n  flow(contractPoints, score =>\n    score > 0 && score <= 100 ? 50 : 0)\n\nconst gamePoints: ScoreComponent = info =>\n  pipe(info, contractPoints, score =>\n    score >= 100 ? (info.isVulnerable ? 500 : 300) : 0)\n\nconst scoreComponents : readonlyRecord.ReadonlyRecord<string, ScoreComponent> = {\n  contractPoints : contractPoints,\n  overtrickPoints: overtrickPoints,\n  slamPoints     : slamPoints,\n  modifierPoints : modifierPoints,\n  penaltyPoints  : penaltyPoints,\n  partScorePoints: partScorePoints,\n  gamePoints     : gamePoints,\n}\n\nconst ScoreC = t.brand(t.number, (i) : i is t.Branded<number, { readonly Score: unique symbol }> => typeof i === \"number\", 'Score')\nexport type Score = t.TypeOf<typeof ScoreC>\nexport const zeroScore = (ScoreC.decode(0) as either.Right<Score>).right\nexport const eqScore : eq.Eq<Score> = number.Eq\nexport const ordScore : ord.Ord<Score> = pipe(number.Ord, ord.reverse)\n\nexport type ScoreComponentLog = readonly [string, number]\n\ntype W = ReadonlyArray<ScoreComponentLog>\nexport const scoreW = (info: ScoreInfo): writer.Writer<W, Score> => \n  pipe(\n    scoreComponents,\n    readonlyRecord.flap(info),\n    readonlyRecord.traverseWithIndex(writer.getApplicative(readonlyArray.getMonoid<ScoreComponentLog>()))((name, score) => pipe(\n      writer.tell([[name, score]] as const),\n      writer.map(constant(score)))),\n    writer.map(flow(\n      readonlyRecord.foldMap(ord.trivial)(number.MonoidSum)(identity),\n      ScoreC.decode,\n      s => (s as either.Right<Score>).right)),\n    writer.map((s): [Score, (w: W) => W] => [s, cs => [[\"TOTAL\", s], ...cs]]),\n    writer.pass)\n\nexport const score = flow(scoreW, writer.evaluate)","import {\n  either,\n  eitherT,\n  option,\n  readonlyArray,\n  readonlyMap,\n  readonlyNonEmptyArray as RNEA,\n  readonlyRecord as RR,\n  readonlyTuple,\n  refinement,\n  semigroup,\n  eq,\n} from \"fp-ts\";\nimport { constant, flow, pipe } from \"fp-ts/lib/function\";\nimport { ordAscending, ordDescending } from \"../lib\";\nimport {\n  ContractBid,\n  contractBids,\n  ContractModifier,\n  Direction,\n  eqContractBid,\n  getIsVulnerable,\n  ordContractBid,\n  Strain,\n  Vulnerability,\n} from \"./bridge\";\nimport { eqScore, making, ordScore, Score, score, zeroScore } from \"./score\";\n\nexport type TrickCountsByStrain = RR.ReadonlyRecord<Strain, number>;\nexport type TrickCountsByDirection = RR.ReadonlyRecord<Direction, number>;\nexport type TrickCountsByStrainThenDirection = RR.ReadonlyRecord<\n  Strain,\n  TrickCountsByDirection\n>;\nexport type TrickCountsByDirectionThenStrain = RR.ReadonlyRecord<\n  Direction,\n  TrickCountsByStrain\n>;\n\nexport const flattenNestedCounts = <K1 extends string, K2 extends string, T>(\n  table: RR.ReadonlyRecord<K1, RR.ReadonlyRecord<K2, T>>\n) =>\n  pipe(\n    readonlyArray.Do,\n    readonlyArray.apS(\"inner\", pipe(table, RR.toReadonlyArray)),\n    readonlyArray.bind(\"outer\", ({ inner }) =>\n      pipe(inner[1], RR.toReadonlyArray)\n    ),\n    readonlyArray.map(({ outer, inner }) => ({\n      outerKey: outer[0],\n      innerKey: inner[0],\n      value: outer[1],\n    }))\n  );\n\nexport const transpose = <K1 extends string, K2 extends string, T>(\n  table: RR.ReadonlyRecord<K1, RR.ReadonlyRecord<K2, T>>\n): RR.ReadonlyRecord<K2, RR.ReadonlyRecord<K1, T>> =>\n  pipe(\n    table,\n    flattenNestedCounts,\n    RNEA.fromReadonlyArray,\n    option.fold(\n      () => ({}),\n      RNEA.groupBy((x) => x.outerKey)\n    ),\n    RR.map(\n      flow(\n        RNEA.fromReadonlyArray,\n        option.fold(\n          () => ({}),\n          RNEA.groupBy((x) => x.innerKey)\n        ),\n        RR.map((x) => x[0].value)\n      )\n    )\n  );\n\nexport type OptimalBid = ContractBid | \"Pass\";\nexport const eqOptimalBid: eq.Eq<OptimalBid> = {\n  equals: (a, b) =>\n    (!(a === \"Pass\" || b === \"Pass\") && eqContractBid.equals(a, b)) || a === b,\n};\nconst initialContractBid: refinement.Refinement<OptimalBid, ContractBid> = (\n  b\n): b is ContractBid => b !== \"Pass\";\nconst initialBids = pipe(\n  contractBids,\n  readonlyArray.sort(ordContractBid),\n  readonlyArray.prepend<OptimalBid>(\"Pass\")\n);\nconst ordInitialBidsDescending = ordDescending(initialBids);\n\nexport type ContractScorePair = readonly [OptimalBid, Score];\nconst getDirectionScores =\n  (counts: TrickCountsByStrain) => (isVulnerable: boolean) =>\n    pipe(\n      initialBids,\n      readonlyArray.map(\n        either.fromPredicate(initialContractBid, () => \"Pass\" as const)\n      ),\n      eitherT.match(readonlyArray.Functor)(\n        (pass): ContractScorePair => [pass, zeroScore],\n        (bid): ContractScorePair => {\n          const tricks = counts[bid.strain];\n          const modifier: ContractModifier = pipe(\n            making({ ...bid, modifier: \"Undoubled\" }, tricks),\n            either.fold(constant(\"Doubled\"), constant(\"Undoubled\"))\n          );\n          return [\n            bid,\n            score({ contract: { ...bid, modifier }, tricks, isVulnerable }),\n          ];\n        }\n      )\n    );\n\nexport const getAllScores =\n  (vulnerability: Vulnerability) => (table: TrickCountsByDirectionThenStrain) =>\n    pipe(\n      table,\n      RR.mapWithIndex((direction, counts) =>\n        getDirectionScores(counts)(getIsVulnerable(direction, vulnerability))\n      )\n    );\n\n// const byContractDescending : ord.Ord<ContractScorePair> =\n//   ord.contramap(readonlyTuple.fst)(ordInitialBidsDescending)\n\nconst shakeContracts = (\n  contractScorePairs: RNEA.ReadonlyNonEmptyArray<ContractScorePair>\n) =>\n  pipe(\n    contractScorePairs,\n    RNEA.map(readonlyTuple.swap),\n    readonlyMap.fromFoldable(\n      eqScore,\n      semigroup.max(ordInitialBidsDescending),\n      RNEA.Foldable\n    ),\n    readonlyMap.toReadonlyArray(ordScore)\n  );\n\nconst pvs = (\n  direction: Direction,\n  availableMoves: RNEA.ReadonlyNonEmptyArray<ContractScorePair>\n): OptimalBid => \"Pass\";\n\nexport interface IndependentVariables {\n  dealer: Direction;\n  vulnerability: Vulnerability;\n}\nexport const parScore =\n  (table: TrickCountsByStrainThenDirection) =>\n  (vars: IndependentVariables): Score =>\n    zeroScore;\n","import * as aq from \"arquero\";\nimport {\n  option as O,\n  readonlyArray as RA,\n  readonlyNonEmptyArray as RNEA,\n  readonlyRecord as RR,\n  readonlyTuple,\n  semigroup as S,\n  ord,\n  number,\n  tuple,\n} from \"fp-ts\";\nimport { sequenceT } from \"fp-ts/lib/Apply\";\nimport { flow, pipe } from \"fp-ts/lib/function\";\nimport * as iso from \"monocle-ts/Iso\";\n\nimport { DoubleDummyTable } from \"../workers/dds.worker\";\nimport {\n  ContractScorePair,\n  OptimalBid,\n  eqOptimalBid,\n  flattenNestedCounts,\n  getAllScores,\n  transpose,\n} from \"./analyze\";\nimport { Direction, directions, Strain, strains } from \"./bridge\";\nimport { Score, eqScore } from \"./score\";\nimport { serializedContractBidL } from \"./serialization\";\n\nconst SerializedKeyL: iso.Iso<readonly [Direction, Strain], string> = iso.iso(\n  ([d, s]) => d + s,\n  (s) => [s.charAt(0) as Direction, s.charAt(1) as Strain] as const\n);\n\nconst columns = pipe(\n  sequenceT(RNEA.Apply)(directions, strains),\n  RNEA.map(SerializedKeyL.get)\n);\n\nconst aggregate =\n  (f: (field: any) => number) =>\n  (table: aq.internal.ColumnTable): DoubleDummyTable =>\n    pipe(\n      columns,\n      RNEA.groupBy((c) => c),\n      RR.map((c) => f(c)),\n      (x) => table.rollup(x),\n      (table) => table.object() as RR.ReadonlyRecord<string, number>,\n      RR.toReadonlyArray,\n      RA.map(readonlyTuple.mapFst(SerializedKeyL.reverseGet)),\n      RNEA.fromReadonlyArray,\n      O.fold(\n        () => ({}),\n        flow(\n          RNEA.groupBy(([[_, strain], __]) => strain),\n          RR.map(\n            flow(\n              RNEA.groupBy(([[direction, _], __]) => direction),\n              RR.map(flow(RNEA.head, ([_, agg]) => agg))\n            )\n          )\n        )\n      )\n    );\n\nconst toRow = (ddt: DoubleDummyTable) =>\n  pipe(\n    ddt,\n    flattenNestedCounts,\n    RA.map(\n      ({ outerKey: direction, innerKey: strain, value: count }) =>\n        [`${direction}${strain}`, count] as const\n    ),\n    RR.fromFoldable(S.first<number>(), RA.Foldable)\n  );\n\nexport type Scores = RNEA.ReadonlyNonEmptyArray<\n  RR.ReadonlyRecord<Direction, ReadonlyArray<ContractScorePair>>\n>;\n\nexport const getScores = (\n  ddt: RNEA.ReadonlyNonEmptyArray<DoubleDummyTable>\n): Scores =>\n  pipe(\n    ddt,\n    RNEA.map(flow(transpose, getAllScores(\"Neither\")))\n    // aq.from,\n    // ct => ct.count(),\n    // ct => ct.object() as RR.ReadonlyRecord<string, number>\n  );\n\ntype BidScorePair = readonly [string, Score];\nexport type ScoreCompare = RR.ReadonlyRecord<string, number> | { tie: number };\n\nconst ordScore: ord.Ord<Score> = ord.reverse(\n  ord.fromCompare((a, b) => number.Ord.compare(a, b))\n);\nconst ordScores: ord.Ord<BidScorePair> = pipe(\n  ordScore,\n  ord.contramap(([_, score]) => score)\n);\n\nconst tallyScore = (results: ReadonlyArray<BidScorePair>): ScoreCompare => {\n  const orderedScores = pipe(results, RA.sort(ordScores), (x) => x);\n  if (\n    !orderedScores.length ||\n    (orderedScores.length > 1 &&\n      eqScore.equals(orderedScores[0][1], orderedScores[1][1]))\n  ) {\n    return { tie: 1 };\n  } else {\n    return { [orderedScores[0][0]]: 1 };\n  }\n};\nconst sumCompare: S.Semigroup<ScoreCompare> = RR.getUnionSemigroup(\n  number.SemigroupSum\n);\nconst zeroCompare = (bids: RNEA.ReadonlyNonEmptyArray<string>): ScoreCompare =>\n  pipe(\n    bids,\n    RNEA.map((b: string) => [b, 0] as const),\n    RR.fromEntries\n  );\n\nconst serializeOptimalBid = (bid: OptimalBid): string =>\n  bid === \"Pass\" ? \"Pass\" : serializedContractBidL.get(bid);\n\nexport const compareScores =\n  (scores: Scores) =>\n  (dirsAndBids: RNEA.ReadonlyNonEmptyArray<[Direction, OptimalBid]>) =>\n    pipe(\n      scores,\n      RNEA.map((score) =>\n        pipe(\n          dirsAndBids,\n          RNEA.map(([dir, bid]) =>\n            pipe(\n              score[dir],\n              RA.filter(([contract]) =>\n                bid === \"Pass\"\n                  ? contract === \"Pass\"\n                  : eqOptimalBid.equals(bid, contract)\n              ),\n              RNEA.fromReadonlyArray,\n              O.fold(\n                () => ({}),\n                RNEA.groupBy(([contract]) => serializeOptimalBid(contract))\n              ),\n              RR.map((x) => x[0]),\n              RR.map(([_, score]) => score)\n            )\n          ),\n          RNEA.map(RR.toReadonlyArray),\n          RA.chain((x) => x),\n          tallyScore\n        )\n      ),\n      RNEA.foldMap(sumCompare)((x: ScoreCompare) => x),\n      (s) =>\n        sumCompare.concat(\n          zeroCompare(\n            pipe(dirsAndBids, RNEA.map(flow(tuple.snd, serializeOptimalBid)))\n          ),\n          s\n        )\n    );\n\nexport interface Stats {\n  count: number;\n  scores: Scores;\n  average: DoubleDummyTable;\n  stdev: DoubleDummyTable;\n}\n\nexport const getStats = (ddt: RNEA.ReadonlyNonEmptyArray<DoubleDummyTable>) =>\n  pipe(\n    ddt,\n    RNEA.map(toRow),\n    aq.from,\n    (ct): Stats => ({\n      count: ct.totalRows(),\n      scores: pipe(ddt, getScores),\n      average: pipe(ct, aggregate(aq.op.mean)),\n      stdev: pipe(ct, aggregate(aq.op.stdev)),\n    })\n  );\n","import {\n  option as O,\n  readonlyArray as RA,\n  readonlyNonEmptyArray as RNEA,\n  readonlyRecord as RR,\n  readonlyTuple as RT,\n  taskEither as TE,\n} from \"fp-ts\";\nimport { observable as Ob, observableEither } from \"fp-ts-rxjs\";\nimport { flow, pipe } from \"fp-ts/lib/function\";\nimport { castDraft } from \"immer\";\nimport memoize from \"proxy-memoize\";\nimport { Epic } from \"redux-observable\";\nimport { concatWith, EMPTY, from, of } from \"rxjs\";\nimport { WritableDraft } from \"immer/dist/internal\";\n\nimport { AnyAction, createSlice, PayloadAction } from \"@reduxjs/toolkit\";\n\nimport { RootState } from \"../app/store\";\nimport { assertUnreachable } from \"../lib\";\nimport { get } from \"../lib/object\";\nimport {\n  Analysis,\n  AnalysisId,\n  GenerationId,\n  Job,\n  JobDetailsMap,\n  JobTypeGenerateDeals,\n  newGenerationId,\n  zeroAnalysis,\n  zeroGeneration,\n} from \"../model/job\";\nimport { getStats } from \"../model/stats\";\nimport { Paths } from \"../model/system\";\nimport { ConstrainedBid } from \"../model/system/core\";\nimport { deleteByGenerationId } from \"../services/idb\";\nimport { completeJob, removeJob, scheduleJob, startJob } from \"./generator\";\n\ninterface State {\n  analyses: RR.ReadonlyRecord<AnalysisId, Analysis>;\n  selectedAnalysis: O.Option<AnalysisId>;\n}\nconst initialState: State = {\n  analyses: {},\n  selectedAnalysis: O.none,\n};\n\nconst name = \"profile\";\n\nconst slice = createSlice({\n  name,\n  initialState,\n  reducers: {\n    addAnalysis: (\n      state,\n      action: PayloadAction<{\n        id: AnalysisId;\n        name: string;\n        count: number;\n        paths: Paths<ConstrainedBid>;\n      }>\n    ) => {\n      const analysis = pipe(\n        action.payload,\n        ({ id, name, count, paths }) => zeroAnalysis(id, name, paths),\n        castDraft\n      );\n      state.analyses[analysis.id] = analysis;\n    },\n    deleteAnalysis: (state, action: PayloadAction<AnalysisId>) => {},\n    removeAnalysis: (state, action: PayloadAction<AnalysisId>) => {\n      delete state.analyses[action.payload];\n    },\n    selectAnalysis: (state, action: PayloadAction<AnalysisId>) => {\n      state.selectedAnalysis = pipe(\n        RR.has(action.payload, state.analyses) ? O.some(action.payload) : O.none\n      );\n    },\n    setAnalysisName: {\n      reducer: (state, action: PayloadAction<string, string, AnalysisId>) => {\n        state.analyses[action.meta].name = action.payload;\n      },\n      prepare: (id: AnalysisId, name: string) => ({ payload: name, meta: id }),\n    },\n    addJobToAnalysis: <K extends keyof JobDetailsMap>(\n      state: WritableDraft<State>,\n      action: PayloadAction<Job<K>>\n    ) => {\n      pipe(\n        state.analyses,\n        RR.lookup(action.payload.analysisId),\n        O.map((analysis) => {\n          switch (action.payload.type) {\n            case \"GenerateDeals\":\n              const genJob = action.payload as Job<\"GenerateDeals\">;\n              return pipe(\n                genJob.details.progress,\n                O.map((p) =>\n                  analysis.generations.push(\n                    pipe(\n                      zeroGeneration(\n                        genJob.details.context.generationId,\n                        p.value\n                      ),\n                      castDraft\n                    )\n                  )\n                )\n              );\n            case \"Satisfies\":\n              const satJob = action.payload as Job<\"Satisfies\">;\n              return pipe(\n                O.Do,\n                O.apS(\"progress\", satJob.details.progress),\n                O.apS(\n                  \"generation\",\n                  pipe(\n                    analysis.generations,\n                    RA.findFirst(\n                      (g) => g.id === satJob.details.context.generationId\n                    )\n                  )\n                ),\n                O.map(\n                  (o) => (o.generation.satisfies = O.some(o.progress.value))\n                )\n              );\n            case \"Solve\":\n              const solveJob = action.payload as Job<\"Solve\">;\n              return pipe(\n                O.Do,\n                O.apS(\"progress\", solveJob.details.progress),\n                O.apS(\n                  \"generation\",\n                  pipe(\n                    analysis.generations,\n                    RA.findFirst(\n                      (g) => g.id === solveJob.details.context.generationId\n                    )\n                  )\n                ),\n                O.map((o) =>\n                  pipe(\n                    o.progress.value,\n                    RR.toReadonlyArray,\n                    RNEA.fromReadonlyArray,\n                    O.map(\n                      flow(\n                        RNEA.map(flow(RT.snd, get(\"results\"))),\n                        getStats,\n                        (stats) => {\n                          if (\n                            RR.has(\n                              solveJob.details.context.bidPath,\n                              o.generation.solutionStats\n                            )\n                          ) {\n                            throw new Error(\n                              \"Combining stat result sets is not implemented\"\n                            );\n                          }\n                          o.generation.solutionStats[\n                            solveJob.details.context.bidPath\n                          ] = castDraft(stats);\n                        }\n                      )\n                    )\n                  )\n                )\n              );\n            default:\n              return assertUnreachable(action.payload.type);\n          }\n        })\n      );\n    },\n  },\n});\n\nexport const {\n  addAnalysis,\n  deleteAnalysis,\n  selectAnalysis,\n  setAnalysisName,\n  addJobToAnalysis,\n} = slice.actions;\nexport default slice.reducer;\n\nexport const epics: ReadonlyArray<Epic<AnyAction, AnyAction, RootState>> = [\n  (action$, state$) =>\n    action$.pipe(\n      Ob.filter(addAnalysis.match),\n      Ob.chain(\n        flow(\n          (a) => a.payload,\n          ({ id, count }) =>\n            pipe(\n              state$.value.profile.analyses,\n              RR.keys,\n              RA.filter((id2) => id2 !== id),\n              RA.map(deleteAnalysis),\n              (analyses) =>\n                from([\n                  ...analyses,\n                  selectAnalysis(id),\n                  scheduleJob({\n                    analysisId: id,\n                    type: \"GenerateDeals\",\n                    context: { generationId: newGenerationId() },\n                    parameter: count,\n                    estimatedUnitsInitial: count,\n                  }),\n                ])\n            )\n        )\n      )\n    ),\n  (action$, state$) =>\n    action$.pipe(\n      Ob.filter(addJobToAnalysis.match),\n      Ob.filterMap((a) =>\n        pipe(\n          O.Do,\n          O.bind(\"job\", () =>\n            a.payload.type === \"GenerateDeals\"\n              ? O.some(a.payload as Job & { details: JobTypeGenerateDeals })\n              : O.none\n          ),\n          O.bind(\"analysis\", ({ job }) =>\n            selectAnalysisById({\n              state: state$.value.profile,\n              analysisId: job.analysisId,\n            })\n          )\n        )\n      ),\n      Ob.chain(({ job, analysis }) =>\n        of(\n          scheduleJob({\n            analysisId: job.analysisId,\n            type: \"Satisfies\",\n            parameter: analysis.paths,\n            context: job.details.context,\n            estimatedUnitsInitial:\n              analysis.paths.length * job.details.parameter,\n          })\n        )\n      )\n    ),\n  (action$, state$) =>\n    action$.pipe(\n      Ob.filter(completeJob.match),\n      Ob.filter((a) => O.isNone(a.error)),\n      Ob.chain(\n        flow(\n          (a) => a.meta,\n          (jobId) =>\n            pipe(\n              state$.value.generator.completed,\n              RA.findFirst((j) => j.id === jobId),\n              O.fold(\n                () => EMPTY,\n                (j) => from([addJobToAnalysis(j), removeJob(jobId)])\n              )\n            )\n        )\n      )\n    ),\n  (action$, state$) =>\n    state$.pipe(\n      Ob.map((s) =>\n        pipe(\n          s.generator.jobs,\n          RA.filter((j) => O.isNone(j.startDate))\n        )\n      ),\n      Ob.filterMap(RNEA.fromReadonlyArray),\n      Ob.chain(\n        flow(\n          RA.map((j) => startJob({ jobId: j.id, type: j.type })),\n          from\n        )\n      )\n    ),\n  (action$, state$) =>\n    action$.pipe(\n      Ob.filter(deleteAnalysis.match),\n      Ob.map((a) => a.payload),\n      Ob.chain((analysisId) =>\n        pipe(\n          state$.value.profile.analyses,\n          RR.lookup(analysisId),\n          O.fold(\n            () => EMPTY,\n            (a) =>\n              pipe(\n                a.generations,\n                RA.map((g) => g.id),\n                TE.traverseArray(deleteByGenerationId),\n                Ob.fromTask\n              )\n          ),\n          observableEither.fold(\n            () => EMPTY,\n            (x) => EMPTY\n          ),\n          concatWith(of(slice.actions.removeAnalysis(analysisId)))\n        )\n      )\n    ),\n];\n\nexport const selectAllAnalyses = memoize((state: State) =>\n  pipe(state.analyses, RR.toReadonlyArray, RA.map(RT.snd))\n);\n\nexport const selectSelectedAnalysis = memoize((state: State) =>\n  pipe(\n    state.selectedAnalysis,\n    O.chain((id) => RR.lookup(id, state.analyses))\n  )\n);\n\ninterface AnalysisIndex {\n  state: State;\n  analysisId: AnalysisId;\n}\nexport const selectAnalysisById = memoize((idx: AnalysisIndex) =>\n  pipe(idx.state.analyses, RR.lookup(idx.analysisId))\n);\n\ninterface GenerationIndex extends AnalysisIndex {\n  generationId: GenerationId;\n}\nexport const selectGenerationByAnalysis = memoize((idx: GenerationIndex) =>\n  pipe(\n    selectAnalysisById(idx),\n    O.chain(\n      flow(\n        get(\"generations\"),\n        RA.findFirst((g) => g.id === idx.generationId)\n      )\n    )\n  )\n);\n","import { either as E, eq, option as O, readonlyArray as RA, readonlyNonEmptyArray as RNEA, readonlyRecord, readonlyTuple, show, these as TH, tree as T } from 'fp-ts';\nimport { flow, pipe } from 'fp-ts/lib/function';\n\nimport { SyntacticBid } from './system/expander';\n\nexport type Path<A> = RNEA.ReadonlyNonEmptyArray<A>\nexport type Paths<A> = RNEA.ReadonlyNonEmptyArray<Path<A>>\nexport type Forest<A> = ReadonlyArray<T.Tree<A>>\n\nexport const getPathUpTo = <A>(eqA: eq.Eq<A>) => (item: A) =>\n  RA.findFirstMap(\n    T.fold((a: A, paths: ReadonlyArray<O.Option<RNEA.ReadonlyNonEmptyArray<A>>>) : O.Option<RNEA.ReadonlyNonEmptyArray<A>> =>\n      eqA.equals(a, item)\n      ? O.some([item])\n      : pipe(paths,\n          RA.findFirstMap(O.map(RA.prepend(a))))))\n\nexport const flatten = <A>(forest: Forest<A>) =>\n  pipe(forest,\n    RA.chain(\n      T.reduce<A, ReadonlyArray<A>>([], (items, a) =>\n        pipe(items, RA.append(a)))))\n\nexport const getPathForest = <A>(forest: Forest<A>) : Forest<Path<A>> =>\n  pipe(forest,\n    RA.map(flow(\n      T.map(RNEA.of),\n      T.fold((a, forest: ReadonlyArray<T.Tree<Path<A>>>) =>\n        T.make(a, pipe(forest,\n          RA.map(T.map(path => RNEA.concat(path)(a))), RA.toArray))))))\n\nexport const getAllLeafPaths = <A>(forest: Forest<A>): ReadonlyArray<Path<A>> =>\n  pipe(forest,\n    RA.chain(\n      T.fold((node: A, paths: ReadonlyArray<Paths<A>>): Paths<A> =>\n        pipe(paths,\n          RNEA.fromReadonlyArray,\n          O.fold(() => [[node]],\n            RNEA.foldMap(RNEA.getSemigroup<Path<A>>())(RNEA.map(RA.prepend(node))))))),\n    RA.filterMap(RNEA.fromReadonlyArray))\n\nexport const getForestFromLeafPaths = <A, F extends show.Show<A>>(show: F) => (paths: ReadonlyArray<Path<A>>): Forest<A> =>\n  pipe(paths,\n    RNEA.fromReadonlyArray,\n    O.fold(\n      () => RA.empty,\n      flow(\n        RNEA.groupBy(flow(RNEA.head, show.show)),\n        readonlyRecord.toReadonlyArray,\n        RA.map(flow(\n          readonlyTuple.snd,\n          paths => T.make(\n            RNEA.head(RNEA.head(paths)),\n            pipe(paths,\n              RNEA.map(flow(\n                RNEA.tail,\n                RNEA.fromReadonlyArray)),\n              RA.compact,\n              getForestFromLeafPaths(show),\n              RA.toArray)))))))\n\nconst extendTreeWithSiblings = <A>(eqA: eq.Eq<A>) => (siblings: ReadonlyArray<A>) => (t: T.Tree<A>) : T.Tree<A & { siblings: ReadonlyArray<A> }> =>\n  T.make(\n    ({ ...t.value, siblings }),\n    pipe(t.forest, RA.map(u =>\n      pipe(t.forest,\n        RA.map(t => t.value),\n        RA.difference(eqA)([u.value]), // end null hack\n        extendTreeWithSiblings(eqA))(u)),\n      RA.toArray))\n\nexport const extendForestWithSiblings = <A>(eqA: eq.Eq<A>) => (forest: Forest<A>) =>\n  pipe(forest, RA.map(t =>\n    pipe(forest,\n      RA.map(t => t.value),\n      RA.difference(eqA)([t.value]),\n      extendTreeWithSiblings(eqA))(t)))\n\nexport const withImplicitPasses =\n  RA.map(\n    T.fold((a: SyntacticBid, bs: T.Forest<SyntacticBid>) =>\n      bs.length === 0 || pipe(bs, RA.exists(t => t.value.bid === \"Pass\"))\n      ? T.make(a, bs)\n      : T.make(a, pipe(bs,\n        RA.append(T.make<SyntacticBid>({ bid: \"Pass\", syntax: { type: \"Otherwise\" }})),\n        RA.toArray))))\n\nexport type ForestWithErrors<L, R> = TH.These<ReadonlyArray<L>, Forest<R>>\nexport const collectErrors = <L, R>(forest: Forest<E.Either<L, R>>): ForestWithErrors<L, R> =>\n  pipe(forest,\n    RA.map(T.traverse(TH.getApplicative(RA.getMonoid<L>()))(E.mapLeft(RA.of))),\n    RA.sequence(TH.getApplicative(RA.getSemigroup<L>())))\n      \nexport const chainCollectedErrors = <A, B, E>(f: (a: A) => TH.These<ReadonlyArray<E>, B>) => (fa: TH.These<ReadonlyArray<E>, A>) =>\n  TH.getChain(RA.getSemigroup<E>()).chain(fa, f)","import { either as E, eitherT, eq, option as O, optionT, readonlyArray as RA, readonlyMap as RM, readonlyNonEmptyArray as RNEA, separated, state as S, string, these, tree as T } from 'fp-ts';\nimport { constant, constVoid, flow, pipe } from 'fp-ts/lib/function';\nimport { Lens } from 'monocle-ts';\nimport { Object } from 'ts-toolbelt';\n\nimport { assertUnreachable } from '../../lib';\nimport { Bid, ContractBid, eqBid, isContractBid } from '../bridge';\nimport { Suit, suits } from '../deck';\nimport { AnyShape, makeShape } from '../evaluation';\nimport { serializedBidL } from '../serialization';\nimport { collectErrors, extendForestWithSiblings, Forest } from '../system';\nimport { ConstrainedBid, Constraint, ConstraintSetTrump, ConstraintSuitComparison, ConstraintSuitHonors, ConstraintSuitPrimary, ConstraintSuitRange, ConstraintSuitSecondary, ConstraintSuitTop, constraintTrue } from './core';\n\nexport const ofS = <A>(x: A) => S.of<ExpandContext, A>(x)\n\nexport type SuitContextSpecifier = \"Wildcard\" | \"Major\" | \"Minor\" | \"OtherMajor\" | \"OtherMinor\"\nexport type SuitSpecifier = SuitContextSpecifier | Suit\nconst isSuit = (s: string): s is Suit =>\n  pipe(suits, RA.elem(string.Eq)(s))\ntype ContextualSuitSyntax<T extends Constraint> = Object.Replace<T, Suit, SuitSpecifier>\ntype SyntaxSuitRange = ContextualSuitSyntax<ConstraintSuitRange>\ntype SyntaxSuitComparison = ContextualSuitSyntax<ConstraintSuitComparison>\ntype SyntaxSuitHonors = ContextualSuitSyntax<ConstraintSuitHonors>\ntype SyntaxSuitTop = ContextualSuitSyntax<ConstraintSuitTop>\ntype SyntaxSuitPrimary = ContextualSuitSyntax<ConstraintSuitPrimary>\ntype SyntaxSuitSecondary = ContextualSuitSyntax<ConstraintSuitSecondary>\ntype SyntaxSetTrump = ContextualSuitSyntax<ConstraintSetTrump>\ntype SyntaxSuit = \n  | SyntaxSuitRange\n  | SyntaxSuitComparison\n  | SyntaxSuitHonors\n  | SyntaxSuitTop\n  | SyntaxSuitPrimary\n  | SyntaxSuitSecondary\n  | SyntaxSetTrump\n\ninterface SyntaxDistribution {\n  type: \"Balanced\" | \"SemiBalanced\" | \"Unbalanced\"\n}\n\ninterface SyntaxLabelDef {\n  type: \"LabelDef\"\n  name: string\n  definition: Syntax\n}\nconst labelDef = (s: SyntaxLabelDef) =>\n  pipe(\n    S.gets(flow(\n      labelsL.get,\n      RM.lookup(string.Eq)(s.name))),\n    S.chain(O.fold(\n      () => ofS(s.definition),\n      c0 => ofS({ type: \"Conjunction\", syntax: [c0, s.definition] } as const))),\n    S.chainFirst(syntax => S.modify(labelsL.modify(RM.upsertAt(string.Eq)(s.name, syntax)))),\n    S.map(flow(E.right, E.right)))\n\ninterface SyntaxLabelRef {\n  type: \"LabelRef\"\n  name: string\n}\nconst labelRef = (s: SyntaxLabelRef) =>\n  pipe(\n    S.gets(flow(\n      labelsL.get,\n      RM.lookup(string.Eq)(s.name))),\n    S.map(flow(\n      E.fromOption((): ExpandErrorReason => \"LabelNotFound\"),\n      E.map(E.right))))\n\ninterface SyntaxWrapper {\n  type: \"Wrapper\"\n  constraint: Constraint\n}\nexport const wrap = (constraint: Constraint): SyntaxWrapper => ({\n  type: \"Wrapper\",\n  constraint\n})\n\ninterface SyntaxConstant {\n  type: \"Constant\",\n  value: boolean\n}\nexport const syntaxTrue  = constant<Syntax>({ type: \"Constant\", value: true })\nexport const syntaxFalse = constant<Syntax>({ type: \"Constant\", value: false })\n\ninterface SyntaxConjunction {\n  type: \"Conjunction\"\n  syntax: RNEA.ReadonlyNonEmptyArray<Syntax>\n}\ninterface SyntaxDisjunction {\n  type: \"Disjunction\"\n  syntax: RNEA.ReadonlyNonEmptyArray<Syntax>\n}\ninterface SyntaxNegation {\n  type: \"Negation\"\n  syntax: Syntax\n}\ntype SyntaxConnective =\n  | SyntaxConjunction\n  | SyntaxDisjunction\n\nconst connective = ({ type, syntax }: SyntaxConnective): S.State<ExpandContext, E.Either<ExpandErrorReason, E.Either<Constraint, Syntax>>> =>\n  pipe(syntax,\n    RNEA.traverse(S.Applicative)(expandOnce),\n    S.map(flow(\n      RA.wilt(E.Applicative)(x => x),\n      E.map(flow(\n        separated.bimap(RNEA.fromReadonlyArray, RNEA.fromReadonlyArray),\n        x => these.fromOptions(x.left, x.right),\n        O.fold(\n          () => E.left(type === \"Conjunction\" ? constraintTrue() : constraintTrue()),\n          these.match(\n            constraints => E.left(constraints.length === 1 ? constraints[0] : { type, constraints }),\n            syntax => E.right(syntax.length === 1 ? syntax[0] : { type, syntax }),\n            (constraints, syntax): E.Either<never, Syntax> => E.right(\n              { type: type,\n                syntax: [wrap({ type, constraints }), { type, syntax }]\n              }))))))))\n\ntype ExpandResult = E.Either<ExpandError, ConstrainedBid>\ninterface ExpandContext {\n  bid: Bid\n  pathReversed: ReadonlyArray<Bid>\n  siblings: ReadonlyArray<SyntacticBid>\n  traversed: ReadonlyArray<ExpandResult>\n  labels: ReadonlyMap<string, Syntax>\n}\nconst zeroContext: ExpandContext = {\n  bid: \"Pass\",\n  pathReversed: [],\n  siblings: RA.empty,\n  traversed: RA.empty,\n  labels: RM.empty\n}\n\nconst contextL = Lens.fromProp<ExpandContext>()\nconst bidL = contextL('bid')\nconst pathReversedL = contextL('pathReversed')\nconst siblingsL = contextL('siblings')\nconst traversedL = contextL('traversed')\nconst labelsL = contextL('labels')\n\ninterface SyntaxOtherBid {\n  type: \"OtherBid\",\n  bid: ContractBid\n}\nconst eqSyntacticBid = pipe(eqBid, eq.contramap((sb: SyntacticBid) => sb.bid));\n\nconst otherBid = (bid: Bid) =>\n  pipe(\n    S.gets(flow(\n      siblingsL.get,\n      RA.findFirst(sb => eqBid.equals(sb.bid, bid)),\n      O.map(sb => sb.syntax))),\n    optionT.alt(S.Monad)(() => S.gets(flow(\n      labelsL.get,\n      RM.lookup(string.Eq)(serializedBidL.get(bid))))),\n    S.map(flow(\n      E.fromOption((): ExpandErrorReason => \"OtherBidNotFound\"),\n      E.map(E.right))))\n\ninterface SyntaxOtherwise {\n  type: \"Otherwise\"\n}\nconst otherwise = pipe(\n  S.gets(bidL.get),\n  S.chain(bid => S.gets(flow(\n    traversedL.get,\n    RA.rights,\n    RA.takeLeftWhile(cb => !eqBid.equals(cb.bid, bid)),\n    RA.map(cb => cb.constraint)))),\n  S.map(flow(\n    RNEA.fromReadonlyArray,\n    O.fold(\n      constraintTrue,\n      (constraints): Constraint => ({\n        type: \"Negation\", constraint: {\n          type: \"Conjunction\", constraints\n        }\n      })),\n    E.left,\n    E.right)))\n\nexport type Syntax =\n  | SyntaxWrapper\n  | SyntaxConstant\n  | SyntaxConjunction\n  | SyntaxDisjunction\n  | SyntaxDistribution\n  | SyntaxNegation\n  | SyntaxSuit\n  | SyntaxLabelDef\n  | SyntaxLabelRef\n  | SyntaxOtherBid\n  | SyntaxOtherwise\n\nconst wrapShapes =\n  RNEA.map((counts: AnyShape): Syntax =>\n    wrap({ type: \"AnyShape\", counts }))\n\nconst syntaxBalanced : Syntax = {\n  type: \"Disjunction\",\n  syntax: wrapShapes([\n    makeShape(4, 3, 3, 3),\n    makeShape(5, 3, 3, 2),\n    makeShape(4, 4, 3, 2)\n  ])\n}\n\nconst syntaxSemiBalanced : Syntax = {\n  type: \"Disjunction\",\n  syntax: wrapShapes([\n    makeShape(5, 4, 2, 2),\n    makeShape(6, 3, 2, 2)\n  ])\n}\n\nconst expandSpecifier = (specifier: SuitSpecifier): S.State<ExpandContext, E.Either<ExpandErrorReason, Suit>> => {\n  switch (specifier) {\n    case \"C\":\n    case \"D\":\n    case \"H\":\n    case \"S\":\n      return ofS(E.right(specifier))\n    case \"Wildcard\":\n      return pipe(\n        S.gets(flow(bidL.get)),\n        S.map(flow(\n          E.fromPredicate(isContractBid, (b): ExpandErrorReason => \"WildcardWithoutBid\"),\n          E.chain(b => pipe(b.strain, E.fromPredicate(isSuit, (b): ExpandErrorReason => \"WildcardInNTContext\"))))))\n    default:\n      return ofS(E.left(\"NotImplemented\"));\n  }\n}\n\nexport type ExpandErrorReason =\n  | \"NotImplemented\"\n  | \"OtherBidNotFound\"\n  | \"LabelNotFound\"\n  | \"WildcardWithoutBid\"\n  | \"WildcardInNTContext\"\n\nexport interface ExpandError {\n  reason: ExpandErrorReason\n  syntax: Syntax\n  path: ReadonlyArray<Bid>\n}\n\nexport const pure = <A>(x: A) => pipe(x, E.right, E.right, ofS)\n\nconst expandOnce = (s: Syntax): S.State<ExpandContext, E.Either<ExpandErrorReason, E.Either<Constraint, Syntax>>> => {\n  switch (s.type) {\n    case \"Wrapper\":\n      return ofS<E.Either<ExpandErrorReason, E.Either<Constraint, Syntax>>>(E.right(E.left(s.constraint)))\n    case \"Constant\":\n      return pure(wrap({ type: \"Constant\", value: s.value }))\n    case \"Conjunction\":\n    case \"Disjunction\":\n      return connective(s)\n    case \"Negation\": \n      return pipe(s.syntax, expandOnce, S.map(E.map(flow(\n        E.bimap(\n          (constraint) => ({ type: \"Negation\", constraint }),\n          (syntax) => ({ type: \"Negation\", syntax }))))))\n    case \"OtherBid\":\n      return otherBid(s.bid)\n    case \"Otherwise\":\n      return otherwise\n    case \"LabelDef\":\n      return labelDef(s)\n    case \"LabelRef\":\n      return labelRef(s)\n    case \"Balanced\":\n      return pure(syntaxBalanced)\n    case \"SemiBalanced\":\n      return pure({ type: \"Disjunction\", syntax: [syntaxBalanced, syntaxSemiBalanced] })\n    case \"Unbalanced\":\n      return pure({ type: \"Negation\", syntax: {\n        type: \"Disjunction\", syntax: [syntaxBalanced, syntaxSemiBalanced]\n      }})\n    case \"SuitRange\":\n    case \"SuitHonors\":\n    case \"SuitPrimary\":\n    case \"SuitSecondary\":\n    case \"SuitTop\":\n    case \"SetTrump\":\n      return pipe(s.suit,\n        expandSpecifier,\n        eitherT.map(S.Functor)(suit => E.left({ ...s, suit })))\n    case \"SuitComparison\":\n      return pipe([s.left, s.right],\n        S.traverseArray(expandSpecifier),\n        S.map(E.sequenceArray),\n        eitherT.map(S.Functor)(suits => E.left({ ...s, left: suits[0], right: suits[1] })))\n          \n    default:\n      // return ofS(E.right(E.right(syntaxFalse())))\n      return assertUnreachable(s)\n  }\n}\n\nconst expand = (syntax: Syntax) : S.State<ExpandContext, E.Either<ExpandErrorReason, Constraint>> =>\n  pipe(\n    syntax,\n    expandOnce,\n    S.chain(flow(\n      E.mapLeft(E.left),\n      E.chain(E.mapLeft(c => E.right(c))),\n      E.fold(ofS, expand))))\n\nexport type SyntacticBid = {\n  bid: Bid\n  syntax: Syntax\n}\n\nconst modifyContext = <T>(...modifiers: ReadonlyArray<(c: T) => T>) =>\n  pipe(modifiers, S.traverseArray(S.modify), S.map(constVoid))\n\nconst expandBid = \n  T.map(({ bid, syntax, siblings }: SyntacticBid & { siblings : ReadonlyArray<SyntacticBid> }) =>\n    pipe(\n      modifyContext(\n        bidL.set(bid),\n        pathReversedL.modify(RA.prepend(bid)),\n        siblingsL.set(siblings),\n        labelsL.modify(RM.upsertAt(string.Eq)(serializedBidL.get(bid), syntax)),\n      ),\n      S.apSecond(expand(syntax)),\n      S.chain(e => pipe(\n        S.gets(pathReversedL.get),\n        S.map(path => pipe(e, E.mapLeft((reason): ExpandError => ({ reason, path: RA.reverse(path), syntax })))))),\n      S.map(E.map((constraint): ConstrainedBid => ({ bid, constraint })))))\n\nconst traversePeers =\n  S.chainFirst((t: T.Tree<ExpandResult>) =>\n    modifyContext(\n      traversedL.modify(RA.append(t.value)),\n      pathReversedL.modify(flow(RA.tail, O.getOrElseW(() => RA.empty)))))\n\ntype ExpandedBid = S.State<ExpandContext, ExpandResult>\nconst expandPeers =\n  T.fold((expandedBid: ExpandedBid, expandedChildForest: ReadonlyArray<S.State<ExpandContext, T.Tree<ExpandResult>>>) => \n    pipe(expandedBid,\n      S.bindTo('result'),\n      S.apS('context', S.get()),\n      S.map(({ result, context }) =>\n        T.make(result,\n          pipe(expandedChildForest,\n            S.traverseArray(traversePeers),\n            S.evaluate(context),\n            RA.toArray)))))\n\nexport const expandForest = (forest: Forest<SyntacticBid>) =>\n  pipe(forest,\n    extendForestWithSiblings(eqSyntacticBid),\n    RA.map(flow(expandBid, expandPeers)),\n    S.traverseArray(traversePeers),\n    S.evaluate(zeroContext),\n    collectErrors)","/* AutoGenerated Code, changes may be overwritten\n* INPUT GRAMMAR:\n* Start := hand=Hand $\n* Hand := S=Suit '\\.' H=Suit '\\.' D=Suit '\\.' C=Suit\n* Suit := cards=Card*\n* Card := c='[AKQJT2-9]'\n*   .rank = number {\n*     const rankStrings = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A']\n*     return rankStrings.indexOf(c) + 2\n*   }\n* // ValidChar := '[AKQJT2-9.]{16}' // 13 + 3 dots\n*/\ntype Nullable<T> = T | null;\ntype $$RuleType<T> = () => Nullable<T>;\nexport interface ASTNodeIntf {\n    kind: ASTKinds;\n}\nexport enum ASTKinds {\n    Start = \"Start\",\n    Hand = \"Hand\",\n    Suit = \"Suit\",\n    Card = \"Card\",\n    $EOF = \"$EOF\",\n}\nexport interface Start {\n    kind: ASTKinds.Start;\n    hand: Hand;\n}\nexport interface Hand {\n    kind: ASTKinds.Hand;\n    S: Suit;\n    H: Suit;\n    D: Suit;\n    C: Suit;\n}\nexport interface Suit {\n    kind: ASTKinds.Suit;\n    cards: Card[];\n}\nexport class Card {\n    public kind: ASTKinds.Card = ASTKinds.Card;\n    public c: string;\n    public rank: number;\n    constructor(c: string){\n        this.c = c;\n        this.rank = ((): number => {\n        const rankStrings = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A']\n    return rankStrings.indexOf(c) + 2\n        })();\n    }\n}\nexport class Parser {\n    private readonly input: string;\n    private pos: PosInfo;\n    private negating: boolean = false;\n    private memoSafe: boolean = true;\n    constructor(input: string) {\n        this.pos = {overallPos: 0, line: 1, offset: 0};\n        this.input = input;\n    }\n    public reset(pos: PosInfo) {\n        this.pos = pos;\n    }\n    public finished(): boolean {\n        return this.pos.overallPos === this.input.length;\n    }\n    public clearMemos(): void {\n    }\n    public matchStart($$dpth: number, $$cr?: ErrorTracker): Nullable<Start> {\n        return this.run<Start>($$dpth,\n            () => {\n                let $scope$hand: Nullable<Hand>;\n                let $$res: Nullable<Start> = null;\n                if (true\n                    && ($scope$hand = this.matchHand($$dpth + 1, $$cr)) !== null\n                    && this.match$EOF($$cr) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Start, hand: $scope$hand};\n                }\n                return $$res;\n            });\n    }\n    public matchHand($$dpth: number, $$cr?: ErrorTracker): Nullable<Hand> {\n        return this.run<Hand>($$dpth,\n            () => {\n                let $scope$S: Nullable<Suit>;\n                let $scope$H: Nullable<Suit>;\n                let $scope$D: Nullable<Suit>;\n                let $scope$C: Nullable<Suit>;\n                let $$res: Nullable<Hand> = null;\n                if (true\n                    && ($scope$S = this.matchSuit($$dpth + 1, $$cr)) !== null\n                    && this.regexAccept(String.raw`(?:\\.)`, $$dpth + 1, $$cr) !== null\n                    && ($scope$H = this.matchSuit($$dpth + 1, $$cr)) !== null\n                    && this.regexAccept(String.raw`(?:\\.)`, $$dpth + 1, $$cr) !== null\n                    && ($scope$D = this.matchSuit($$dpth + 1, $$cr)) !== null\n                    && this.regexAccept(String.raw`(?:\\.)`, $$dpth + 1, $$cr) !== null\n                    && ($scope$C = this.matchSuit($$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Hand, S: $scope$S, H: $scope$H, D: $scope$D, C: $scope$C};\n                }\n                return $$res;\n            });\n    }\n    public matchSuit($$dpth: number, $$cr?: ErrorTracker): Nullable<Suit> {\n        return this.run<Suit>($$dpth,\n            () => {\n                let $scope$cards: Nullable<Card[]>;\n                let $$res: Nullable<Suit> = null;\n                if (true\n                    && ($scope$cards = this.loop<Card>(() => this.matchCard($$dpth + 1, $$cr), true)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Suit, cards: $scope$cards};\n                }\n                return $$res;\n            });\n    }\n    public matchCard($$dpth: number, $$cr?: ErrorTracker): Nullable<Card> {\n        return this.run<Card>($$dpth,\n            () => {\n                let $scope$c: Nullable<string>;\n                let $$res: Nullable<Card> = null;\n                if (true\n                    && ($scope$c = this.regexAccept(String.raw`(?:[AKQJT2-9])`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = new Card($scope$c);\n                }\n                return $$res;\n            });\n    }\n    public test(): boolean {\n        const mrk = this.mark();\n        const res = this.matchStart(0);\n        const ans = res !== null;\n        this.reset(mrk);\n        return ans;\n    }\n    public parse(): ParseResult {\n        const mrk = this.mark();\n        const res = this.matchStart(0);\n        if (res)\n            return {ast: res, errs: []};\n        this.reset(mrk);\n        const rec = new ErrorTracker();\n        this.clearMemos();\n        this.matchStart(0, rec);\n        const err = rec.getErr()\n        return {ast: res, errs: err !== null ? [err] : []}\n    }\n    public mark(): PosInfo {\n        return this.pos;\n    }\n    private loop<T>(func: $$RuleType<T>, star: boolean = false): Nullable<T[]> {\n        const mrk = this.mark();\n        const res: T[] = [];\n        for (;;) {\n            const t = func();\n            if (t === null) {\n                break;\n            }\n            res.push(t);\n        }\n        if (star || res.length > 0) {\n            return res;\n        }\n        this.reset(mrk);\n        return null;\n    }\n    private run<T>($$dpth: number, fn: $$RuleType<T>): Nullable<T> {\n        const mrk = this.mark();\n        const res = fn()\n        if (res !== null)\n            return res;\n        this.reset(mrk);\n        return null;\n    }\n    private choice<T>(fns: Array<$$RuleType<T>>): Nullable<T> {\n        for (const f of fns) {\n            const res = f();\n            if (res !== null) {\n                return res;\n            }\n        }\n        return null;\n    }\n    private regexAccept(match: string, dpth: number, cr?: ErrorTracker): Nullable<string> {\n        return this.run<string>(dpth,\n            () => {\n                const reg = new RegExp(match, \"y\");\n                const mrk = this.mark();\n                reg.lastIndex = mrk.overallPos;\n                const res = this.tryConsume(reg);\n                if(cr) {\n                    cr.record(mrk, res, {\n                        kind: \"RegexMatch\",\n                        // We substring from 3 to len - 1 to strip off the\n                        // non-capture group syntax added as a WebKit workaround\n                        literal: match.substring(3, match.length - 1),\n                        negated: this.negating,\n                    });\n                }\n                return res;\n            });\n    }\n    private tryConsume(reg: RegExp): Nullable<string> {\n        const res = reg.exec(this.input);\n        if (res) {\n            let lineJmp = 0;\n            let lind = -1;\n            for (let i = 0; i < res[0].length; ++i) {\n                if (res[0][i] === \"\\n\") {\n                    ++lineJmp;\n                    lind = i;\n                }\n            }\n            this.pos = {\n                overallPos: reg.lastIndex,\n                line: this.pos.line + lineJmp,\n                offset: lind === -1 ? this.pos.offset + res[0].length : (res[0].length - lind - 1)\n            };\n            return res[0];\n        }\n        return null;\n    }\n    private noConsume<T>(fn: $$RuleType<T>): Nullable<T> {\n        const mrk = this.mark();\n        const res = fn();\n        this.reset(mrk);\n        return res;\n    }\n    private negate<T>(fn: $$RuleType<T>): Nullable<boolean> {\n        const mrk = this.mark();\n        const oneg = this.negating;\n        this.negating = !oneg;\n        const res = fn();\n        this.negating = oneg;\n        this.reset(mrk);\n        return res === null ? true : null;\n    }\n    private memoise<K>(rule: $$RuleType<K>, memo: Map<number, [Nullable<K>, PosInfo]>): Nullable<K> {\n        const $scope$pos = this.mark();\n        const $scope$memoRes = memo.get($scope$pos.overallPos);\n        if(this.memoSafe && $scope$memoRes !== undefined) {\n        this.reset($scope$memoRes[1]);\n        return $scope$memoRes[0];\n        }\n        const $scope$result = rule();\n        if(this.memoSafe)\n        memo.set($scope$pos.overallPos, [$scope$result, this.mark()]);\n        return $scope$result;\n    }\n    private match$EOF(et?: ErrorTracker): Nullable<{kind: ASTKinds.$EOF}> {\n        const res: {kind: ASTKinds.$EOF} | null = this.finished() ? { kind: ASTKinds.$EOF } : null;\n        if(et)\n            et.record(this.mark(), res, { kind: \"EOF\", negated: this.negating });\n        return res;\n    }\n}\nexport function parse(s: string): ParseResult {\n    const p = new Parser(s);\n    return p.parse();\n}\nexport interface ParseResult {\n    ast: Nullable<Start>;\n    errs: SyntaxErr[];\n}\nexport interface PosInfo {\n    readonly overallPos: number;\n    readonly line: number;\n    readonly offset: number;\n}\nexport interface RegexMatch {\n    readonly kind: \"RegexMatch\";\n    readonly negated: boolean;\n    readonly literal: string;\n}\nexport type EOFMatch = { kind: \"EOF\"; negated: boolean };\nexport type MatchAttempt = RegexMatch | EOFMatch;\nexport class SyntaxErr {\n    public pos: PosInfo;\n    public expmatches: MatchAttempt[];\n    constructor(pos: PosInfo, expmatches: MatchAttempt[]) {\n        this.pos = pos;\n        this.expmatches = [...expmatches];\n    }\n    public toString(): string {\n        return `Syntax Error at line ${this.pos.line}:${this.pos.offset}. Expected one of ${this.expmatches.map(x => x.kind === \"EOF\" ? \" EOF\" : ` ${x.negated ? 'not ': ''}'${x.literal}'`)}`;\n    }\n}\nclass ErrorTracker {\n    private mxpos: PosInfo = {overallPos: -1, line: -1, offset: -1};\n    private regexset: Set<string> = new Set();\n    private pmatches: MatchAttempt[] = [];\n    public record(pos: PosInfo, result: any, att: MatchAttempt) {\n        if ((result === null) === att.negated)\n            return;\n        if (pos.overallPos > this.mxpos.overallPos) {\n            this.mxpos = pos;\n            this.pmatches = [];\n            this.regexset.clear()\n        }\n        if (this.mxpos.overallPos === pos.overallPos) {\n            if(att.kind === \"RegexMatch\") {\n                if(!this.regexset.has(att.literal))\n                    this.pmatches.push(att);\n                this.regexset.add(att.literal);\n            } else {\n                this.pmatches.push(att);\n            }\n        }\n    }\n    public getErr(): SyntaxErr | null {\n        if (this.mxpos.overallPos !== -1)\n            return new SyntaxErr(this.mxpos, this.pmatches);\n        return null;\n    }\n}","import { either, eitherT, option, readonlyArray, readonlyNonEmptyArray, readonlyRecord, string } from 'fp-ts';\nimport { constant, flow, identity, pipe } from 'fp-ts/lib/function';\n\nimport { assertUnreachable } from '../lib';\nimport { Bid, Strain } from '../model/bridge';\nimport { rankFromString, ranks, Suit } from '../model/deck';\nimport { zeroSpecificShape } from '../model/evaluation';\nimport { SuitComparisonOperator } from '../model/system/core';\nimport { SuitSpecifier, SyntacticBid, Syntax, syntaxFalse, syntaxTrue, wrap } from '../model/system/expander';\nimport * as AST from '../parse/bid.peg.g';\n\nconst getConnectiveItems = (items: ReadonlyArray<AST.Constraint>) =>\n  pipe(items,\n    readonlyNonEmptyArray.fromReadonlyArray,\n    option.map(flow(\n      readonlyNonEmptyArray.map(constraint),\n      either.fromPredicate(i => i.length > 1, i => i[0]))))\n\nconst connective = (type: \"Conjunction\" | \"Disjunction\") =>\n  flow(getConnectiveItems,\n    eitherT.match(option.Functor)(identity, syntax => ({\n      type,\n      syntax\n    }) as const),\n    option.getOrElse(type === \"Conjunction\" ? syntaxTrue : syntaxFalse))\n\nconst suit = (s: AST.Suit) : Suit =>\n  s.kind === AST.ASTKinds.Club    ? 'C' :\n  s.kind === AST.ASTKinds.Diamond ? 'D' :\n  s.kind === AST.ASTKinds.Heart   ? 'H' :\n                                    'S'\n\nconst strain = (s: AST.Strain) : Strain =>\n  s.kind === AST.ASTKinds.Notrump ? 'N' :\n  suit(s)\n\nconst suitSpecifier = (s: AST.SuitSpecifier) : SuitSpecifier =>\n  s.kind === AST.ASTKinds.Major ? \"Major\" :\n  s.kind === AST.ASTKinds.Minor ? \"Minor\" :\n  s.kind === AST.ASTKinds.OtherMajor ? \"OtherMajor\" :\n  s.kind === AST.ASTKinds.OtherMinor ? \"OtherMinor\" :\n  s.kind === AST.ASTKinds.Wildcard ? \"Wildcard\" :\n  suit(s)\n\nconst bindValueQualifier = (s: AST.BoundQualifier, value: number) => (type: 'min' | 'max') =>\n  pipe(value,\n    option.of,\n    option.filter(_ =>\n      s.kind === AST.ASTKinds.Equals\n      || (type === 'min' && s.kind === AST.ASTKinds.Plus)\n      || (type === 'max' && s.kind === AST.ASTKinds.Minus)))\n\nconst constraintList = (c: AST.ConstraintList) : Syntax =>\n  pipe(c,\n    readonlyArray.map(c => c.constraint),\n    connective(\"Conjunction\"))\n\nexport const constraint = (c: AST.Constraint) : Syntax => {\n  switch (c.kind) {\n\n    case AST.ASTKinds.True:\n      return syntaxTrue()\n\n    case AST.ASTKinds.False:\n      return syntaxFalse()\n\n    case AST.ASTKinds.And:\n      return pipe(\n        c.constraints,\n        readonlyArray.map(c => c.constraint),\n        connective(\"Conjunction\"))\n\n    case AST.ASTKinds.Otherwise:\n      return { type: \"Otherwise\" }\n\n    case AST.ASTKinds.Or:\n      const flatten = (head: AST.Constraint, ...items: ReadonlyArray<AST.Constraint>) : readonlyNonEmptyArray.ReadonlyNonEmptyArray<AST.Constraint> =>\n        head.kind === AST.ASTKinds.Or\n        ? flatten(head.left, head.right, ...items)\n        : pipe(items,\n            readonlyNonEmptyArray.fromReadonlyArray,\n            option.fold(\n              () => [head],\n              items => [head, ...flatten(items[0], ...items.slice(1))]))\n      return pipe(\n        flatten(c.left, c.right),\n        connective(\"Disjunction\"))\n\n    case AST.ASTKinds.Not:\n      return {\n        type: \"Negation\",\n        syntax: constraint(c.constraint)\n      }\n\n    case AST.ASTKinds.OtherBid:\n      return {\n        type: \"OtherBid\",\n        bid: {\n          level: c.level.value,\n          strain: strain(c.strain)\n        }\n      }\n\n    case AST.ASTKinds.PointRange:\n      return wrap({\n        type: \"PointRange\",\n        min: c.lower.value,\n        max: c.upper.value\n      })\n\n    case AST.ASTKinds.PointBound:\n      return wrap({\n        type: \"PointRange\",\n        min: pipe(bindValueQualifier(c.qualifier, c.value.value)('min'), option.getOrElse(constant(0))),\n        max: pipe(bindValueQualifier(c.qualifier, c.value.value)('max'), option.getOrElse(constant(37))),\n      })\n\n    case AST.ASTKinds.SuitRange:\n      return {\n        type: \"SuitRange\",\n        min: c.lower.value,\n        max: c.upper.value,\n        suit: suitSpecifier(c.suit)\n      }\n\n    case AST.ASTKinds.SuitComparison:\n      return {\n        type: \"SuitComparison\",\n        op: c.op.v as SuitComparisonOperator,\n        left: suitSpecifier(c.left),\n        right: suitSpecifier(c.right)\n      }\n\n    case AST.ASTKinds.Primary:\n    case AST.ASTKinds.Secondary:\n      return {\n        type: `Suit${c.kind}`,\n        suit: suitSpecifier(c.suit)\n      }\n\n    case AST.ASTKinds.SetTrump:\n      return {\n        type: \"SetTrump\",\n        suit: suitSpecifier(c.suit)\n      }\n\n    case AST.ASTKinds.SuitBound:\n      return {\n        type: \"SuitRange\",\n        min: pipe(bindValueQualifier(c.qualifier, c.value.value)('min'), option.getOrElse(constant(0))),\n        max: pipe(bindValueQualifier(c.qualifier, c.value.value)('max'), option.getOrElse(constant(13))),\n        suit: suitSpecifier(c.suit)\n      }\n\n    case AST.ASTKinds.SuitHonors:\n      return {\n        type: \"SuitHonors\",\n        suit: suitSpecifier(c.suit),\n        honors: pipe(c.honors,\n          readonlyArray.fromArray,\n          readonlyArray.traverse(option.Applicative)(flow(h => h.v, rankFromString)),\n          option.getOrElseW(() => []))\n      }\n\n    case AST.ASTKinds.SuitTop:\n      return {\n        type: \"SuitTop\",\n        suit: suitSpecifier(c.suit),\n        count: parseInt(c.x),\n        minRank: ranks[ranks.length - parseInt(c.y)]\n      }\n\n    case AST.ASTKinds.AnyShape:\n      return wrap({\n        type: \"AnyShape\",\n        counts: pipe(c.v, string.split(''), readonlyArray.map(parseInt)) as [number, number, number, number]\n      })\n\n    case AST.ASTKinds.SpecificShape:\n      return wrap({\n        type: \"SpecificShape\",\n        suits: pipe(zeroSpecificShape, readonlyRecord.mapWithIndex((s, _) => c[s].value))\n      })\n\n    // case AST.ASTKinds.Relay:\n    //   return wrap({\n    //     type: \"Relay\",\n    //     bid: {\n    //       level: c.bid.level.value,\n    //       strain: strain(c.bid.strain)\n    //     }\n    //   })\n\n    case AST.ASTKinds.LabelDef:\n      return {\n        type: \"LabelDef\",\n        name: c.label.v,\n        definition: constraintList(c.constraints)\n      }\n\n    case AST.ASTKinds.LabelRef:\n      return {\n        type: \"LabelRef\",\n        name: c.label.v\n      }\n\n    case AST.ASTKinds.Balanced:\n    case AST.ASTKinds.SemiBalanced:\n    case AST.ASTKinds.Unbalanced:\n      return { type: c.kind }\n    \n    default:\n      return assertUnreachable(c)\n  }\n}\n\nexport const bid = (bid: AST.Bid): Bid => {\n  switch (bid.kind) {\n    case AST.ASTKinds.ContractBid:\n      return {\n        level: bid.level.value,\n        strain: strain(bid.specifier as AST.Strain),\n      }\n    case AST.ASTKinds.Pass:\n      return \"Pass\"\n    default:\n      return assertUnreachable(bid)\n  }\n}\n\nexport const constrainedBid = (bidSpec: AST.BidSpec) : SyntacticBid => ({\n  bid: bid(bidSpec.bid),\n  syntax: pipe(\n    bidSpec.constraints?.constraints,\n    option.fromNullable,\n    option.fold(syntaxFalse, constraintList))\n})\n\nexport const parseBid = AST.parse\n","import { ord, readonlyArray, readonlyNonEmptyArray, readonlyRecord, readonlySet, readonlyTuple, string } from 'fp-ts';\nimport { Right } from 'fp-ts/lib/Either';\nimport { flow, identity, pipe } from 'fp-ts/lib/function';\nimport * as e from 'io-ts/Encoder';\n\nimport { Board, directions, ordDirection } from '../model/bridge';\nimport { Card, eqCard, getOrdGroupedHand, groupHandBySuits, Hand, ordRankDescending, Rank, RankC, Suit, suits } from '../model/deck';\nimport * as AST from '../parse/hand.peg.g';\n\nconst suit = (hand: AST.Hand) => (suit: Suit) : ReadonlyArray<Card> =>\n  pipe(hand[suit].cards,\n    readonlyArray.map(card => ({ suit, rank: (RankC.decode(card.rank) as Right<Rank>).right })))\n\nexport const hand = (hand: AST.Hand) : Hand =>\n  pipe(suits,\n    readonlyArray.map(suit(hand)),\n    readonlyArray.flatten,\n    readonlySet.fromReadonlyArray(eqCard))\n\nexport const parseHand = AST.parse\n\n// PBN hand notation\nexport const handE : e.Encoder<string, Hand> = {\n  encode: flow(\n    groupHandBySuits,\n    readonlyRecord.toReadonlyArray,\n    readonlyArray.sort(getOrdGroupedHand<ReadonlyArray<Rank>>()),\n    readonlyArray.map(flow(\n      readonlyTuple.snd,\n      readonlyArray.sort(ordRankDescending),\n      readonlyArray.reduce(\"\", (cur, rank) => cur + RankC.encode(rank)))),\n    readonlyArray.intersperse(\".\"),\n    readonlyArray.foldMap(string.Monoid)(identity))\n}\n\n// PBN board notation\nexport const boardE : e.Encoder<string, Board> = {\n  encode: ({ dealer, deal }) => pipe(deal,\n    readonlyRecord.map(handE.encode),\n    readonlyRecord.toReadonlyArray,\n    readonlyArray.sort(ord.contramap(readonlyTuple.fst)(ordDirection)),\n    readonlyArray.rotate(directions.indexOf(dealer)),\n    readonlyArray.map(readonlyTuple.snd),\n    readonlyArray.intersperse(\" \"),\n    readonlyArray.prepend(dealer + \":\"),\n    readonlyNonEmptyArray.concatAll(string.Semigroup))\n}","import { either, option, readonlyArray, readonlyNonEmptyArray as RNEA } from 'fp-ts';\nimport { constant, flow, pipe } from 'fp-ts/lib/function';\nimport * as d from 'io-ts/Decoder';\nimport * as DE from 'io-ts/lib/DecodeError';\nimport * as FS from 'io-ts/lib/FreeSemigroup';\n\nimport { constrainedBid, parseBid } from './bid';\nimport { hand, parseHand } from './hand';\n\nexport interface PosInfo {\n  readonly overallPos: number;\n  readonly line: number;\n  readonly offset: number;\n}\nexport interface RegexMatch {\n  readonly kind: \"RegexMatch\";\n  readonly negated: boolean;\n  readonly literal: string;\n}\nexport type EOFMatch = { kind: \"EOF\"; negated: boolean };\nexport type MatchAttempt = RegexMatch | EOFMatch;\ninterface SyntaxErr {\n  pos: PosInfo;\n  expmatches: MatchAttempt[];\n  toString(): string\n}\ninterface ParseResult<T> {\n  ast: T | null;\n  errs: SyntaxErr[];\n}\n// above is generalized from generated tsPEG code\n\nconst convertErrors = (errs: ReadonlyArray<readonly [string, SyntaxErr]>): d.DecodeError =>\n  pipe(errs,\n    RNEA.fromReadonlyArray,\n    option.fold(constant(d.error(null, \"No syntax errors reported\")),\n      RNEA.foldMap(FS.getSemigroup<DE.DecodeError<string>>())(([actual, err]) =>\n        FS.of(DE.key(actual, \"required\",\n          FS.of(DE.index(err.pos.offset, \"required\",\n            pipe(err.expmatches,\n              RNEA.fromReadonlyArray,\n              option.fold(constant(FS.of(DE.leaf(actual, \"\"))),\n                RNEA.foldMapWithIndex(FS.getSemigroup<DE.DecodeError<string>>())((i, x)=>\n                  FS.of(DE.leaf(actual.substring(err.pos.offset), x.kind === \"EOF\" ? \"EOF\" : `${x.negated ? 'not ': ''}'${x.literal}'`))))))))))))\n\nconst parseResultToEither = <T>(result: ParseResult<T>) =>\n  either.fromNullable(result.errs)(result.ast)\n\nconst getDecoder = <T>(parser: (input: string) => ParseResult<T>) : d.Decoder<string, T> =>\n  pipe(\n    d.string,\n    d.parse(input => pipe(input,\n      parser,\n      parseResultToEither,\n      either.mapLeft(flow(\n        readonlyArray.map(x => [input, x] as const),\n        convertErrors)))))\n\nexport const decodeBid = flow(\n  getDecoder(parseBid).decode,\n  either.map(x => constrainedBid(x.spec)))\n\nexport const decodeHand = flow(\n  getDecoder(parseHand).decode,\n  either.map(x => hand(x.hand)))","import { either, option, predicate, readonlyArray, readonlyNonEmptyArray, readonlyRecord, readonlySet, readonlyTuple, separated } from 'fp-ts';\nimport { observable, observableEither } from 'fp-ts-rxjs';\nimport { tailRec } from 'fp-ts/lib/ChainRec';\nimport { constFalse, constTrue, flow, pipe } from 'fp-ts/lib/function';\nimport { castDraft } from 'immer';\nimport { WritableDraft } from 'immer/dist/internal';\nimport memoize from 'proxy-memoize';\nimport { O } from 'ts-toolbelt';\n\nimport { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';\n\nimport { Board, deal } from '../model/bridge';\nimport { eqCard, Hand, newDeck, ordCardDescending } from '../model/deck';\nimport { getHcp } from '../model/evaluation';\nimport { DecodedHand, DecodedSerializedHand, decodedSerializedHandL, serializedDealL, SerializedHand, serializedHandL } from '../model/serialization';\nimport { Path, Paths } from '../model/system';\nimport { ConstrainedBid } from '../model/system/core';\nimport { satisfiesPath } from '../model/system/satisfaction';\nimport { decodeHand } from '../parse';\nimport { observeSolutions } from '../workers';\nimport { DoubleDummyResult } from '../workers/dds.worker';\n\nconst name = 'selection'\n\ninterface State {\n  selectedBlockKey: option.Option<string>\n  opener?: DecodedSerializedHand\n  responder?: DecodedSerializedHand\n  result?: DoubleDummyResult\n}\nexport type AuctionPositionType = O.SelectKeys<State, DecodedHand>\n\nconst initialState : State = {\n  selectedBlockKey: option.none\n}\n\ninterface Hands {\n  opener: SerializedHand\n  responder: SerializedHand\n}\n\nconst setHands = (state: WritableDraft<State>) => (hands: readonly [Hand, Hand]) => {\n  const [opener, responder] = hands\n  state.opener = pipe(opener, either.right, decodedSerializedHandL.get, castDraft)\n  state.responder = pipe(responder, either.right, decodedSerializedHandL.get, castDraft)\n}\n\nconst genBoardFromHands = (opener: Hand, responder: Hand) =>\n  pipe(newDeck(),\n    readonlyArray.difference(eqCard)(pipe(opener, readonlySet.toReadonlyArray(ordCardDescending))),\n    readonlyArray.difference(eqCard)(pipe(responder, readonlySet.toReadonlyArray(ordCardDescending))),\n    readonlyArray.chunksOf(13),\n    readonlyArray.map(readonlySet.fromReadonlyArray(eqCard)),\n    ([l, r]) : Board => ({\n      dealer: 'N',\n      deal: {\n        N: opener,\n        S: responder,\n        E: l,\n        W: r\n      }\n    }))\n\nconst getResult = createAsyncThunk<DoubleDummyResult, Hands, { rejectValue: string }>('abc', ({ opener, responder }, { rejectWithValue }) =>\n  pipe(\n    genBoardFromHands(serializedHandL.reverseGet(opener), serializedHandL.reverseGet(responder)).deal,\n    serializedDealL.get,\n    readonlyArray.of,\n    observeSolutions,\n    observableEither.map(flow(\n      readonlyRecord.toReadonlyArray,\n      readonlyArray.map(readonlyTuple.snd),\n      a => a[0])),\n    observable.map(either.getOrElseW(rejectWithValue)),\n    observable.toTask)\n  ())\n\nconst genUntilCondition = (limit: option.Option<number>) => (condition: predicate.Predicate<readonly [Hand, Hand]>) =>\n  tailRec(limit, l => {\n    if (pipe(l, option.fold(constFalse, i => i === 0))) {\n      return either.right(option.none)\n    } else {\n      const d = deal(newDeck())\n      const hands = [d.N, d.S] as const\n      const result = condition(hands)\n      return result\n        ? either.right(option.some(hands))\n        : either.left(pipe(l, option.map(i => i - 1)))\n    }\n  })\n\nconst genMatchingOf = (length: predicate.Predicate<number>) => (paths: Paths<ConstrainedBid>) =>\n  genUntilCondition(option.some(10000))(hands =>\n    pipe(paths,\n      readonlyArray.partition(satisfiesPath(...hands)),\n      separated.right,\n      x => length(x.length)))\n\nconst slice = createSlice({\n  name,\n  initialState,\n  reducers: {\n    setSelectedBlockKey: (state, action: PayloadAction<option.Option<string>>) => {\n      state.selectedBlockKey = action.payload\n    },\n    setHand: {\n      reducer: (state, action: PayloadAction<string, string, AuctionPositionType>) => {\n        state[action.meta] = pipe(action.payload, decodeHand, decodedSerializedHandL.get, castDraft)\n      },\n      prepare: (payload, meta) => ({ payload, meta })\n    },\n    genOnce: (state) => {\n      pipe(\n        genUntilCondition(option.none)(constTrue),\n        option.map(setHands(state)))\n    },\n    getHandsMatchingPath: (state, action: PayloadAction<Path<ConstrainedBid>>) => {\n      pipe(\n        genUntilCondition(option.some(10000))(hands =>\n          satisfiesPath(...hands)(action.payload)),\n        option.map(setHands(state)))\n    },\n    genHandsNotMatchingAnyOf: {\n      reducer: (state, action: PayloadAction<readonlyNonEmptyArray.ReadonlyNonEmptyArray<Path<ConstrainedBid>>, string, number>) => {\n        pipe(\n          genUntilCondition(option.some(10000))(hands =>\n            getHcp(hands[0]) >= action.meta\n            && pipe(action.payload, readonlyArray.every(predicate.not(satisfiesPath(...hands))))),\n          option.map(setHands(state)))\n      },\n      prepare: (payload: readonlyNonEmptyArray.ReadonlyNonEmptyArray<Path<ConstrainedBid>>, openerMinHcp: number) =>\n        ({ payload, meta: openerMinHcp })\n    },\n    genHandsMatchingExactlyOneOf: (state, action: PayloadAction<readonlyNonEmptyArray.ReadonlyNonEmptyArray<Path<ConstrainedBid>>>) => {\n      pipe(\n        genMatchingOf(l => l === 1)(action.payload),\n        option.map(setHands(state)))\n    },\n    genHandsMatchingMoreThanOneOf: (state, action: PayloadAction<readonlyNonEmptyArray.ReadonlyNonEmptyArray<Path<ConstrainedBid>>>) => {\n      pipe(\n        genMatchingOf(l => l > 1)(action.payload),\n        option.map(setHands(state)))\n    }\n  },\n  extraReducers: builder => builder\n    .addCase(getResult.fulfilled, (state, action) => {\n      state.result = pipe(action.payload, castDraft)\n    })\n  })\n\n\nexport const { setSelectedBlockKey, setHand, genOnce, getHandsMatchingPath, genHandsNotMatchingAnyOf, genHandsMatchingExactlyOneOf, genHandsMatchingMoreThanOneOf } = slice.actions\nexport { getResult };\n\nexport default slice.reducer\n\nexport const selectBlockKey = memoize((state: State) =>\n  pipe(state.selectedBlockKey,\n    option.toNullable))\n\nexport const selectHand = memoize(({ state, type } : {state: State, type: AuctionPositionType}) : option.Option<Hand> =>\n  pipe(state[type],\n    option.fromNullable,\n    option.chain(flow(decodedSerializedHandL.reverseGet, option.fromEither))))","import { readonlyArray } from 'fp-ts';\nimport { pipe } from 'fp-ts/lib/function';\n\nimport { createSlice, PayloadAction } from '@reduxjs/toolkit';\n\ninterface State {\n  implicitPass: boolean\n  generateCount: number\n}\n\nconst initialState: State = {\n  implicitPass: false,\n  generateCount: 30000\n}\n\nconst name = 'settings'\nconst slice = createSlice({\n  name,\n  initialState,\n  reducers: {\n    setInitial: (state, action: PayloadAction<SettingsState>) => {\n      pipe(Object.keys(action.payload) as ReadonlyArray<keyof State>,\n        readonlyArray.map(p => (state as any)[p] = action.payload[p] as any))\n    },\n    setProperty: {\n      reducer: (state, action: PayloadAction<any, string, keyof State>) => {\n        (state as any)[action.meta] = action.payload\n      },\n      prepare: <K extends keyof State, V extends State[K]>(key: K, value: V) =>\n        ({ payload: value, meta: key })\n    }\n  }\n})\n\nexport const { setProperty: setSettingsProperty, setInitial: setInitialSettings } = slice.actions\nexport type SettingsState = State\nexport default slice.reducer","import { readonlyArray, readonlyRecord, readonlyTuple } from 'fp-ts';\nimport { flow } from 'fp-ts/lib/function';\n\nexport function* permute<T>(values: ReadonlyArray<T>) {\n  const permutation = Array.from(values)\n  var length = permutation.length,\n      c = Array(length).fill(0),\n      i = 1, k, p;\n\n  yield permutation.slice();\n  while (i < length) {\n    if (c[i] < i) {\n      k = i % 2 && c[i];\n      p = permutation[i];\n      permutation[i] = permutation[k];\n      permutation[k] = p;\n      ++c[i];\n      i = 1;\n      yield permutation.slice();\n    } else {\n      c[i] = 0;\n      ++i;\n    }\n  }\n}\n\nexport const values = flow(readonlyRecord.toReadonlyArray, readonlyArray.map(readonlyTuple.snd))\n","import { either as E, ord, readonlyArray as RA, readonlyNonEmptyArray as RNEA } from 'fp-ts';\nimport { apply, constVoid, pipe } from 'fp-ts/lib/function';\n\nimport { Bid } from '../bridge';\nimport { Forest, getAllLeafPaths, Path } from '../system';\nimport { ConstrainedBid, ordConstrainedBid } from './core';\n\ninterface SystemValidationErrorBidsOutOfOrder {\n  type: \"BidsOutOfOrder\"\n  left: ConstrainedBid\n  right: ConstrainedBid\n}\n\n// interface SystemValidationErrorPrimarySuitAlreadyDefined {\n//   type: \"PrimarySuitAlreadyDefined\"\n//   constraint: ConstraintSuitPrimary\n// }\n// interface SystemValidationErrorSamePrimaryAndSecondarySuit {\n//   type: \"SamePrimaryAndSecondarySuit\"\n//   constraint: ConstraintSuitSecondary\n// }\n// interface SystemValidationErrorTrumpSuitAlreadyDefined {\n//   type: \"TrumpSuitAlreadyDefined\"\n//   constraint: ConstraintSetTrump\n// }\n// interface SystemValidationErrorSuitRangeInvalid {\n//   type: \"SuitRangeInvalid\",\n//   constraint: ConstraintSuitRange\n// }\n// interface SystemValidationErrorPointRangeInvalid {\n//   type: \"PointRangeInvalid\",\n//   constraint: ConstraintPointRange\n// }\n// interface SystemValidationErrorSpecificShapeInvalid {\n//   type: \"SpecificShapeInvalid\",\n//   constraint: ConstraintSpecificShape\n// }\n\n// interface SystemValidationErrorAnyShapeInvalid {\n//   type: \"AnyShapeInvalid\",\n//   constraint: ConstraintAnyShape\n// }\n// interface SystemValidationErrorPassWhileForcing {\n//   type: \"PassWhileForcing\",\n//   bid: Bid\n// }\n// interface SystemValidationErrorNoBidDefinedButStillForcing {\n//   type: \"NoBidDefinedButStillForcing\",\n//   path: ReadonlyArray<Bid>\n// }\n\n// interface SystemValidationErrorIllegalContextModification {\n//   type: \"IllegalContextModification\"\n// }\n\n// type SystemValidationBidReason =\n//   | SystemValidationErrorNoPrimarySuitDefined\n//   | SystemValidationErrorPrimarySuitAlreadyDefined\n//   | SystemValidationErrorSamePrimaryAndSecondarySuit\n//   | SystemValidationErrorTrumpSuitAlreadyDefined\n//   | SystemValidationErrorSuitRangeInvalid\n//   | SystemValidationErrorPointRangeInvalid\n//   | SystemValidationErrorSpecificShapeInvalid\n//   | SystemValidationErrorAnyShapeInvalid\n//   | SystemValidationErrorIllegalContextModification\n// type SystemValidationBidError = SystemValidationBidReason & {\n//   bid: Bid\n// }\n\nexport type SystemValidationError =\n  \n  // ( SystemValidationBidError\n  (| SystemValidationErrorBidsOutOfOrder )\n  // | SystemValidationErrorPassWhileForcing\n  // | SystemValidationErrorNoBidDefinedButStillForcing)\n  & { path: ReadonlyArray<Bid> }\n\ntype SystemValidation = E.Either<SystemValidationError, void>\n// type ValidateReasonResult = S.State<BidContext, E.Either<SystemValidationBidReason, void>>\n// type ValidateResult = S.State<BidContext, SystemValidation>\n\nconst bidPathSorted = (path: Path<ConstrainedBid>): SystemValidation =>\n  pipe(path,\n    RA.zip(RNEA.tail(path)),\n    RA.traverse(E.Applicative)(([left, right]) =>\n      !ord.lt(ordConstrainedBid)(left, right)\n      ? E.left({ type: \"BidsOutOfOrder\" as const, left, right, path: pipe(path, RA.map(cb => cb.bid)) })\n      : E.right(constVoid())),\n    E.map(constVoid))\n\nconst forestSorted = (tree: Forest<ConstrainedBid>) =>\n  // The sibling nodes do NOT need to be sorted\n  pipe(tree,\n    getAllLeafPaths,\n    RA.traverse(E.Applicative)(bidPathSorted),\n    E.map(constVoid))\n\n// const resetForce = S.modify(forceL.set(O.none))\n// const continueForce: typeof resetForce = S.of(constVoid())\n// const updateForce = (bid: Bid) => (force: ConstraintForce) => {\n//   switch (force.type) {\n//     case \"ForceOneRound\":\n//     case \"Relay\":\n//       return resetForce\n//     case \"ForceGame\":\n//       return isGameLevel(bid) ? resetForce : continueForce\n//     case \"ForceSlam\":\n//       return isSlamLevel(bid) ? resetForce : continueForce\n//     default:\n//       return assertUnreachable(force)\n//   }\n// }\n\n// const updateForceS : S.State<BidContext, void> =\n//   pipe(\n//     updateForce, ofS,\n//     S.ap(S.gets(bidL.get)),\n//     S.map(O.of),\n//     optionT.ap(S.Apply)(S.gets(forceL.get)),\n//     S.chain(O.sequence(S.Applicative)),\n//     S.map(constVoid))\n\n// const rotateRelativeContexts : S.State<BidContext, void> =\n//   pipe(\n//     S.sequenceArray([\n//       pipe(S.gets(playersL.get), S.chain(flow(rotateRecord(relativePlayers), playersL.set, S.modify))),\n//       pipe(S.gets(partnershipsL.get), S.chain(flow(rotateRecord(relativePartnerships), partnershipsL.set, S.modify)))\n//     ]),\n//     S.map(constVoid))\n\n// const checkPass = (bid: Bid) => (force: O.Option<ConstraintForce>) =>\n//   !(bid === \"Pass\" && O.isSome(force))\n\n// const checkPassS : ValidateResult =\n//   pipe(\n//     ofS(checkPass),\n//     S.ap(S.gets(bidL.get)),\n//     S.ap(S.gets(forceO.getOption)),\n//     S.chain(boolean.fold(\n//       flow(() => ofS({}),\n//         S.apS('bid', S.gets(bidL.get)),\n//         S.apS('path', S.gets(pathL.get)),\n//         S.map(({ bid, path }) =>\n//         E.left({ type: \"PassWhileForcing\" as const, bid, path }))),\n//       flow(constVoid, E.right, ofS))))\n\n// const checkFinal : ValidateResult =\n//   pipe(\n//     S.gets(forceO.getOption),\n//     S.bindTo('force'),  \n//     S.apS('path', S.gets(pathL.get)),\n//     S.map(({ force, path }) => pipe(force,\n//       E.fromPredicate(O.isNone, () => ({ type: \"NoBidDefinedButStillForcing\", path } as const)),\n//       E.map(constVoid))))\n\n// const pathIsSound = (path: Path<ConstrainedBid>) =>\n//   pipe(path,\n//     S.traverseArray(info =>\n//       pipe(\n//         S.modify(bidL.set(info.bid)),\n//         S.chain(() => checkPassS),\n//         S.chain(E.traverse(S.Applicative)(() =>\n//           pipe(ofS(info.constraint),\n//             S.apFirst(updateForceS),\n//             S.chain(validateS),\n//             S.map(E.mapLeft((r): SystemValidationBidError => ({ bid: info.bid, ...r })))))),\n//         S.apFirst(S.modify(pathL.modify(RA.prepend(info.bid)))),\n//         S.apFirst(rotateRelativeContexts),\n//         S.map(flow(\n//           E.map(E.mapLeft((err): SystemValidationError => ({ ...err, path: pipe(path, RA.map(b => b.bid)) }))),\n//           E.flatten)))),\n//     S.map(RA.sequence(E.Applicative)),\n//     eitherT.chain(S.Monad)(() => checkFinal),\n//     S.evaluate(zeroValidationContext))\n\n// const forestIsSound = (tree: Forest<ConstrainedBid>) : SystemValidation =>\n//   pipe(tree,\n//     getAllLeafPaths,\n//     RA.traverse(E.Applicative)(flow(\n//       pathIsSound,\n//       E.mapLeft((path): SystemValidationError => ({ type: \"SAT\", path })))),\n//     E.map(constVoid))\n\nexport const validateForest = (forest: Forest<ConstrainedBid>) =>\n  pipe([forestSorted], //forestIsSound],\n    RA.traverse(E.Applicative)(apply(forest)),\n    E.map(constVoid))","import { either as E, eq, option as O, readonlyArray as RA, readonlyNonEmptyArray as RNEA, readonlyTuple, state, string, these as TH, tree as T } from 'fp-ts';\nimport { observable as Ob } from 'fp-ts-rxjs';\nimport { apply, constFalse, flow, identity, pipe } from 'fp-ts/lib/function';\nimport { castDraft } from 'immer';\nimport * as t from 'io-ts';\nimport { DecodeError } from 'io-ts/lib/Decoder';\nimport memoize from 'proxy-memoize';\nimport { Epic } from 'redux-observable';\nimport { debounceTime } from 'rxjs';\n\nimport { datum as D } from '@nll/datum';\nimport { AnyAction, createEntityAdapter, createSlice, PayloadAction } from '@reduxjs/toolkit';\n\nimport { RootState } from '../app/store';\nimport { values } from '../lib/array';\nimport { get } from '../lib/object';\nimport { Bid, eqBid } from '../model/bridge';\nimport { chainCollectedErrors, collectErrors, flatten, ForestWithErrors, getAllLeafPaths, getPathForest, getPathUpTo, Path, withImplicitPasses } from '../model/system';\nimport { ExpandError, expandForest, SyntacticBid } from '../model/system/expander';\nimport { SystemValidationError, validateForest } from '../model/system/validation';\nimport { decodeBid } from '../parse';\nimport { observeValidation } from '../workers';\n\ntype BlockKey = string\nconst eqBlockKey : eq.Eq<BlockKey> = string.Eq\n\nexport type DecodedBid = ReturnType<typeof decodeBid>\ninterface DecodedBidItem {\n  id: BlockKey\n  value: DecodedBid\n}\nconst decodedBidAdapter = createEntityAdapter<DecodedBidItem>()\n\ntype SerializedBlockKeyPath = t.Branded<string, { readonly BlockKeyPath: unique symbol }>\ninterface ValidatedPathItem {\n  id: SerializedBlockKeyPath\n  value: D.Datum<boolean>\n}\nconst validatedPathAdapter = createEntityAdapter<ValidatedPathItem>()\n\ntype BlockTree = T.Forest<BlockKey>\ninterface State {\n  system: BlockTree\n  decodedBids: ReturnType<typeof decodedBidAdapter.getInitialState>\n  validatedPaths: ReturnType<typeof validatedPathAdapter.getInitialState>\n}\n\nconst initialState: State = {\n  system: [],\n  decodedBids: decodedBidAdapter.getInitialState(),\n  validatedPaths: validatedPathAdapter.getInitialState()\n}\n\nexport interface BlockKeyDescriptor {\n  key: BlockKey\n  depth: number\n}\nconst buildForest = (items: ReadonlyArray<BlockKeyDescriptor>): BlockTree => {\n  const root = T.make<BlockKey>(\"ROOT\")\n  var parents = [root]\n  items.forEach(item => {\n    const curr = parents[item.depth + 1] = {\n      forest: [],\n      value: item.key\n    }\n    parents[item.depth].forest.push(curr)\n  })\n  return root.forest\n}\n\nexport interface BlockItem {\n  key: string\n  text: string\n}\n\nconst name = 'system'\nconst slice = createSlice({\n  name,\n  initialState,\n  reducers: {\n    setSystem: (state, action: PayloadAction<ReadonlyArray<BlockKeyDescriptor>>) => {\n      state.system = pipe(buildForest(action.payload), castDraft)\n    },\n    removeConstraintsByBlockKey: (state, action: PayloadAction<RNEA.ReadonlyNonEmptyArray<BlockKey>>) => {\n      decodedBidAdapter.removeMany(state.decodedBids, action.payload)\n      // validatedPathAdapter.removeMany(\n      validatedPathAdapter.removeMany(state.validatedPaths,\n        pipe(state.validatedPaths.ids as unknown as ReadonlyArray<SerializedBlockKeyPath>,\n          RA.filter(path => pipe(action.payload, RA.exists(flow(string.includes, apply(path)))))))\n    },\n    cacheSystemConstraints: (state, action: PayloadAction<RNEA.ReadonlyNonEmptyArray<BlockItem>>) => {\n      const decodedBids = pipe(action.payload, RNEA.map((i): DecodedBidItem => ({ id: i.key, value: decodeBid(i.text) })))\n      decodedBidAdapter.setMany(state.decodedBids, decodedBids)\n    },\n    validateSystem: (state) => { },\n    reportValidationResult: (state, action: PayloadAction<readonly [Path<Bid>, boolean]>) => {\n      pipe(action.payload,\n        readonlyTuple.fst,\n        path => getValidationPathKeyByPath({ state, path }),\n        O.map(flow(\n          (id): ValidatedPathItem => ({ id, value: pipe(action.payload, readonlyTuple.snd, D.replete) }),\n          i => validatedPathAdapter.upsertOne(state.validatedPaths, i))))\n    }\n  }\n})\n\nexport const { setSystem, removeConstraintsByBlockKey, cacheSystemConstraints, validateSystem, reportValidationResult } = slice.actions\n\nconst constrainedBidSelectors = decodedBidAdapter.getSelectors()\n\ninterface KeyedState {\n  state: State\n  key: BlockKey\n}\n\nconst getCachedBidByKey = (constrainedBids: State['decodedBids']) => (key: BlockKey) =>\n  pipe(\n    O.fromNullableK(constrainedBidSelectors.selectById)(constrainedBids, key),\n    O.map(i => i.value))\n\ninterface StateWithPath {\n  state: State\n  path: Path<Bid>\n}\nconst getValidationPathKeyByPath = (({ state, path }: StateWithPath) => \n  pipe(path,\n    RNEA.traverse(O.Applicative)(b1 => pipe(\n      state.decodedBids.entities,\n      values,\n      RA.filterMap(O.fromNullable),\n      RA.findFirst(x => pipe(x.value, O.fromEither, O.map(get('bid')), b2 => O.elem(eqBid)(b1, b2))),\n      O.map(get('id')))),\n    O.map(flow(\n      RNEA.intersperse('.'),\n      RNEA.foldMap(string.Semigroup)(identity),\n      x => x as SerializedBlockKeyPath))))\n\nexport const selectBidByKey = memoize(({ state, key }: KeyedState) =>\n  pipe(key,\n    getCachedBidByKey(state.decodedBids),\n    O.chain(O.fromEither)))\n\nexport const selectBidPathUpToKey = memoize(({ state, key }: KeyedState) =>\n  pipe(\n    state.system,\n    getPathUpTo(eqBlockKey)(key),\n    O.getOrElse(() => RA.zero()),\n    RA.filterMap(getCachedBidByKey(state.decodedBids)),\n    RA.sequence(E.Applicative)))\n\nexport const selectRules = memoize((state: State) =>\n  pipe(state.system,\n    flatten,\n    RA.filterMap(getCachedBidByKey(state.decodedBids))))\n\nexport const selectErrors = memoize(\n  flow(\n    selectRules,\n    RA.lefts))\n\nconst getCompleteForest = (bids: State['decodedBids']) =>\n  flow(\n    RA.filterMap(T.traverse(O.Applicative)(getCachedBidByKey(bids))),\n    collectErrors)\n\ninterface OptionsState {\n  state: State\n  options?: { implicitPass: boolean }\n}\nexport const selectCompleteSyntaxForest = memoize(({ state, options }: OptionsState): ForestWithErrors<DecodeError, SyntacticBid> =>\n  pipe(state.system,\n    getCompleteForest(state.decodedBids),\n    TH.map(options?.implicitPass ? withImplicitPasses : identity)))\n\ninterface SystemErrorParse { type: \"Parse\", error: DecodeError }\ninterface SystemErrorSyntax { type: \"Syntax\", error: ExpandError }\ninterface SystemErrorValidation { type: \"Validation\", error: SystemValidationError }\nexport type SystemErrorWithPath = SystemErrorSyntax | SystemErrorValidation\nexport type SystemError =\n  | SystemErrorParse\n  | SystemErrorSyntax\n  | SystemErrorValidation\n\nexport const selectExpandedConstraintForest = memoize(\n  flow(selectCompleteSyntaxForest,\n    TH.mapLeft(RA.map((error): SystemError => ({ type: \"Parse\", error }))), \n    chainCollectedErrors(flow(\n      expandForest,\n      TH.mapLeft(RA.map((error): SystemError => ({ type: \"Syntax\", error })))))))\n\nexport const selectCompleteConstraintForest = memoize(\n  flow(selectExpandedConstraintForest,\n    chainCollectedErrors(bidForest => pipe(\n      bidForest,\n      validateForest,\n      TH.bimap(\n        (error): ReadonlyArray<SystemError> => RA.of({ type: \"Validation\", error }),\n        () => bidForest)))))\n\nexport const selectSystemWithErrors = memoize(\n  flow(selectCompleteConstraintForest,\n    TH.map(getAllLeafPaths)))\n\nexport const selectPristineSystem = memoize(\n  flow(selectSystemWithErrors,\n    TH.getRightOnly,\n    O.chain(RNEA.fromReadonlyArray)))\n\nexport const selectValidConstrainedBidPaths = memoize(\n  flow(selectSystemWithErrors,\n    TH.getRight,\n    O.chain(RNEA.fromReadonlyArray)))\n\nexport const selectCompleteBidPathUpToKey = memoize((state: KeyedState & OptionsState) =>\n  pipe(O.Do,\n    O.apS('path', O.fromEitherK(selectBidPathUpToKey)(state)),\n    O.apS('paths', pipe(state, selectCompleteConstraintForest, TH.getRight, O.map(getAllLeafPaths))),\n    O.chain(({ path, paths }) =>\n      pipe(paths,\n        RA.findFirst(cbPath =>\n          RA.getEq(pipe(eqBid, eq.contramap((b: { bid: Bid }) => b.bid)))\n            .equals(path, cbPath))))))\n\nexport const selectCompleteBidByKey = flow(\n  selectCompleteBidPathUpToKey,\n  O.map(RNEA.last))\n\nconst eqBidPath = pipe(eqBid, RA.getEq)\nexport interface ErrorNode {\n  bid: Bid\n  path: Path<Bid>\n  errors: ReadonlyArray<SystemErrorWithPath>\n}\nexport const selectErrorTree = memoize((options: OptionsState) =>\n  pipe(options,\n    selectCompleteSyntaxForest,\n    TH.map(flow(\n      RA.map(T.map(sb => sb.bid)),\n      getPathForest,\n      RA.toArray,\n      pathForest => pipe(options,\n        selectCompleteConstraintForest,\n        TH.getLeft,\n        O.getOrElse(() => RA.zero()),\n        RA.filterMap(e => e.type !== \"Parse\" ? O.some(e) : O.none),\n        errors =>\n          pipe(pathForest,\n            RA.map(T.map((path): ErrorNode => ({\n              bid: pipe(path, RNEA.last),\n              path,\n              errors: pipe(errors, RA.filter(e => eqBidPath.equals(e.error.path, path)))\n            })))))))))\n\nexport const selectErrorsByKey = memoize((state: KeyedState & OptionsState) =>\n  pipe(O.Do,\n    O.apS('errors', pipe(state,\n      selectErrorTree,\n      TH.getRight)),\n    O.apS('sb', selectBidByKey(state)),\n    O.fold(() => RA.empty,\n      ({ sb, errors }) => pipe(errors,\n        flatten,\n        RA.filter(e => eqBid.equals(sb.bid, e.bid))))))\n    \nexport default slice.reducer\n\nexport const epics : ReadonlyArray<Epic<AnyAction, AnyAction, RootState>> = [\n  flow(Ob.filter(setSystem.match),\n    debounceTime(1000),\n    Ob.map(() => validateSystem())),\n  (action$, state$) => pipe(action$,\n    Ob.filter(validateSystem.match),\n    // takeUntil(pipe(action$, Ob.filter(setSystem.match))),\n    Ob.chain(() => pipe(\n      { state: state$.value.system },\n      selectExpandedConstraintForest,\n      TH.getRight,\n      O.fold(() => RA.empty, getAllLeafPaths),\n      RA.filter(flow(\n        RNEA.map(get('bid')),\n        path => getValidationPathKeyByPath({ state: state$.value.system, path }),\n        O.fold(constFalse, bp => !state$.value.system.validatedPaths.ids.includes(bp)))),\n      observeValidation)),\n    Ob.map(reportValidationResult))\n]","import { option, readonlyArray } from 'fp-ts';\nimport { pipe } from 'fp-ts/lib/function';\nimport { ReadonlyNonEmptyArray } from 'fp-ts/lib/ReadonlyNonEmptyArray';\nimport memoize from 'proxy-memoize';\nimport { combineEpics } from 'redux-observable';\n\nimport { AnyAction } from '@reduxjs/toolkit';\n\nimport { RootState } from '../app/store';\nimport { ConstrainedBid } from '../model/system/core';\nimport { satisfiesPath } from '../model/system/satisfaction';\nimport generator, { epics as generatorEpics } from './generator';\nimport profile, { epics as profileEpics } from './profile';\nimport selection, { selectHand } from './selection';\nimport settings from './settings';\nimport system, { epics as systemEpics, selectValidConstrainedBidPaths } from './system';\n\nconst reducers = {\n  system,\n  selection,\n  generator,\n  settings,\n  profile\n}\nexport default reducers\n\nexport const rootEpic = combineEpics<AnyAction, AnyAction, RootState>(\n  ...generatorEpics,\n  ...profileEpics,\n  ...systemEpics\n)\n\ninterface BidResult {\n  path: ReadonlyNonEmptyArray<ConstrainedBid>\n  result: boolean\n}\n\nexport const selectPathsSatisfyHands = memoize((state: RootState) : ReadonlyArray<BidResult> | null =>\n  pipe(option.Do,\n    option.apS('opener', selectHand({ state: state.selection, type: 'opener' })),\n    option.apS('responder', selectHand({ state: state.selection, type: 'responder' })),\n    option.apS('paths', pipe(selectValidConstrainedBidPaths({ state: state.system, options: state.settings }))),\n    option.map(o => pipe(o.paths,\n      readonlyArray.map(path => ({\n        path,\n        result: satisfiesPath(o.opener, o.responder)(path)\n      })))),\n    option.toNullable))","import { Action, AnyAction, ThunkAction, configureStore } from '@reduxjs/toolkit';\nimport reducer, { rootEpic } from '../reducers';\n\nimport { createEpicMiddleware } from 'redux-observable';\n\ntype R = typeof reducer\nexport type RootState = { [K in keyof R]: ReturnType<R[K]> }\n\nconst epicMiddleware = createEpicMiddleware<AnyAction, AnyAction, RootState>()\nexport const store = configureStore({\n  reducer: reducer,\n  middleware: (getDefaultMiddleware => [...getDefaultMiddleware(), epicMiddleware])\n})\nepicMiddleware.run(rootEpic)\n\nexport type AppDispatch = typeof store.dispatch;\nexport type AppThunk<ReturnType = void> = ThunkAction<\n  ReturnType,\n  RootState,\n  unknown,\n  Action<string>\n>;","import { Link, Outlet } from 'react-router-dom';\n\nconst App = () => {\n  return (\n    <div className=\"App\">\n      <div>\n        <div style={{ display: \"inline-block\", float: 'left' }}>\n          <Link to=\"/design\">Design</Link>\n          &nbsp;|&nbsp;\n          <Link to=\"/analyze\">Analyze</Link>\n        </div>\n        <div style={{ display: \"inline-block\", float: 'right' }}>\n          <a target=\"_blank\" rel=\"noreferrer\" href=\"https://github.com/kdblocher/bridge#documentation\">Documentation</a>\n          &nbsp;|&nbsp;\n          <a target=\"_blank\" rel=\"noreferrer\" href=\"https://github.com/kdblocher/bridge/discussions\">Share ideas</a>\n          &nbsp;|&nbsp;\n          <a target=\"_blank\" rel=\"noreferrer\" href=\"https://github.com/kdblocher/bridge/issues/new\">Report issue</a>\n        </div>\n      </div>\n      <br />\n      <Outlet />\n    </div>\n  )\n}\n\nexport default App\n","import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';\nimport type { RootState, AppDispatch } from './store';\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\n","import \"draft-js/dist/Draft.css\";\n\nimport {\n  ContentBlock,\n  convertFromRaw,\n  convertToRaw,\n  Editor as DraftJsEditor,\n  EditorState,\n  getDefaultKeyBinding,\n  RichUtils,\n} from \"draft-js\";\nimport {\n  eq,\n  monoid,\n  number,\n  option,\n  ord,\n  readonlyArray,\n  readonlyNonEmptyArray,\n  readonlySet,\n  string,\n} from \"fp-ts\";\nimport { flow, pipe } from \"fp-ts/lib/function\";\nimport { useCallback, useEffect, useState } from \"react\";\nimport styled from \"styled-components\";\n\nimport { useAppDispatch, useAppSelector } from \"../app/hooks\";\nimport { selectBlockKey, setSelectedBlockKey } from \"../reducers/selection\";\nimport {\n  BlockItem,\n  BlockKeyDescriptor,\n  cacheSystemConstraints,\n  removeConstraintsByBlockKey,\n  setSystem,\n} from \"../reducers/system\";\n\nconst EditorDiv = styled.div`\n  font-family: Cascadia Code, Consolas, monospace;\n  font-size: 1em;\n`;\n\nconst getDescriptorFromContentBlock = (\n  x: ContentBlock\n): BlockKeyDescriptor & BlockItem => ({\n  key: x.getKey(),\n  text: x.getText(),\n  depth: x.getDepth(),\n});\n\nconst eqContentBlock = monoid.concatAll(eq.getMonoid<ContentBlock>())([\n  pipe(\n    string.Eq,\n    eq.contramap((b) => b.getKey())\n  ),\n  pipe(\n    string.Eq,\n    eq.contramap((b) => b.getText())\n  ),\n  pipe(\n    number.Eq,\n    eq.contramap((b) => b.getDepth())\n  ),\n]);\nconst getBlocks = (editorState: EditorState) =>\n  pipe(\n    editorState.getCurrentContent().getBlocksAsArray(),\n    readonlySet.fromReadonlyArray(eqContentBlock)\n  );\n\nconst Editor = () => {\n  const [editorState, setEditorState] = useState(() =>\n    EditorState.createEmpty()\n  );\n  const [blocks, setBlocks] = useState(() => getBlocks(editorState));\n  const dispatch = useAppDispatch();\n  const selectedBlockKey = useAppSelector((state) =>\n    selectBlockKey(state.selection)\n  );\n\n  const onChange = useCallback(\n    (editorState: EditorState) => {\n      setEditorState(editorState);\n      setTimeout(\n        () =>\n          localStorage.setItem(\n            \"editor\",\n            JSON.stringify(convertToRaw(editorState.getCurrentContent()))\n          ),\n        0\n      );\n      const newBlocks = getBlocks(editorState);\n      const same = readonlySet.intersection(eqContentBlock)(blocks, newBlocks);\n      const removed = readonlySet.difference(eqContentBlock)(blocks, same);\n      const added = readonlySet.difference(eqContentBlock)(newBlocks, same);\n      setBlocks(newBlocks);\n\n      if (\n        !readonlySet.isEmpty(\n          monoid.concatAll(\n            readonlySet.getUnionMonoid<ContentBlock>(eqContentBlock)\n          )([removed, added])\n        )\n      ) {\n        dispatch(\n          pipe(\n            newBlocks,\n            readonlySet.toReadonlyArray<ContentBlock>(ord.trivial),\n            readonlyArray.map(getDescriptorFromContentBlock),\n            setSystem\n          )\n        );\n        pipe(\n          removed,\n          readonlySet.toReadonlyArray<ContentBlock>(ord.trivial),\n          readonlyNonEmptyArray.fromReadonlyArray,\n          option.map(\n            flow(\n              readonlyNonEmptyArray.map((b) => b.getKey()),\n              (x) => dispatch(removeConstraintsByBlockKey(x))\n            )\n          )\n        );\n        pipe(\n          added,\n          readonlySet.toReadonlyArray<ContentBlock>(ord.trivial),\n          readonlyNonEmptyArray.fromReadonlyArray,\n          option.map(\n            flow(\n              readonlyNonEmptyArray.map(getDescriptorFromContentBlock),\n              (x) => dispatch(cacheSystemConstraints(x))\n            )\n          )\n        );\n      }\n\n      const newSelectedBlockKey = editorState.getSelection().getFocusKey();\n      if (newSelectedBlockKey !== selectedBlockKey) {\n        dispatch(setSelectedBlockKey(option.some(newSelectedBlockKey)));\n      }\n    },\n    [blocks, dispatch, selectedBlockKey]\n  );\n\n  useEffect(() => {\n    const savedEditorState = localStorage.getItem(\"editor\");\n    if (savedEditorState) {\n      setEditorState(() =>\n        EditorState.createWithContent(\n          convertFromRaw(JSON.parse(savedEditorState))\n        )\n      );\n    } else {\n      setEditorState(() =>\n        RichUtils.toggleBlockType(editorState, \"unordered-list-item\")\n      );\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return (\n    <div>\n      <h3>Editor</h3>\n      <EditorDiv>\n        <DraftJsEditor\n          editorState={editorState}\n          onChange={onChange}\n          // https://github.com/facebook/draft-js/blob/master/examples/draft-0-10-0/rich/rich.html#L61\n          keyBindingFn={(e) => {\n            if (e.keyCode === 9 /* TAB */) {\n              const newEditorState = RichUtils.onTab(\n                e,\n                editorState,\n                10 /* maxDepth */\n              );\n              if (newEditorState !== editorState) {\n                onChange(newEditorState);\n              }\n              return null;\n            }\n            return getDefaultKeyBinding(e);\n          }}\n        />\n      </EditorDiv>\n    </div>\n  );\n};\n\nexport default Editor;\n","import { Fragment } from 'react';\nimport styled from 'styled-components';\n\nimport { Bid, ContractBid, NonContractBid } from '../../model/bridge';\n\nconst SuitSpan = styled.span `\n  &.S::after { content: \"♠\"; color: #0000FF; }\n  &.H::after { content: \"♥\"; color: #FF0000; }\n  &.D::after { content: \"♦\"; color: #FFA500; }\n  &.C::after { content: \"♣\"; color: #32CD32; }\n  &.N::after { content: \"NT\" }\n`\n\nconst ContractBidView = ({ bid }: { bid: ContractBid }) =>\n  <>\n    <span>{bid.level}</span>\n    <SuitSpan className={bid.strain}></SuitSpan>\n  </>\n\nconst NonContractBidView = ({ bid }: { bid: NonContractBid }) =>\n  <span>{bid}</span>\n\nexport const BidView = ({ bid }: { bid: Bid }) =>\n  typeof bid === \"string\"\n    ? <NonContractBidView bid={bid} />\n    : <ContractBidView bid={bid} />\ninterface Props {\n  path: ReadonlyArray<Bid>\n}\nconst BidPath = ({ path }: Props) => \n  <span>{path.map((bid, i) => \n    <Fragment key={i}>\n      &nbsp;\n      <BidView bid={bid} />\n    </Fragment>)\n  }</span>\n\nexport default BidPath","import { option, readonlyArray as RA, these, tree as T } from 'fp-ts';\nimport { pipe } from 'fp-ts/lib/function';\nimport { draw } from 'io-ts/lib/Decoder';\nimport { Fragment, useMemo } from 'react';\nimport styled from 'styled-components';\n\nimport { useAppSelector } from '../app/hooks';\nimport { assertUnreachable } from '../lib';\nimport { Bid } from '../model/bridge';\nimport { serializedBidPathL } from '../model/serialization';\nimport { Forest } from '../model/system';\nimport { ExpandError } from '../model/system/expander';\nimport { SystemValidationError } from '../model/system/validation';\nimport { ErrorNode, selectErrorTree, selectPristineSystem, SystemErrorWithPath } from '../reducers/system';\nimport BidPath, { BidView } from './core/BidPath';\n\nconst GridContainer = styled.div`\n  clear: both;\n  display: inline-grid;\n  grid-template-columns: auto auto;\n  width: auto;\n`\n\ninterface ExpandErrorProps {\n  error: ExpandError\n}\nconst ExpandErrorView = ({ error }: ExpandErrorProps) =>\n  <span>{error.syntax.type}: {error.reason}</span>\n\ninterface ValidationErrorProps {\n  error: SystemValidationError\n}\nconst ValidationErrorView = ({ error }: ValidationErrorProps) => {\n  switch (error.type) {\n    case \"BidsOutOfOrder\": return <span>Bids <BidView bid={error.left.bid} /> and <BidView bid={error.right.bid} /> out of order</span>\n    // case \"SAT\": return <span>Path has no solution: <BidPath path={error.path} /></span>\n    // case \"NoPrimarySuitDefined\": return <span>No primary suit defined for secondary suit {error.constraint.suit}</span>\n    // case \"PrimarySuitAlreadyDefined\": return <span>Primary suit has already been defined</span>\n    // case \"SamePrimaryAndSecondarySuit\": return <span>Primary and secondary suits cannot be the same</span>\n    // case \"TrumpSuitAlreadyDefined\": return <span>Trump suit has already been defined</span>\n    // case \"NoBidDefinedButStillForcing\": return <span>Bid is forcing, but no response is defined</span>\n    // case \"PassWhileForcing\": return <span>Previous bid is forcing, but a pass was bid</span>\n    // case \"SuitRangeInvalid\": return <span>Suit {error.constraint.suit} range {error.constraint.min}, {error.constraint.max} is invalid</span>\n    // case \"PointRangeInvalid\": return <span>Point range {error.constraint.min}, {error.constraint.max} is invalid </span>\n    // case \"SpecificShapeInvalid\": return <span>Specific shape {error.constraint.suits.S}{error.constraint.suits.H}{error.constraint.suits.D}{error.constraint.suits.C} is invalid</span>\n    // case \"AnyShapeInvalid\": return <span>Shape {pipe(error.constraint.counts, RA.reduce(\"\", (cur, c) => cur + c))} is invalid</span>\n    // case \"IllegalContextModification\": return <span>Cannot modify the context under a disjunction or negation</span>\n    // default: return assertUnreachable(error)\n  }\n}\n\ninterface ErrorProps {\n  bid: Bid\n  errors: ReadonlyArray<SystemErrorWithPath>\n}\nconst BidErrorsView = ({ bid, errors }: ErrorProps) =>\n  <div>\n    {errors.map((e, i) => {\n      switch (e.type) {\n        case \"Syntax\": return <ExpandErrorView key={i} error={e.error} />\n        case \"Validation\": return <ValidationErrorView key={i} error={e.error} />\n        default: return assertUnreachable(e)\n      }\n    })}\n    {errors.length === 0 && \"none\"}\n  </div>\n\ninterface ErrorGridProps {\n  errors: ReadonlyArray<ErrorNode>\n}\nexport const ErrorGrid = ({ errors }: ErrorGridProps) =>\n  <GridContainer>\n    {errors.filter(e => e.errors.length > 0).map(({ bid, path, errors }) =>\n      <Fragment key={serializedBidPathL.get(path)}>\n        <BidPath path={path} />\n        <BidErrorsView bid={bid} errors={errors} />\n      </Fragment>\n    )}\n  </GridContainer>\n\ninterface ErrorForestProps {\n  forest: Forest<ErrorNode>\n}\nconst ErrorForest = ({ forest }: ErrorForestProps) => {\n  const flattenedForest = useMemo(() => pipe(forest, RA.chain(T.foldMap(RA.getMonoid<ErrorNode>())(RA.of))), [forest])\n  return <ErrorGrid errors={flattenedForest} />\n}\n\nconst Errors = () => {\n  const systemExists = useAppSelector(state => pipe(state.system.system, RA.isNonEmpty))\n  const isPristine = useAppSelector(state => pipe(\n    selectPristineSystem({ state: state.system, options: state.settings }),\n    option.isSome))\n  const errors = useAppSelector(state => selectErrorTree({ state: state.system, options: state.settings }))\n  return (\n    <section>\n      {!systemExists || isPristine ? <></> : <>\n        <h3>Errors</h3>\n        {these.isLeft(errors) && <div>\n          <h4>Parse Errors</h4>\n          <ul>{errors.left.map((e, i) => <li key={i}><pre>{draw(e)}</pre></li>)}</ul>\n        </div>}\n        {these.isRight(errors) && <div>\n          <h4>Semantic Errors</h4>\n          <ErrorForest forest={errors.right} />\n        </div>}\n      </>}\n    </section>\n  )\n}\n\nexport default Errors","import { option, readonlyArray } from 'fp-ts';\nimport { pipe } from 'fp-ts/lib/function';\nimport JSONPretty from 'react-json-pretty';\n\nimport { useAppSelector } from '../app/hooks';\nimport { selectBidByKey, selectCompleteBidByKey, selectErrorsByKey } from '../reducers/system';\nimport { ErrorGrid } from './Errors';\n\nconst SelectionDetails = () => {\n  const selected = useAppSelector(state => state.selection.selectedBlockKey)\n  const syntacticBid = useAppSelector(state => pipe(selected,\n    option.chain(key => selectBidByKey({ state: state.system, key })),\n    option.toNullable))\n  const constrainedBid = useAppSelector(state => pipe(selected,\n    option.chain(key => selectCompleteBidByKey({ state: state.system, key })),\n    option.toNullable))\n  const errors = useAppSelector(state =>  pipe(selected,\n    option.fold(() => readonlyArray.empty, key => selectErrorsByKey({ state: state.system, key }))))\n\n  return (\n    <section>\n      {selected && <div>\n        <h3>Selection</h3>\n        {errors && <div>\n          <h4>Errors</h4>\n          <ErrorGrid errors={errors} />\n        </div>}\n        {syntacticBid && <div>\n          <h4>Syntax</h4>\n          <JSONPretty data={syntacticBid} />\n        </div>}\n        {constrainedBid && <div>\n          <h4>Constraint</h4>\n          <JSONPretty data={constrainedBid} />\n        </div>}\n      </div>}\n    </section>\n  )\n}\n\nexport default SelectionDetails","import { readonlyArray, readonlyRecord, readonlyTuple } from 'fp-ts';\nimport { pipe } from 'fp-ts/lib/function';\nimport styled from 'styled-components';\nimport { getOrdGroupedHand, groupHandBySuits, Hand, Rank, rankStrings, Suit } from '../../model/deck';\n\n\nconst RankList = styled.ol `\n  padding-left: 0;\n`\n\nconst RankListItem = styled.li `\n  list-style-type: none;\n  display: inline;\n  float: left;\n`\n\ninterface RankProps {\n  rank: Rank\n}\nconst RankView = ({ rank }: RankProps) =>\n  <RankListItem>{rankStrings[rank - 2]}</RankListItem>\n\nconst SuitList = styled.ol `\n  white-space: nowrap;\n  width: 15em;\n  margin: 0;\n  padding-left: 0;\n  list-style: decimal url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) inside;\n`\n\nconst suitBase = `\n  &.S::before { content: \"♠\"; color: #0000FF }\n  &.H::before { content: \"♥\"; color: #FF0000 }\n  &.D::before { content: \"♦\"; color: #FFA500 }\n  &.C::before { content: \"♣\"; color: #32CD32 }\n`\n\nconst SuitListItem = styled.li `\n  display: inline;\n  &::before {\n    display: inline;\n    float: left;\n    margin-left: 5px;\n  }\n  ${suitBase}\n`\n\ninterface SuitProps {\n  suit: Suit\n  ranks: ReadonlyArray<Rank>\n}\nconst SuitView = ({ suit, ranks }: SuitProps) => {\n  return <SuitListItem className={suit}>\n    <RankList>\n      {ranks.map((r, i) => <RankView key={i} rank={r} />)}\n      {ranks.length === 0 && <RankListItem>-</RankListItem> }\n    </RankList>\n </SuitListItem>\n}\n\ninterface HandProps {\n  hand: Hand\n}\nconst HandView = ({ hand }: HandProps) => {\n  const groupedHand = groupHandBySuits(hand)\n  return (\n    <SuitList>\n      {pipe(groupedHand,\n        readonlyRecord.mapWithIndex((suit, ranks) =>\n          <SuitView key={suit} suit={suit} ranks={ranks} />),\n        readonlyRecord.toReadonlyArray,\n        readonlyArray.sort(getOrdGroupedHand<JSX.Element>()),\n        readonlyArray.map(readonlyTuple.snd))}\n    </SuitList>\n  )\n}\n\nexport default HandView","import styled from 'styled-components';\nimport { directions, strains } from '../../model/bridge';\nimport { serializedDealL } from '../../model/serialization';\nimport { DoubleDummyResult, DoubleDummyTable } from '../../workers/dds.worker';\nimport HandView from './HandView';\n\n\nconst suitBase = `\n  &.S::before { content: \"♠\"; color: #0000FF }\n  &.H::before { content: \"♥\"; color: #FF0000 }\n  &.D::before { content: \"♦\"; color: #FFA500 }\n  &.C::before { content: \"♣\"; color: #32CD32 }\n`\n\nconst StrainSpan = styled.span `\n  ${suitBase}\n  &.N::before { content: \"NT\"; color: #000000; font-size: 12px; }\n`\n\ninterface DoubleDummyTableProps {\n  table: DoubleDummyTable\n}\nexport const DoubleDummyTableView = ({ table }: DoubleDummyTableProps) => {\n  return (\n    <table>\n      <thead>\n        <tr>\n          <th></th>\n          {strains.map((s, i) => <th style={{fontWeight: \"normal\", verticalAlign: \"middle\"}} key={i}><StrainSpan className={s} /></th>)}\n        </tr>\n      </thead>\n      <tbody>\n        {directions.map((d, i) => <tr key={i}>\n          <td>{d}</td>\n          {strains.map((s, i) => <td key={i}>{Math.round(table[s][d] * 100) / 100}</td>)}\n        </tr>)}\n      </tbody>\n    </table>\n  )\n}\n\ninterface Props {\n  result: DoubleDummyResult\n}\nconst DoubleDummyResultView = ({ result }: Props) => {\n  return (\n    <table>\n      <thead>\n        <tr>\n          <th></th>\n          {strains.map((s, i) => <th style={{fontWeight: \"normal\", verticalAlign: \"middle\"}} key={i}><StrainSpan className={s} /></th>)}\n        </tr>\n      </thead>\n      <tbody>\n        {directions.map((d, i) => <tr key={i}>\n          <td>{d}</td>\n          {strains.map((s, i) => <td key={i}>{result.results[s][d]}</td>)}\n          <td><HandView hand={serializedDealL.reverseGet(result.board.deal)[d]} /></td>\n        </tr>)}\n      </tbody>\n    </table>\n  )\n}\n\nexport default DoubleDummyResultView","import { either, option } from \"fp-ts\"\n\nimport { DecodeError } from \"io-ts/Decoder\"\nimport { draw } from \"io-ts/lib/Decoder\"\nimport { pipe } from \"fp-ts/lib/function\"\n\ninterface OptionProps<T> {\n  value: option.Option<T>\n  children: (value: T) => JSX.Element\n  onNone?: () => JSX.Element\n}\nexport const Option = <T extends {}>({value, children: onSuccess, onNone }: OptionProps<T>) => \n  pipe(value, option.fold(\n    () => onNone ? onNone() : <></>,\n    onSuccess))\n\ninterface DecodeProps<T> {\n  value: either.Either<DecodeError, T>\n  children: (value: T) => JSX.Element\n  onError?: (error: DecodeError) => JSX.Element\n}\nexport const Decode = <T extends {}>({value, children: onSuccess, onError }: DecodeProps<T>) => \n  pipe(value, either.fold(\n    e => onError ? onError(e) : <span>{draw(e)}</span>,\n    onSuccess))","import { Button } from '@fluentui/react-components';\nimport { option } from 'fp-ts';\nimport { pipe } from 'fp-ts/lib/function';\nimport { useState } from 'react';\n\nimport { useAppDispatch, useAppSelector } from '../app/hooks';\nimport { Paths } from '../model/system';\nimport { ConstrainedBid } from '../model/system/core';\nimport { genHandsMatchingExactlyOneOf, genHandsMatchingMoreThanOneOf, genHandsNotMatchingAnyOf, genOnce, getHandsMatchingPath } from '../reducers/selection';\nimport { selectCompleteBidPathUpToKey, selectValidConstrainedBidPaths } from '../reducers/system';\n\nconst GenerateOnce = () => {\n  const dispatch = useAppDispatch()\n  return (\n    <Button onClick={() => dispatch(genOnce())}>Random</Button>\n  )\n}\n\ninterface GenerateSystemProps {\n  bidPaths: Paths<ConstrainedBid> | null\n}\n\nconst GenerateMatchZero = ({ bidPaths }: GenerateSystemProps) => {\n  const dispatch = useAppDispatch()\n  const [minHcp, setMinHcp] = useState<number>(11)\n  return <>\n    {bidPaths && <span>\n      <Button onClick={() => dispatch(genHandsNotMatchingAnyOf(bidPaths, minHcp))}>Zero</Button>\n      Min HCP\n      <input type=\"number\" style={{ width: 50 }} value={minHcp} onChange={e => setMinHcp(parseInt(e.target.value))} />\n    </span>}\n  </>\n}\n\nconst GenerateMatchOne = ({ bidPaths }: GenerateSystemProps) => {\n  const dispatch = useAppDispatch()\n  return <>\n    {bidPaths && <span>\n      <Button onClick={() => dispatch(genHandsMatchingExactlyOneOf(bidPaths))}>One</Button>\n    </span>}\n  </>\n}\n\nconst GenerateMatchMany = ({ bidPaths }: GenerateSystemProps) => {\n  const dispatch = useAppDispatch()\n  return <>\n    {bidPaths && <span>\n      <Button onClick={() => dispatch(genHandsMatchingMoreThanOneOf(bidPaths))}>Many</Button>\n    </span>}\n  </>\n}\n\nconst GenerateMatchSelected = () => {\n  const selected = useAppSelector(state => state.selection.selectedBlockKey)\n  const bidPath = useAppSelector(state => pipe(selected,\n    option.chain(key => selectCompleteBidPathUpToKey({ state: state.system, key })),\n    option.toNullable))\n  const dispatch = useAppDispatch()\n  return <>\n    {bidPath && <Button onClick={() => dispatch(getHandsMatchingPath(bidPath))}>Selected</Button>}\n  </>\n}\n\nconst SelectionGenerators = () => {\n  const bidPaths = useAppSelector(state =>\n    pipe(selectValidConstrainedBidPaths({ state: state.system, options: state.settings }),\n      option.toNullable))\n  return (\n    <section>\n      <h4>Generate Hands</h4>\n      <GenerateOnce />\n      <GenerateMatchSelected />\n      <GenerateMatchZero bidPaths={bidPaths} />\n      <GenerateMatchOne bidPaths={bidPaths} />\n      <GenerateMatchMany bidPaths={bidPaths} />\n    </section>)\n}\n\nexport default SelectionGenerators","import { Button } from '@fluentui/react-components';\nimport { option, readonlyRecord } from 'fp-ts';\nimport { constVoid, flow, pipe } from 'fp-ts/lib/function';\nimport { useCallback, useEffect, useState } from 'react';\nimport styled from 'styled-components';\n\nimport { useAppDispatch, useAppSelector } from '../app/hooks';\nimport { serializedHandL } from '../model/serialization';\nimport { handE } from '../parse/hand';\nimport { AuctionPositionType, getResult, selectHand, setHand } from '../reducers/selection';\nimport DoubleDummyResultView from './core/DoubleDummyResultView';\nimport HandView from './core/HandView';\nimport { Option } from './core/Monad';\nimport SelectionGenerators from './SelectionGenerators';\n\ninterface HandInputProps {\n  type: AuctionPositionType\n}\nconst HandInput = ({ type }: HandInputProps) => {\n  const dispatch = useAppDispatch()\n  const [value, setValue] = useState<string>(\"\")\n  const storageKey = `hand.${type}`\n\n  const encodedHand = useAppSelector(state => pipe(\n    selectHand({ state: state.selection, type }),\n    option.map(handE.encode),\n    option.toNullable))\n\n  const onSetHand = useCallback((hand: string) => {\n    setValue(hand)\n    dispatch(setHand(hand, type))\n  }, [dispatch, type])\n\n  useEffect(() => {\n    const savedHand = localStorage.getItem(storageKey)\n    if (savedHand) {\n      onSetHand(savedHand)\n    }\n  }, [onSetHand, storageKey, type])\n\n  return <input type=\"text\" placeholder=\"AKQJ.T987.654.32\" value={encodedHand ?? value} onChange={e => onSetHand(e.target.value)} onBlur={() => localStorage.setItem(storageKey, value)} />\n}\n\nconst HandCol = styled.th`\n  width: 15em;\n`\n\nconst HandEditor = () => {\n  const dispatch = useAppDispatch()\n  const [o, r] = [\n    useAppSelector(state => selectHand({ state: state.selection, type: 'opener' })),\n    useAppSelector(state => selectHand({ state: state.selection, type: 'responder' }))\n  ]\n  const getResultCallback = useCallback(() => pipe(\n    option.Do,\n    option.apS('opener', o),\n    option.apS('responder', r),\n    option.map(flow(\n      readonlyRecord.map(serializedHandL.get),\n      getResult,\n      dispatch)),\n    constVoid), [dispatch, o, r])\n\n  const result = useAppSelector(state => state.selection.result)\n\n  return (\n    <>\n      <table>\n        <thead>\n          <tr>\n            <HandCol>Opener</HandCol>\n            <HandCol>Responder</HandCol>\n          </tr>\n        </thead>\n        <tbody>\n          <tr>\n            <td><HandInput type=\"opener\" /></td>\n            <td><HandInput type=\"responder\" /></td>\n          </tr>\n          <tr>\n            <td><Option value={o}>{hand => <HandView hand={hand} />}</Option></td>\n            <td><Option value={r}>{hand => <HandView hand={hand} />}</Option></td>\n          </tr>\n        </tbody>\n      </table>\n      <SelectionGenerators />\n      <p>\n        <Button onClick={getResultCallback}>Solution</Button>\n        {result && <DoubleDummyResultView result={result} />}\n      </p>\n    </>\n  )\n}\n\nexport default HandEditor","import { useAppSelector } from '../app/hooks';\nimport { selectPathsSatisfyHands } from '../reducers';\nimport BidPath from './core/BidPath';\nimport HandEditor from './HandEditor';\n\nconst TestHands = () => {\n  const results = useAppSelector(selectPathsSatisfyHands)\n  return (\n    <section>\n      <h3>Test Hands</h3>\n      <HandEditor />\n      {results !== null && <div>\n        <h4>Results</h4>\n        <ul>\n          {results.map((r, i) => <li key={i}>\n            <BidPath path={r.path.map(p => p.bid)} />\n            : &nbsp;\n            <span>{r.result.toString()}</span>\n          </li>)}\n        </ul>\n      </div>}\n    </section>\n  )\n}\n\nexport default TestHands","import Editor from \"./Editor\"\nimport Errors from \"./Errors\"\nimport SelectionDetails from \"./SelectionDetails\"\nimport TestHands from \"./TestHands\"\n\nconst Design = () => {\n  return (\n    <>\n      <div style={{ clear: 'both', display: \"inline-block\", width: '50%' }}>\n        <div style={{ float: \"left\" }}>\n          <Editor />\n        </div>\n        <div style={{ clear: \"both\" }}>\n          <Errors />\n        </div>\n      </div>\n      <div style={{ display: \"inline-block\", width: '50%', float: \"right\" }}>\n        <TestHands />\n        {/* <SystemDetails /> */}\n        <SelectionDetails />\n      </div>\n    </>\n  )\n}\n\nexport default Design","interface FractionalProps {\n  numerator: number\n  denominator: number\n  decimalPlaces?: number\n}\nconst Fractional = ({ numerator, denominator, decimalPlaces }: FractionalProps) => {\n  const m = Math.pow(10, decimalPlaces ?? 0)\n  return <span>1 in {Math.floor(denominator / numerator * m) / m}</span>\n}\n\nexport default Fractional","interface PercentageProps {\n  numerator: number\n  denominator: number\n  decimalPlaces?: number\n}\nconst Percentage = ({ numerator, denominator, decimalPlaces }: PercentageProps) => {\n  const m = Math.pow(10, decimalPlaces ?? 0)\n  return <span>{Math.floor(numerator * (100 * m) / denominator) / m}%</span>\n}\n\nexport default Percentage","import { SerializedBidPath, serializedBidPathL } from '../../model/serialization';\nimport BidPath from '../core/BidPath';\nimport Fractional from '../core/Fractional';\nimport Percentage from '../core/Percentage';\n\ninterface StatsPathProps {\n  path: SerializedBidPath\n  satisfiesCount: number\n  dealCount?: number\n}\nconst StatsPath = ({ path, satisfiesCount, dealCount }: StatsPathProps) => {\n  return (\n    <>\n      <BidPath path={serializedBidPathL.reverseGet(path)} />\n      <span>\n        {satisfiesCount}\n        {dealCount && <small>\n          &nbsp;(\n          <Percentage numerator={satisfiesCount} denominator={dealCount} decimalPlaces={2} />\n          &nbsp;,&nbsp;or&nbsp;\n          <Fractional numerator={satisfiesCount} denominator={dealCount} />\n          )\n        </small>}\n      </span>\n    </>)\n}\n\nexport default StatsPath","import { Stats } from '../../model/stats';\nimport { DoubleDummyTableView } from '../core/DoubleDummyResultView';\n\ninterface SolutionStatsProps {\n  stats: Stats\n}\nconst SolutionStats = ({ stats }: SolutionStatsProps) => {\n  return (<>\n    {stats.average !== null && <section>\n      <h4>Average</h4>\n      {stats.average !== null && <DoubleDummyTableView table={stats.average} />}\n    </section>}\n    {stats.stdev !== null && <section>\n      <h4>Std. Dev.</h4>\n      <DoubleDummyTableView table={stats.stdev} />\n    </section>}\n  </>)\n}\n\nexport default SolutionStats","import styled from 'styled-components';\nimport { readonlyRecord as RR } from 'fp-ts';\nimport { Strain, strains } from '../../model/bridge';\n\nconst suitBase = `\n  &.S::before { content: \"♠\"; color: #0000FF }\n  &.H::before { content: \"♥\"; color: #FF0000 }\n  &.D::before { content: \"♦\"; color: #FFA500 }\n  &.C::before { content: \"♣\"; color: #32CD32 }\n`\n\nexport const StrainSpan = styled.span `\n  ${suitBase}\n  &.N::before { content: \"NT\"; color: #000000; font-size: 12px; }\n`\n\ntype StrainRow<T> = RR.ReadonlyRecord<Strain, T>\nexport interface StrainTable<T> {\n  rows: ReadonlyArray<StrainRow<T>>\n}\n\ninterface StrainTableProps<T> {\n  table: StrainTable<T>\n  renderColHeader: ((strain: Strain, index: number) => JSX.Element | undefined)\n  renderRowHeader: (row: StrainRow<T>, index: number) => JSX.Element | undefined\n  renderCell: (value: T, strain: Strain, rowIndex: number) => JSX.Element | undefined\n}\n\nexport const StrainTableView = <T extends any>({ table, renderColHeader, renderRowHeader, renderCell }: StrainTableProps<T>) => {\n  return (\n    <table>\n      <thead>\n        <tr>\n          <th></th>\n          {strains.map((s, i) => renderColHeader ? renderColHeader(s, i) : <th style={{fontWeight: \"normal\", verticalAlign: \"middle\"}} key={i}><StrainSpan className={s} /></th>)}\n        </tr>\n      </thead>\n      <tbody>\n        {table.rows.map((r, i) => <tr key={i}>\n          <td>{renderRowHeader(r, i)}</td>\n          {strains.map((s, j) => <td key={j}>{renderCell(r[s], s, i)}</td>)}\n        </tr>)}\n      </tbody>\n    </table>\n  )\n}\n\nexport default StrainTableView","import { readonlyRecord as RR, readonlyArray as RA, } from \"fp-ts\"\nimport { ContractBid, eqContractBid, levels, strains } from \"../../model/bridge\"\nimport StrainTableView, { StrainSpan } from \"./StrainTableView\"\nimport { pipe } from \"fp-ts/lib/function\"\nimport { Button } from '@fluentui/react-components';\n\ninterface BidSelectorButtonProps {\n  selected: boolean,\n  children: JSX.Element\n  setSelected: (selected: boolean) => void\n}\nconst BidSelectorButton = ({ children, selected, setSelected }: BidSelectorButtonProps) =>\n  <Button style={{minWidth: \"50px\", width: \"50px\"}} onClick={() => setSelected(!selected)} appearance={selected ? \"primary\" : \"secondary\"}>{children}</Button>\n\ninterface BidSelectorProps {\n  bids: ReadonlyArray<ContractBid>,\n  setSelectedBid: (bid: ContractBid, selected: boolean) => void \n}\nexport const BidSelector = ({ bids, setSelectedBid }: BidSelectorProps) => {\n  const contractBidsEnabledByLevel =\n    pipe(levels,\n      RA.map(level => pipe(strains,\n        RA.map(strain => ({ level, strain }) as ContractBid),\n        RA.map(bid => [bid.strain, pipe(bids, RA.exists(selectedBid => eqContractBid.equals(bid, selectedBid)))] as const),\n      RR.fromEntries)))\n  return (<StrainTableView\n    table={{rows: contractBidsEnabledByLevel}}\n    renderColHeader={() => undefined}\n    renderRowHeader={() => undefined}\n    renderCell={(selected, s, i) =>\n      <BidSelectorButton selected={selected} setSelected={selected => setSelectedBid({ level: i + 1, strain: s}, selected)}>\n        <>{i + 1}<StrainSpan className={s} /></>\n      </BidSelectorButton>}\n    />)\n}\n\nexport default BidSelector","import { ContractBid, Direction, eqContractBid, ordContractBid } from \"../../model/bridge\";\nimport { readonlyArray as RA, readonlyNonEmptyArray as RNEA } from \"fp-ts\";\nimport { Scores, compareScores } from \"../../model/stats\"\nimport Percentage from \"../core/Percentage\";\nimport BidSelector from \"../core/BidSelector\";\nimport { useCallback, useMemo, useState } from \"react\";\nimport { pipe } from \"fp-ts/lib/function\";\nimport styled from \"styled-components\";\nimport { BidView } from \"../core/BidPath\";\nimport { serializedBidL } from \"../../model/serialization\";\n\ninterface ScoreComparisonProps {\n  contractBid: ContractBid\n  scores: Scores\n}\nconst defaultDir : Direction = \"N\"\n\nexport const Columns = styled.div `\n  display: flex;\n  flex-direction: row;\n`\n\nexport const Column = styled.div `\n  width: 35%;\n`\n\nexport const ScoreList = styled.ul `\n  list-style-type: none;\n`\n\nconst ScoreComparison = ({ contractBid, scores }: ScoreComparisonProps) => {\n  const [bids, setBids] = useState<RNEA.ReadonlyNonEmptyArray<ContractBid>>([contractBid])\n  const setSelectedBid = useCallback((bid: ContractBid, selected: boolean) =>\n    setBids(pipe(\n      bids,\n      selected ? RA.union(eqContractBid)([bid]) : RA.filter(b => !eqContractBid.equals(bid, b)),\n      RA.append(contractBid),\n      RNEA.uniq(eqContractBid),\n      RNEA.sort(ordContractBid)))\n  , [bids, contractBid])\n  const comparison = useMemo(() => compareScores(scores)(pipe(bids, RNEA.map(b => ([defaultDir, b])))), [bids, scores])\n  const length = scores.length\n  return (<section>\n    <h4>Compare Contracts</h4>\n    <Columns>\n      <BidSelector bids={bids} setSelectedBid={setSelectedBid} />\n      <ScoreList>{length && Object.entries(comparison).map(([contract, count], i) =>\n        <li key={i}>\n          {contract === \"tie\" ? \"(ties)\" : <BidView bid={serializedBidL.reverseGet(contract)} />}\n          : {count} (<Percentage numerator={count} denominator={length} />)\n        </li>)}\n      </ScoreList>\n    </Columns>\n  </section>)\n}\n\nexport default ScoreComparison","import {\n  option as O,\n  readonlyRecord as RR,\n  readonlyNonEmptyArray as RNEA,\n} from \"fp-ts\";\nimport { flow, pipe } from \"fp-ts/lib/function\";\nimport { get } from \"../../lib/object\";\nimport { Generation } from \"../../model/job\";\nimport {\n  SerializedBidPath,\n  serializedBidPathL,\n} from \"../../model/serialization\";\nimport SolutionStats from \"./SolutionStats\";\nimport ScoreComparison from \"./ScoreComparison\";\nimport { ContractBid } from \"../../model/bridge\";\nimport styled from \"styled-components\";\n\nexport const Columns = styled.div`\n  display: flex;\n  flex-direction: row;\n`;\n\nexport const Column = styled.div`\n  width: 35%;\n`;\n\ninterface StatsDetailsProps {\n  path: SerializedBidPath;\n  generation: Generation;\n  onClose: () => void;\n}\nconst StatsDetails = ({ path, generation, onClose }: StatsDetailsProps) => {\n  const stats = pipe(\n    generation,\n    O.fromNullable,\n    O.chain(flow(get(\"solutionStats\"), RR.lookup(path))),\n    O.toNullable\n  );\n  const solveCount = pipe(\n    stats,\n    O.fromNullable,\n    O.map(get(\"count\")),\n    O.chain(O.fromPredicate((len) => len > 0)),\n    O.toNullable\n  );\n  const contractBid = pipe(\n    path,\n    serializedBidPathL.reverseGet,\n    RNEA.last\n  ) as ContractBid;\n  return (\n    <div>\n      {solveCount && <h3>{solveCount} solutions found</h3>}\n      <Columns>\n        <Column>{stats && <SolutionStats stats={stats} />}</Column>\n        <div>\n          {stats?.scores && (\n            <ScoreComparison contractBid={contractBid} scores={stats.scores} />\n          )}\n        </div>\n      </Columns>\n    </div>\n  );\n};\n\nexport default StatsDetails;\n","import {\n  number,\n  option as O,\n  readonlyArray as RA,\n  readonlyRecord as RR,\n  readonlyTuple,\n  taskEither as TE,\n} from \"fp-ts\";\nimport { flow, pipe } from \"fp-ts/lib/function\";\nimport { Fragment, useCallback, useMemo, useState } from \"react\";\nimport styled from \"styled-components\";\n\nimport {\n  Button,\n  Dialog,\n  DialogActions,\n  DialogBody,\n  DialogContent,\n  DialogSurface,\n  DialogTitle,\n  DialogTrigger,\n} from \"@fluentui/react-components\";\nimport { ReadonlyNonEmptyArray } from \"fp-ts/lib/ReadonlyNonEmptyArray\";\nimport { useAppDispatch, useAppSelector } from \"../app/hooks\";\nimport { get } from \"../lib/object\";\nimport { eqBid } from \"../model/bridge\";\nimport {\n  AnalysisId,\n  ConstrainedBidPathHash,\n  Generation,\n  GenerationId,\n  getBidPathHash,\n  newAnalysisId,\n  newGenerationId,\n} from \"../model/job\";\nimport { SerializedBidPath, serializedBidPathL } from \"../model/serialization\";\nimport { Path, Paths } from \"../model/system\";\nimport { ConstrainedBid } from \"../model/system/core\";\nimport { scheduleJob } from \"../reducers/generator\";\nimport {\n  addAnalysis,\n  deleteAnalysis,\n  selectAllAnalyses,\n  selectAnalysis,\n  selectAnalysisById,\n  selectGenerationByAnalysis,\n  selectSelectedAnalysis,\n  setAnalysisName,\n} from \"../reducers/profile\";\nimport { selectValidConstrainedBidPaths } from \"../reducers/system\";\nimport { getDealsWithSolutionsByPath } from \"../services/idb\";\nimport SolutionStats from \"./stats/SolutionStats\";\nimport StatsPath from \"./stats/StatsPath\";\nimport StatsDetails from \"./stats/StatsDetails\";\nimport BidPath from \"./core/BidPath\";\n\nconst FlexList = styled.ul`\n  display: flex;\n  flex-flow: row wrap;\n  list-style-type: none;\n  padding: 0px;\n  margin: 0px;\n`;\nconst FlexListItem = styled.li`\n  padding: 0px;\n  margin: 5px;\n`;\n\ninterface AnalysisProps {\n  analysisId: AnalysisId;\n}\nconst AnalysisView = ({ analysisId }: AnalysisProps) => {\n  const analysis = useAppSelector((state) =>\n    pipe(selectAnalysisById({ state: state.profile, analysisId }), O.toNullable)\n  );\n  const dispatch = useAppDispatch();\n  const dealCount = !analysis\n    ? 0\n    : pipe(\n        analysis.generations,\n        RA.foldMap(number.MonoidSum)((g) => g.dealCount)\n      );\n  const onRemoveClick = useCallback(\n    () => dispatch(deleteAnalysis(analysisId)),\n    [analysisId, dispatch]\n  );\n  const onSelectClick = useCallback(\n    () => dispatch(selectAnalysis(analysisId)),\n    [analysisId, dispatch]\n  );\n  const onNameChange = useCallback(\n    (name) => dispatch(setAnalysisName(analysisId, name)),\n    [analysisId, dispatch]\n  );\n  return (\n    <>\n      {analysis && (\n        <FlexListItem>\n          <input\n            type=\"text\"\n            value={analysis.name}\n            onChange={(e) => onNameChange(e.target.value)}\n          />\n          <p>\n            Paths: {analysis.paths.length} <br />\n            Deals: {dealCount}{\" \"}\n            <small>({analysis.generations.length} generations)</small>\n            <br />\n          </p>\n          <Button onClick={onSelectClick}>Select</Button>\n          <Button onClick={onRemoveClick}>Remove</Button>\n        </FlexListItem>\n      )}\n    </>\n  );\n};\n\ninterface StatsPathItemProps {\n  generationId: GenerationId;\n  analysisId: AnalysisId;\n  path: SerializedBidPath;\n  pathHash: ConstrainedBidPathHash;\n  count: number;\n}\nconst StatsPathItem = ({\n  path,\n  count,\n  generationId,\n  analysisId,\n  pathHash,\n}: StatsPathItemProps) => {\n  const generation = useAppSelector((state) =>\n    pipe(\n      selectGenerationByAnalysis({\n        state: state.profile,\n        analysisId,\n        generationId,\n      }),\n      O.toNullable\n    )\n  );\n  const dispatch = useAppDispatch();\n  const solve = useCallback(\n    () =>\n      pipe(\n        getDealsWithSolutionsByPath(generationId, pathHash),\n        TE.map(\n          flow(\n            RR.filter((d) => O.isNone(d.solution)),\n            RR.map((d) => d.deal),\n            RR.toReadonlyArray,\n            RA.map(readonlyTuple.snd),\n            (deals) =>\n              dispatch(\n                scheduleJob({\n                  analysisId: analysisId,\n                  type: \"Solve\",\n                  parameter: deals,\n                  context: { generationId: generationId, bidPath: path },\n                  estimatedUnitsInitial: deals.length,\n                })\n              )\n          )\n        )\n      )(),\n    [analysisId, dispatch, generationId, path, pathHash]\n  );\n  return (\n    <>\n      {generation && (\n        <>\n          {/* Contained in CSS grid, so make sure the node count is consistent with StatsPathContainer CSS */}\n          <StatsPath\n            path={path}\n            satisfiesCount={count}\n            dealCount={generation.dealCount}\n          />\n          <StatsModal path={path} generation={generation} solve={solve} />\n        </>\n      )}\n    </>\n  );\n};\n\ninterface StatsModelProps {\n  path: SerializedBidPath;\n  generation: Generation;\n  solve: () => void;\n}\nconst StatsModal = ({ path, generation, solve }: StatsModelProps) => {\n  const [showDetails, setShowDetails] = useState<boolean>(false);\n  const onShowClick = useCallback(\n    (open: boolean) => {\n      if (open) {\n        solve();\n      }\n      setShowDetails(open);\n    },\n    [solve]\n  );\n  return (\n    <>\n      <Dialog\n        modalType=\"modal\"\n        open={showDetails}\n        onOpenChange={(__, data) => onShowClick(data.open)}\n      >\n        <DialogTrigger>\n          <Button>Details...</Button>\n        </DialogTrigger>\n        <DialogSurface>\n          <DialogBody>\n            <DialogTitle>\n              Solution Details -{\" \"}\n              <BidPath path={serializedBidPathL.reverseGet(path)} />\n            </DialogTitle>\n            <StatsDetails\n              path={path}\n              generation={generation}\n              onClose={() => setShowDetails(false)}\n            />\n            <DialogActions>\n              <DialogTrigger disableButtonEnhancement>\n                <Button appearance=\"secondary\">Close</Button>\n              </DialogTrigger>\n            </DialogActions>\n          </DialogBody>\n        </DialogSurface>\n      </Dialog>\n    </>\n  );\n};\n\nconst StatsPathContainer = styled.div`\n  clear: both;\n  display: inline-grid;\n  grid-column-gap: 5px;\n  grid-template-columns: auto auto auto;\n  width: auto;\n`;\n\ninterface GenerationViewProps {\n  analysisId: AnalysisId;\n  generationId: GenerationId;\n}\nconst GenerationView = ({ analysisId, generationId }: GenerationViewProps) => {\n  const generation = useAppSelector((state) =>\n    pipe(\n      selectGenerationByAnalysis({\n        state: state.profile,\n        analysisId,\n        generationId,\n      }),\n      O.toNullable\n    )\n  );\n  const satisfies = useMemo(\n    () =>\n      pipe(\n        generation,\n        O.fromNullable,\n        O.chain(get(\"satisfies\")),\n        O.map(RR.toReadonlyArray),\n        O.toNullable\n      ),\n    [generation]\n  );\n  const paths = useAppSelector((state) =>\n    pipe(\n      selectAnalysisById({ state: state.profile, analysisId }),\n      O.map(get(\"paths\")),\n      O.toNullable\n    )\n  );\n\n  const dispatch = useAppDispatch();\n  const onSatisfiesClick = useCallback(\n    () =>\n      generation &&\n      paths &&\n      dispatch(\n        scheduleJob({\n          analysisId: analysisId,\n          type: \"Satisfies\",\n          parameter: paths,\n          context: { generationId: generation.id },\n          estimatedUnitsInitial: paths.length * generation.dealCount,\n        })\n      ),\n    [analysisId, dispatch, generation, paths]\n  );\n\n  const getHash = useCallback(\n    (path: SerializedBidPath) =>\n      pipe(\n        paths,\n        O.fromNullable,\n        O.chain(\n          RA.findFirst(\n            flow(RA.map(get(\"bid\")), (bids) =>\n              RA.getEq(eqBid).equals(bids, serializedBidPathL.reverseGet(path))\n            )\n          )\n        ),\n        O.map(getBidPathHash),\n        O.toNullable\n      ),\n    [paths]\n  );\n\n  return (\n    <>\n      {generation && (\n        <FlexListItem>\n          Deal Count: {generation.dealCount} <br />\n          {satisfies && (\n            <StatsPathContainer>\n              {satisfies.map(([path, count]) => {\n                const pathHash = getHash(path);\n                return (\n                  <Fragment key={path}>\n                    {pathHash && (\n                      <StatsPathItem\n                        key={path}\n                        path={path}\n                        pathHash={pathHash}\n                        count={count}\n                        generationId={generationId}\n                        analysisId={analysisId}\n                      />\n                    )}\n                  </Fragment>\n                );\n              })}\n            </StatsPathContainer>\n          )}\n        </FlexListItem>\n      )}\n    </>\n  );\n};\n\nconst SelectedAnalysis = () => {\n  const analysis = useAppSelector((state) =>\n    pipe(selectSelectedAnalysis(state.profile), O.toNullable)\n  );\n  const generateCount = useAppSelector((state) => state.settings.generateCount);\n\n  const dispatch = useAppDispatch();\n  const onGenerateDealsClick = useCallback(\n    (count: number) => {\n      if (analysis) {\n        dispatch(\n          scheduleJob({\n            analysisId: analysis.id,\n            type: \"GenerateDeals\",\n            context: { generationId: newGenerationId() },\n            parameter: count,\n            estimatedUnitsInitial: count,\n          })\n        );\n      }\n    },\n    [analysis, dispatch]\n  );\n\n  return (\n    <>\n      {analysis && (\n        <div>\n          <h4>{analysis.name}</h4>\n          <FlexList>\n            {analysis.generations.map((g) => (\n              <GenerationView\n                key={g.id}\n                analysisId={analysis.id}\n                generationId={g.id}\n              />\n            ))}\n          </FlexList>\n          <Button onClick={() => onGenerateDealsClick(generateCount)}>\n            Generate Deals\n          </Button>\n        </div>\n      )}\n    </>\n  );\n};\n\ninterface NewAnalysisProps {\n  paths: ReadonlyNonEmptyArray<Path<ConstrainedBid>>;\n  onSubmitOrClose: () => void;\n}\nconst NewAnalysis = ({ paths, onSubmitOrClose }: NewAnalysisProps) => {\n  const dispatch = useAppDispatch();\n  const onGoClick = useCallback(\n    (name: string, count: number, paths: Paths<ConstrainedBid>) => {\n      onSubmitOrClose();\n      dispatch(addAnalysis({ id: newAnalysisId(), name, count, paths }));\n    },\n    [dispatch, onSubmitOrClose]\n  );\n  const defaultCount = useAppSelector(\n    (state) => state.settings[\"generateCount\"]\n  );\n  const [name, setName] = useState<string>(\n    `New analysis (${paths.length} paths)`\n  );\n  const [count, setCount] = useState<number>(defaultCount);\n  return (\n    <DialogContent>\n      <p>\n        Name{\" \"}\n        <input\n          type=\"text\"\n          value={name}\n          onChange={(e) => setName(e.target.value)}\n        />\n        <br />\n        Hands to Generate{\" \"}\n        <input\n          type=\"number\"\n          value={count}\n          onChange={(e) => pipe(e.target.value, parseInt, setCount)}\n          style={{ width: \"100px\" }}\n        />\n      </p>\n      <DialogActions>\n        <DialogTrigger disableButtonEnhancement>\n          <Button appearance=\"secondary\">Close</Button>\n        </DialogTrigger>\n        <Button\n          appearance=\"primary\"\n          disabled={!paths}\n          onClick={() => onGoClick(name, count, paths)}\n        >\n          Go\n        </Button>\n      </DialogActions>\n    </DialogContent>\n  );\n};\n\nconst Analyses = () => {\n  const [newAnalysis, setNewAnalysis] = useState<boolean>(false);\n  const paths = useAppSelector((state) =>\n    pipe(\n      selectValidConstrainedBidPaths({\n        state: state.system,\n        options: state.settings,\n      }),\n      O.toNullable\n    )\n  );\n  return (\n    <section>\n      <h3>Analyses</h3>\n      <SelectedAnalysis />\n      {paths && (\n        <>\n          <Dialog\n            modalType=\"modal\"\n            open={newAnalysis}\n            onOpenChange={(__, data) => setNewAnalysis(data.open)}\n          >\n            <DialogTrigger>\n              <Button>Start...</Button>\n            </DialogTrigger>\n            <DialogSurface>\n              <DialogBody>\n                <DialogTitle>New Analysis</DialogTitle>\n                <NewAnalysis\n                  paths={paths}\n                  onSubmitOrClose={() => setNewAnalysis(false)}\n                />\n              </DialogBody>\n            </DialogSurface>\n          </Dialog>\n        </>\n      )}\n    </section>\n  );\n};\n\nexport default Analyses;\n","import { Button } from '@fluentui/react-components';\nimport { option as O } from 'fp-ts';\nimport { flow, pipe } from 'fp-ts/lib/function';\nimport { useCallback, useMemo } from 'react';\nimport TimeAgo from 'react-timeago';\nimport styled from 'styled-components';\n\nimport { useAppDispatch, useAppSelector } from '../app/hooks';\nimport { get } from '../lib/object';\nimport { DateNumber, DateNumberB, estimatedTimeRemaining, getGenericProgress, Job, now, ProgressData } from '../model/job';\nimport { removeJob, startJob } from '../reducers/generator';\n\ninterface DateViewProps {\n  date: O.Option<DateNumber> | DateNumber | null\n}\nconst DateView = ({ date }: DateViewProps) => {\n  const value =\n    !date ? null :\n      typeof date === \"number\" ? date :\n        date._tag === \"Some\" ? date.value :\n          null\n  return <>{value && <TimeAgo date={(new Date(value))} />}</>\n}\n\nconst JobList = styled.ul`\n  display: flex;\n  flex-flow: row wrap;\n  list-style-type: none;\n  padding: 0px;\n  margin: 0px;\n`\nconst JobListItem = styled.li`\n  padding: 0px;\n  margin: 5px;\n`\n\ninterface ProgressViewProps {\n  start: DateNumber\n  unitsInitial: number\n  progress: ProgressData\n}\nconst ProgressView = ({ progress, unitsInitial, start }: ProgressViewProps) => {\n  const timeRemaining = useMemo(() => pipe(\n    progress,\n    estimatedTimeRemaining(unitsInitial),\n    O.map(r => now() + r),\n    O.chain(flow(DateNumberB.decode, O.fromEither)),\n    O.toNullable)\n    , [progress, unitsInitial])\n  return (\n    <p>\n      Started: <DateView date={start} /><br />\n      Last Updated: <DateView date={progress.updateDate} /> <br />\n      Progress: {unitsInitial - progress.unitsDone} units remaining ({Math.floor(progress.unitsDone * 100 / unitsInitial)}%) <br />\n      Est. Completion: <DateView date={timeRemaining} />\n    </p>\n  )\n}\n\ninterface JobViewProps {\n  job: Job\n}\nconst JobView = ({ job }: JobViewProps) => {\n  const progress = pipe(job,\n    getGenericProgress,\n    O.toNullable)\n  const startDate = pipe(job,\n    get(\"startDate\"),\n    O.toNullable)\n  const dispatch = useAppDispatch()\n  const onRemoveClick = useCallback(() => job && dispatch(removeJob(job.id)), [dispatch, job])\n  const onStartClick = useCallback(() => job && dispatch(startJob({ jobId: job.id, type: job.type })), [dispatch, job])\n  return (<>{job &&\n    <JobListItem>\n      <h5>{job.type}</h5>\n      {!progress && <p>\n        Estimated Units: {job.unitsInitial} <br />\n        <Button onClick={onStartClick}>Start</Button>\n        <Button onClick={onRemoveClick}>Remove</Button>\n      </p>}\n      {progress && startDate && <ProgressView progress={progress} unitsInitial={job.unitsInitial} start={startDate} />}\n    </JobListItem>\n  }</>)\n}\n\nconst Jobs = () => {\n  const jobs = useAppSelector(state => state.generator.jobs)\n  return (\n    <section>\n      {/* <h3>Jobs</h3> */}\n      <JobList>\n        {jobs.map(j => <JobView key={j.id} job={j} />)}\n      </JobList>\n    </section>\n  )\n}\n\nexport default Jobs","import Analyses from \"./Analyses\"\nimport Editor from \"./Editor\"\nimport Jobs from \"./Jobs\"\n\nconst Analyze = () => {\n  return (\n    <>\n      <div style={{ clear: 'both', display: \"inline-block\", width: '50%' }}>\n        <div style={{ float: \"left\" }}>\n          <Editor />\n        </div>\n        <div style={{ clear: \"both\" }}>\n          <Jobs />\n          {/* <Stats /> */}\n        </div>\n      </div>\n      <div style={{ display: \"inline-block\", width: '50%', float: \"right\" }}>\n        <Analyses />\n      </div>\n    </>\n  )\n}\n\nexport default Analyze","import './index.css';\n\nimport * as serviceWorker from './serviceWorker';\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport { createBrowserRouter, RouterProvider } from 'react-router-dom';\nimport { store } from './app/store';\nimport App from './components';\nimport Design from './components/Design';\nimport Analyze from './components/Analyze';\nimport { FluentProvider, teamsLightTheme, } from '@fluentui/react-components';\n\nconst router = createBrowserRouter([\n  {\n    path: \"/\", element: <App />, children: [\n      { path: \"/design\", element: <Design /> },\n      { path: \"/analyze\", element: <Analyze /> },\n    ]\n  },\n], {\n  basename: \"/bridge\"\n})\n\nReactDOM.render(\n  <React.StrictMode>\n    <FluentProvider theme={teamsLightTheme}>\n      <Provider store={store}>\n        <RouterProvider router={router} />\n      </Provider>\n    </FluentProvider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}