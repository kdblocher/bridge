{"version":3,"sources":["serviceWorker.ts","model/deck.ts","parse/bid.peg.g.ts","model/bridge.ts","parse/hand.peg.g.ts","parse/bid.ts","parse/hand.ts","parse/index.ts","reducers/system.ts","model/constraints.ts","reducers/selection.ts","app/hooks.ts","components/Editor.tsx","reducers/index.ts","components/SelectionDetails.tsx","components/index.tsx","app/store.ts","index.tsx"],"names":["Boolean","window","location","hostname","match","nextRandom","ASTKinds","suits","Math","random","eqSuit","eq","eqStrict","ordSuit","pipe","number","Ord","ord","reverse","contramap","x","indexOf","ranks","RankB","t","i","RankC","is","validate","r","eqRank","ordRank","eqCard","struct","suit","rank","ordCard","getMonoid","concat","c","zeroGroupedHand","Array","map","_","decode","right","S","H","D","C","strains","zeroShape","apply","sequenceS","readonlyArray","Apply","level","makeBy","strain","sortShape","s","sort","makeShape","counts","eqShape","getEq","Eq","zeroSpecificShape","getHandSpecificShape","hand","readonlySet","toReadonlyArray","readonlyNonEmptyArray","fromReadonlyArray","option","fold","flow","groupBy","readonlyRecord","length","union","first","Digit","literal","kind","value","this","parseInt","Number","Parser","input","pos","negating","memoSafe","$scope$Constraint$memo","Map","overallPos","line","offset","clear","$$dpth","$$cr","run","$scope$bid","$$res","matchBid","match$EOF","Start","bid","$scope$level","$scope$constraints","matchDigit","matchBidSpecifier","regexAccept","String","raw","matchConstraintList","Bid","constraints","choice","matchBidSpecifier_1","matchBidSpecifier_2","matchWildcard","matchSuitSpecifier","$scope$v","Wildcard","v","matchSuitSpecifier_1","matchSuitSpecifier_2","matchSuitSpecifier_3","matchMajor","matchMinor","matchStrain","Major","Minor","matchStrain_1","matchStrain_2","matchSuit","matchNotrump","matchSuit_1","matchSuit_2","matchSuit_3","matchSuit_4","matchClub","matchDiamond","matchHeart","matchSpade","Club","Diamond","Heart","Spade","Notrump","loop","matchConstraintListItem","$scope$constraint","matchConstraint","ConstraintListItem","constraint","$scope$pos","mark","memo","get","undefined","reset","$scope$oldMemoSafe","set","lastRes","lastPos","res","matchConstraint_1","matchConstraint_2","matchConstraint_3","matchConstraint_4","matchConstraint_5","matchConstraint_6","matchConstraint_7","matchConstraint_8","end","matchConstraintAnd","matchConstraintOr","matchDistribution","matchResponse","matchSuitRange","matchSuitBound","matchPointRange","matchPointBound","$scope$left","$scope$right","matchConstraintOr_$0","ConstraintOr","left","matchConstraintOr_$0_1","matchConstraintOr_$0_2","ConstraintAnd","$scope$lower","$scope$upper","matchNumber","PointRange","lower","upper","$scope$value","$scope$qualifier","matchBoundQualifier","PointBound","qualifier","$scope$suit","matchSuitRangeSpecifier","SuitRange","SuitBound","matchSuitRangeSpecifier_1","matchSuitRangeSpecifier_2","matchSuitRangeSpecifier_3","OtherMajor","OtherMinor","matchBoundQualifier_1","matchBoundQualifier_2","matchBoundQualifier_3","matchPlus","matchMinus","matchEquals","Plus","Minus","matchEquals_1","matchEquals_2","Equals_1","Equals_2","matchDistribution_1","matchDistribution_2","matchDistribution_3","matchDistribution_4","matchBalanced","matchSemiBalanced","matchUnbalanced","matchShape","Balanced","SemiBalanced","Unbalanced","$scope$S","$scope$H","$scope$D","$scope$C","Shape","matchResponse_1","matchResponse_2","matchResponse_3","matchResponse_4","matchForceOneRound","matchForceGame","matchForceSlam","matchRelay","ForceOneRound","ForceGame","ForceSlam","$scope$strain","Relay","$scope$literal","mrk","ans","matchStart","ast","errs","rec","ErrorTracker","clearMemos","err","getErr","func","star","push","fn","fns","f","dpth","cr","reg","RegExp","lastIndex","tryConsume","record","substring","negated","exec","lineJmp","lind","oneg","rule","$scope$memoRes","$scope$result","et","finished","$EOF","SyntaxErr","expmatches","mxpos","regexset","Set","pmatches","result","att","has","add","constraintFromAST","suitFromAST","AST","strainFromAST","suitSpecifierFromAST","type","flatten","min","max","mapWithIndex","parseBid","parse","Card","$scope$hand","matchHand","Hand","$scope$cards","matchCard","Suit","cards","$scope$c","handFromAST","card","parseHand","convertErrors","constant","d","foldMapWithIndex","FS","DE","toString","parseResultToEither","either","fromNullable","getDecoder","parser","mapLeft","decodeBid","decodeHand","getRoot","tree","make","text","initialState","system","getPath","blockKey","node","path","some","findFirstMap","identity","prepend","chain","tail","reduce","items","a","append","slice","createSlice","name","reducers","setSystem","state","action","root","parents","forEach","item","curr","depth","key","forest","buildTree","payload","castDraft","actions","selectErrors","n","compact","separate","separated","getCardHcp","getHcp","foldMap","MonoidSum","isShape","shape","equals","readonlyTuple","snd","suitCounts","idx","lookup","getOrElse","getHandShape","isBalanced","exists","isSemiBalanced","satisfies","every","between","range","getSuitsToCheck","isSuitRange","isSpecificShape","selectedBlockKey","none","setSelectedBlockKey","setHand","reducer","meta","prepare","useAppDispatch","useDispatch","useAppSelector","useSelector","Editor","React","useState","EditorState","createEmpty","editorState","setEditorState","dispatch","onChange","useCallback","getCurrentContent","getBlockMap","toArray","getKey","getText","getDepth","getItemsFromBlocks","getSelection","getFocusKey","useEffect","RichUtils","toggleBlockType","keyBindingFn","e","keyCode","newEditorState","onTab","getDefaultKeyBinding","alternate","selection","opener","responder","unfold","g","val","next","done","walkNodesWithHands","bids","zip","selectHandsSatisfySelectedPath","Do","apS","o","sequence","Applicative","selectBids","fromEither","toNullable","Decode","onSuccess","children","onError","draw","HandInput","setValue","onSetHand","placeholder","target","RankList","styled","ol","RankListItem","li","Rank","Deck","HandCol","th","SuitList","SuitListItem","className","groupedHand","getUnionMonoid","SelectionDetails","selected","selectPath","last","selectNode","errors","join","JSON","stringify","App","style","display","width","store","configureStore","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.0ddb1680.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import { either, eq, number, option, ord, readonlyArray, readonlyNonEmptyArray, readonlyRecord, readonlySet } from 'fp-ts';\nimport { flow, pipe } from 'fp-ts/lib/function';\nimport * as t from 'io-ts';\n\nexport const shuffle = (nextRandom: () => number) => <T>(array: T[]): readonly T[] => {\n  for (let i = 0; i < array.length; i++) {\n    const r = i + (nextRandom() * (array.length - 1 - i));\n    [array[i], array[r]] = [array[r], array[i]]\n  }\n  return array;\n}\n\nexport const basicShuffle = shuffle(Math.random)\n\nexport type Suit = 'C' | 'D' | 'H' | 'S'\nexport const suits = ['C', 'D', 'H', 'S'] as const\nexport const eqSuit : eq.Eq<Suit> = eq.eqStrict\nexport const ordSuit : ord.Ord<Suit> = pipe(number.Ord, ord.reverse, ord.contramap(x => suits.indexOf(x)))\n\nexport const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'] as const\nconst RankB = t.brand(t.number, (i) : i is t.Branded<number, { readonly Rank: unique symbol }> => i >= 2 && i <= 14, 'Rank')\nexport const RankC = new t.Type('Rank', RankB.is, RankB.validate, r => ranks[r - 2])\nexport type Rank = t.TypeOf<typeof RankC>\nexport const eqRank : eq.Eq<Rank> = eq.eqStrict\nexport const ordRank : ord.Ord<Rank> = pipe(number.Ord, ord.reverse)\n\nexport interface Card {\n  suit: Suit\n  rank: Rank\n}\nexport const cardToString = (c: Card) =>\n  `${c.suit}${RankC.encode(c.rank)}`\nexport const eqCard : eq.Eq<Card> = eq.struct({\n  suit: eqSuit,\n  rank: eqRank\n})\nexport const ordCard : ord.Ord<Card> = ord.getMonoid<Card>().concat(\n  pipe(ordSuit, ord.contramap(c => c.suit)),\n  pipe(ordRank, ord.contramap(c => c.rank))\n)\n\nexport const cards: readonly Card[] = Array(52).map<Card>((_, i) => ({\n  suit: suits[i / 13],\n  rank: (RankC.decode(i % 13) as either.Right<Rank>).right\n}))\n\nexport type Hand = ReadonlySet<Card>\nexport type GroupedHand = readonlyRecord.ReadonlyRecord<Suit, ReadonlyArray<Rank>>\nexport const getOrdGroupedHand = <T>() =>\n  ord.contramap(([suit, _]: readonly [Suit, T]) => suit)(ordSuit)\nexport const zeroGroupedHand : GroupedHand = ({\n  S: [],\n  H: [],\n  D: [],\n  C: [],\n})\n\nexport const groupHandBySuits = (hand: Hand) : GroupedHand =>\n  pipe(hand,\n    readonlySet.toReadonlyArray(ordCard),\n    readonlyNonEmptyArray.fromReadonlyArray,\n    option.fold(() => zeroGroupedHand, flow(\n      readonlyNonEmptyArray.groupBy(c => c.suit),\n      readonlyRecord.map(readonlyNonEmptyArray.map(c => c.rank)),\n      readonlyRecord.union(readonlyArray.getUnionMonoid(eqRank))(zeroGroupedHand)\n    )))\n\nexport type Deck = readonly Card[]\n\nexport const newDeck = () : Deck =>\n  basicShuffle([...cards])","/* AutoGenerated Code, changes may be overwritten\n* INPUT GRAMMAR:\n* Start := bid=Bid $\n* Bid := level=Digit bid=BidSpecifier ': ' constraints=ConstraintList\n* BidSpecifier := Wildcard | SuitSpecifier\n* Wildcard := v='x'\n* SuitSpecifier := Major | Minor | Strain\n* Major := v='M'\n* Minor := v='m'\n* Strain := Suit | Notrump\n* Suit := Club | Diamond | Heart | Spade\n* Club := v='[Cc]'\n* Diamond := v='[Dd]'\n* Heart := v='[Hh]'\n* Spade := v='[Ss]'\n* Notrump := v='[Nn]' '[Tt]'?\n* ConstraintList := ConstraintListItem+\n* ConstraintListItem := constraint=Constraint ' '?\n* Constraint := ConstraintAnd | ConstraintOr | Distribution | Response | SuitRange | SuitBound | PointRange | PointBound \n* ConstraintOr := left=Constraint {' or ' | ' / '} right=Constraint\n* ConstraintAnd := '\\(' constraints=ConstraintList '\\)'\n* PointRange := lower=Number '-' upper=Number\n* PointBound := value=Number qualifier=BoundQualifier\n* SuitRange := lower=Digit '-' upper=Digit suit=SuitRangeSpecifier\n* SuitBound := value=Number qualifier=BoundQualifier suit=SuitRangeSpecifier\n* SuitRangeSpecifier := Major | Minor | Suit //| OtherMajor | OtherMinor\n* OtherMajor := v='oM'\n* OtherMinor := v='om'\n* BoundQualifier := Plus | Minus | Equals\n* Plus := v='\\+'\n* Minus := v='\\-'\n* Equals := v='=' | v=''\n* Distribution := Balanced | SemiBalanced | Unbalanced | Shape\n* Balanced := v='BAL'\n* SemiBalanced := v='semiBAL'\n* Unbalanced := v='unBAL'\n* Shape := S=Digit H=Digit D=Digit C=Digit\n* Response := ForceOneRound | ForceGame | ForceSlam | Relay\n* ForceOneRound := v='F1'\n* ForceGame := v='FG'\n* ForceSlam := v='FS'\n* Relay := level=Number strain=Strain\n* Digit := literal='[0-9]'\n*   .value = number { return parseInt(literal) }\n* Number := literal='[0-9]+'\n*   .value = number { return parseInt(literal) }\n*/\ntype Nullable<T> = T | null;\ntype $$RuleType<T> = () => Nullable<T>;\ninterface ASTNodeIntf {\n    kind: ASTKinds;\n}\nexport enum ASTKinds {\n    Start = \"Start\",\n    Bid = \"Bid\",\n    BidSpecifier_1 = \"BidSpecifier_1\",\n    BidSpecifier_2 = \"BidSpecifier_2\",\n    Wildcard = \"Wildcard\",\n    SuitSpecifier_1 = \"SuitSpecifier_1\",\n    SuitSpecifier_2 = \"SuitSpecifier_2\",\n    SuitSpecifier_3 = \"SuitSpecifier_3\",\n    Major = \"Major\",\n    Minor = \"Minor\",\n    Strain_1 = \"Strain_1\",\n    Strain_2 = \"Strain_2\",\n    Suit_1 = \"Suit_1\",\n    Suit_2 = \"Suit_2\",\n    Suit_3 = \"Suit_3\",\n    Suit_4 = \"Suit_4\",\n    Club = \"Club\",\n    Diamond = \"Diamond\",\n    Heart = \"Heart\",\n    Spade = \"Spade\",\n    Notrump = \"Notrump\",\n    ConstraintList = \"ConstraintList\",\n    ConstraintListItem = \"ConstraintListItem\",\n    Constraint_1 = \"Constraint_1\",\n    Constraint_2 = \"Constraint_2\",\n    Constraint_3 = \"Constraint_3\",\n    Constraint_4 = \"Constraint_4\",\n    Constraint_5 = \"Constraint_5\",\n    Constraint_6 = \"Constraint_6\",\n    Constraint_7 = \"Constraint_7\",\n    Constraint_8 = \"Constraint_8\",\n    ConstraintOr = \"ConstraintOr\",\n    ConstraintOr_$0_1 = \"ConstraintOr_$0_1\",\n    ConstraintOr_$0_2 = \"ConstraintOr_$0_2\",\n    ConstraintAnd = \"ConstraintAnd\",\n    PointRange = \"PointRange\",\n    PointBound = \"PointBound\",\n    SuitRange = \"SuitRange\",\n    SuitBound = \"SuitBound\",\n    SuitRangeSpecifier_1 = \"SuitRangeSpecifier_1\",\n    SuitRangeSpecifier_2 = \"SuitRangeSpecifier_2\",\n    SuitRangeSpecifier_3 = \"SuitRangeSpecifier_3\",\n    OtherMajor = \"OtherMajor\",\n    OtherMinor = \"OtherMinor\",\n    BoundQualifier_1 = \"BoundQualifier_1\",\n    BoundQualifier_2 = \"BoundQualifier_2\",\n    BoundQualifier_3 = \"BoundQualifier_3\",\n    Plus = \"Plus\",\n    Minus = \"Minus\",\n    Equals_1 = \"Equals_1\",\n    Equals_2 = \"Equals_2\",\n    Distribution_1 = \"Distribution_1\",\n    Distribution_2 = \"Distribution_2\",\n    Distribution_3 = \"Distribution_3\",\n    Distribution_4 = \"Distribution_4\",\n    Balanced = \"Balanced\",\n    SemiBalanced = \"SemiBalanced\",\n    Unbalanced = \"Unbalanced\",\n    Shape = \"Shape\",\n    Response_1 = \"Response_1\",\n    Response_2 = \"Response_2\",\n    Response_3 = \"Response_3\",\n    Response_4 = \"Response_4\",\n    ForceOneRound = \"ForceOneRound\",\n    ForceGame = \"ForceGame\",\n    ForceSlam = \"ForceSlam\",\n    Relay = \"Relay\",\n    Digit = \"Digit\",\n    Number = \"Number\",\n    $EOF = \"$EOF\",\n}\nexport interface Start {\n    kind: ASTKinds.Start;\n    bid: Bid;\n}\nexport interface Bid {\n    kind: ASTKinds.Bid;\n    level: Digit;\n    bid: BidSpecifier;\n    constraints: ConstraintList;\n}\nexport type BidSpecifier = BidSpecifier_1 | BidSpecifier_2;\nexport type BidSpecifier_1 = Wildcard;\nexport type BidSpecifier_2 = SuitSpecifier;\nexport interface Wildcard {\n    kind: ASTKinds.Wildcard;\n    v: string;\n}\nexport type SuitSpecifier = SuitSpecifier_1 | SuitSpecifier_2 | SuitSpecifier_3;\nexport type SuitSpecifier_1 = Major;\nexport type SuitSpecifier_2 = Minor;\nexport type SuitSpecifier_3 = Strain;\nexport interface Major {\n    kind: ASTKinds.Major;\n    v: string;\n}\nexport interface Minor {\n    kind: ASTKinds.Minor;\n    v: string;\n}\nexport type Strain = Strain_1 | Strain_2;\nexport type Strain_1 = Suit;\nexport type Strain_2 = Notrump;\nexport type Suit = Suit_1 | Suit_2 | Suit_3 | Suit_4;\nexport type Suit_1 = Club;\nexport type Suit_2 = Diamond;\nexport type Suit_3 = Heart;\nexport type Suit_4 = Spade;\nexport interface Club {\n    kind: ASTKinds.Club;\n    v: string;\n}\nexport interface Diamond {\n    kind: ASTKinds.Diamond;\n    v: string;\n}\nexport interface Heart {\n    kind: ASTKinds.Heart;\n    v: string;\n}\nexport interface Spade {\n    kind: ASTKinds.Spade;\n    v: string;\n}\nexport interface Notrump {\n    kind: ASTKinds.Notrump;\n    v: string;\n}\nexport type ConstraintList = ConstraintListItem[];\nexport interface ConstraintListItem {\n    kind: ASTKinds.ConstraintListItem;\n    constraint: Constraint;\n}\nexport type Constraint = Constraint_1 | Constraint_2 | Constraint_3 | Constraint_4 | Constraint_5 | Constraint_6 | Constraint_7 | Constraint_8;\nexport type Constraint_1 = ConstraintAnd;\nexport type Constraint_2 = ConstraintOr;\nexport type Constraint_3 = Distribution;\nexport type Constraint_4 = Response;\nexport type Constraint_5 = SuitRange;\nexport type Constraint_6 = SuitBound;\nexport type Constraint_7 = PointRange;\nexport type Constraint_8 = PointBound;\nexport interface ConstraintOr {\n    kind: ASTKinds.ConstraintOr;\n    left: Constraint;\n    right: Constraint;\n}\nexport type ConstraintOr_$0 = ConstraintOr_$0_1 | ConstraintOr_$0_2;\nexport type ConstraintOr_$0_1 = string;\nexport type ConstraintOr_$0_2 = string;\nexport interface ConstraintAnd {\n    kind: ASTKinds.ConstraintAnd;\n    constraints: ConstraintList;\n}\nexport interface PointRange {\n    kind: ASTKinds.PointRange;\n    lower: Number;\n    upper: Number;\n}\nexport interface PointBound {\n    kind: ASTKinds.PointBound;\n    value: Number;\n    qualifier: BoundQualifier;\n}\nexport interface SuitRange {\n    kind: ASTKinds.SuitRange;\n    lower: Digit;\n    upper: Digit;\n    suit: SuitRangeSpecifier;\n}\nexport interface SuitBound {\n    kind: ASTKinds.SuitBound;\n    value: Number;\n    qualifier: BoundQualifier;\n    suit: SuitRangeSpecifier;\n}\nexport type SuitRangeSpecifier = SuitRangeSpecifier_1 | SuitRangeSpecifier_2 | SuitRangeSpecifier_3;\nexport type SuitRangeSpecifier_1 = Major;\nexport type SuitRangeSpecifier_2 = Minor;\nexport type SuitRangeSpecifier_3 = Suit;\nexport interface OtherMajor {\n    kind: ASTKinds.OtherMajor;\n    v: string;\n}\nexport interface OtherMinor {\n    kind: ASTKinds.OtherMinor;\n    v: string;\n}\nexport type BoundQualifier = BoundQualifier_1 | BoundQualifier_2 | BoundQualifier_3;\nexport type BoundQualifier_1 = Plus;\nexport type BoundQualifier_2 = Minus;\nexport type BoundQualifier_3 = Equals;\nexport interface Plus {\n    kind: ASTKinds.Plus;\n    v: string;\n}\nexport interface Minus {\n    kind: ASTKinds.Minus;\n    v: string;\n}\nexport type Equals = Equals_1 | Equals_2;\nexport interface Equals_1 {\n    kind: ASTKinds.Equals_1;\n    v: string;\n}\nexport interface Equals_2 {\n    kind: ASTKinds.Equals_2;\n    v: string;\n}\nexport type Distribution = Distribution_1 | Distribution_2 | Distribution_3 | Distribution_4;\nexport type Distribution_1 = Balanced;\nexport type Distribution_2 = SemiBalanced;\nexport type Distribution_3 = Unbalanced;\nexport type Distribution_4 = Shape;\nexport interface Balanced {\n    kind: ASTKinds.Balanced;\n    v: string;\n}\nexport interface SemiBalanced {\n    kind: ASTKinds.SemiBalanced;\n    v: string;\n}\nexport interface Unbalanced {\n    kind: ASTKinds.Unbalanced;\n    v: string;\n}\nexport interface Shape {\n    kind: ASTKinds.Shape;\n    S: Digit;\n    H: Digit;\n    D: Digit;\n    C: Digit;\n}\nexport type Response = Response_1 | Response_2 | Response_3 | Response_4;\nexport type Response_1 = ForceOneRound;\nexport type Response_2 = ForceGame;\nexport type Response_3 = ForceSlam;\nexport type Response_4 = Relay;\nexport interface ForceOneRound {\n    kind: ASTKinds.ForceOneRound;\n    v: string;\n}\nexport interface ForceGame {\n    kind: ASTKinds.ForceGame;\n    v: string;\n}\nexport interface ForceSlam {\n    kind: ASTKinds.ForceSlam;\n    v: string;\n}\nexport interface Relay {\n    kind: ASTKinds.Relay;\n    level: Number;\n    strain: Strain;\n}\nexport class Digit {\n    public kind: ASTKinds.Digit = ASTKinds.Digit;\n    public literal: string;\n    public value: number;\n    constructor(literal: string){\n        this.literal = literal;\n        this.value = ((): number => {\n        return parseInt(literal)\n        })();\n    }\n}\nexport class Number {\n    public kind: ASTKinds.Number = ASTKinds.Number;\n    public literal: string;\n    public value: number;\n    constructor(literal: string){\n        this.literal = literal;\n        this.value = ((): number => {\n        return parseInt(literal)\n        })();\n    }\n}\nexport class Parser {\n    private readonly input: string;\n    private pos: PosInfo;\n    private negating: boolean = false;\n    private memoSafe: boolean = true;\n    constructor(input: string) {\n        this.pos = {overallPos: 0, line: 1, offset: 0};\n        this.input = input;\n    }\n    public reset(pos: PosInfo) {\n        this.pos = pos;\n    }\n    public finished(): boolean {\n        return this.pos.overallPos === this.input.length;\n    }\n    public clearMemos(): void {\n        this.$scope$Constraint$memo.clear();\n    }\n    protected $scope$Constraint$memo: Map<number, [Nullable<Constraint>, PosInfo]> = new Map();\n    public matchStart($$dpth: number, $$cr?: ErrorTracker): Nullable<Start> {\n        return this.run<Start>($$dpth,\n            () => {\n                let $scope$bid: Nullable<Bid>;\n                let $$res: Nullable<Start> = null;\n                if (true\n                    && ($scope$bid = this.matchBid($$dpth + 1, $$cr)) !== null\n                    && this.match$EOF($$cr) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Start, bid: $scope$bid};\n                }\n                return $$res;\n            });\n    }\n    public matchBid($$dpth: number, $$cr?: ErrorTracker): Nullable<Bid> {\n        return this.run<Bid>($$dpth,\n            () => {\n                let $scope$level: Nullable<Digit>;\n                let $scope$bid: Nullable<BidSpecifier>;\n                let $scope$constraints: Nullable<ConstraintList>;\n                let $$res: Nullable<Bid> = null;\n                if (true\n                    && ($scope$level = this.matchDigit($$dpth + 1, $$cr)) !== null\n                    && ($scope$bid = this.matchBidSpecifier($$dpth + 1, $$cr)) !== null\n                    && this.regexAccept(String.raw`(?:: )`, $$dpth + 1, $$cr) !== null\n                    && ($scope$constraints = this.matchConstraintList($$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Bid, level: $scope$level, bid: $scope$bid, constraints: $scope$constraints};\n                }\n                return $$res;\n            });\n    }\n    public matchBidSpecifier($$dpth: number, $$cr?: ErrorTracker): Nullable<BidSpecifier> {\n        return this.choice<BidSpecifier>([\n            () => this.matchBidSpecifier_1($$dpth + 1, $$cr),\n            () => this.matchBidSpecifier_2($$dpth + 1, $$cr),\n        ]);\n    }\n    public matchBidSpecifier_1($$dpth: number, $$cr?: ErrorTracker): Nullable<BidSpecifier_1> {\n        return this.matchWildcard($$dpth + 1, $$cr);\n    }\n    public matchBidSpecifier_2($$dpth: number, $$cr?: ErrorTracker): Nullable<BidSpecifier_2> {\n        return this.matchSuitSpecifier($$dpth + 1, $$cr);\n    }\n    public matchWildcard($$dpth: number, $$cr?: ErrorTracker): Nullable<Wildcard> {\n        return this.run<Wildcard>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Wildcard> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:x)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Wildcard, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchSuitSpecifier($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitSpecifier> {\n        return this.choice<SuitSpecifier>([\n            () => this.matchSuitSpecifier_1($$dpth + 1, $$cr),\n            () => this.matchSuitSpecifier_2($$dpth + 1, $$cr),\n            () => this.matchSuitSpecifier_3($$dpth + 1, $$cr),\n        ]);\n    }\n    public matchSuitSpecifier_1($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitSpecifier_1> {\n        return this.matchMajor($$dpth + 1, $$cr);\n    }\n    public matchSuitSpecifier_2($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitSpecifier_2> {\n        return this.matchMinor($$dpth + 1, $$cr);\n    }\n    public matchSuitSpecifier_3($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitSpecifier_3> {\n        return this.matchStrain($$dpth + 1, $$cr);\n    }\n    public matchMajor($$dpth: number, $$cr?: ErrorTracker): Nullable<Major> {\n        return this.run<Major>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Major> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:M)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Major, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchMinor($$dpth: number, $$cr?: ErrorTracker): Nullable<Minor> {\n        return this.run<Minor>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Minor> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:m)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Minor, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchStrain($$dpth: number, $$cr?: ErrorTracker): Nullable<Strain> {\n        return this.choice<Strain>([\n            () => this.matchStrain_1($$dpth + 1, $$cr),\n            () => this.matchStrain_2($$dpth + 1, $$cr),\n        ]);\n    }\n    public matchStrain_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Strain_1> {\n        return this.matchSuit($$dpth + 1, $$cr);\n    }\n    public matchStrain_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Strain_2> {\n        return this.matchNotrump($$dpth + 1, $$cr);\n    }\n    public matchSuit($$dpth: number, $$cr?: ErrorTracker): Nullable<Suit> {\n        return this.choice<Suit>([\n            () => this.matchSuit_1($$dpth + 1, $$cr),\n            () => this.matchSuit_2($$dpth + 1, $$cr),\n            () => this.matchSuit_3($$dpth + 1, $$cr),\n            () => this.matchSuit_4($$dpth + 1, $$cr),\n        ]);\n    }\n    public matchSuit_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Suit_1> {\n        return this.matchClub($$dpth + 1, $$cr);\n    }\n    public matchSuit_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Suit_2> {\n        return this.matchDiamond($$dpth + 1, $$cr);\n    }\n    public matchSuit_3($$dpth: number, $$cr?: ErrorTracker): Nullable<Suit_3> {\n        return this.matchHeart($$dpth + 1, $$cr);\n    }\n    public matchSuit_4($$dpth: number, $$cr?: ErrorTracker): Nullable<Suit_4> {\n        return this.matchSpade($$dpth + 1, $$cr);\n    }\n    public matchClub($$dpth: number, $$cr?: ErrorTracker): Nullable<Club> {\n        return this.run<Club>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Club> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:[Cc])`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Club, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchDiamond($$dpth: number, $$cr?: ErrorTracker): Nullable<Diamond> {\n        return this.run<Diamond>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Diamond> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:[Dd])`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Diamond, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchHeart($$dpth: number, $$cr?: ErrorTracker): Nullable<Heart> {\n        return this.run<Heart>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Heart> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:[Hh])`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Heart, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchSpade($$dpth: number, $$cr?: ErrorTracker): Nullable<Spade> {\n        return this.run<Spade>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Spade> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:[Ss])`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Spade, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchNotrump($$dpth: number, $$cr?: ErrorTracker): Nullable<Notrump> {\n        return this.run<Notrump>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Notrump> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:[Nn])`, $$dpth + 1, $$cr)) !== null\n                    && ((this.regexAccept(String.raw`(?:[Tt])`, $$dpth + 1, $$cr)) || true)\n                ) {\n                    $$res = {kind: ASTKinds.Notrump, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchConstraintList($$dpth: number, $$cr?: ErrorTracker): Nullable<ConstraintList> {\n        return this.loop<ConstraintListItem>(() => this.matchConstraintListItem($$dpth + 1, $$cr), false);\n    }\n    public matchConstraintListItem($$dpth: number, $$cr?: ErrorTracker): Nullable<ConstraintListItem> {\n        return this.run<ConstraintListItem>($$dpth,\n            () => {\n                let $scope$constraint: Nullable<Constraint>;\n                let $$res: Nullable<ConstraintListItem> = null;\n                if (true\n                    && ($scope$constraint = this.matchConstraint($$dpth + 1, $$cr)) !== null\n                    && ((this.regexAccept(String.raw`(?: )`, $$dpth + 1, $$cr)) || true)\n                ) {\n                    $$res = {kind: ASTKinds.ConstraintListItem, constraint: $scope$constraint};\n                }\n                return $$res;\n            });\n    }\n    public matchConstraint($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint> {\n        const fn = () => {\n            return this.choice<Constraint>([\n                () => this.matchConstraint_1($$dpth + 1, $$cr),\n                () => this.matchConstraint_2($$dpth + 1, $$cr),\n                () => this.matchConstraint_3($$dpth + 1, $$cr),\n                () => this.matchConstraint_4($$dpth + 1, $$cr),\n                () => this.matchConstraint_5($$dpth + 1, $$cr),\n                () => this.matchConstraint_6($$dpth + 1, $$cr),\n                () => this.matchConstraint_7($$dpth + 1, $$cr),\n                () => this.matchConstraint_8($$dpth + 1, $$cr),\n            ]);\n        };\n        const $scope$pos = this.mark();\n        const memo = this.$scope$Constraint$memo.get($scope$pos.overallPos);\n        if(memo !== undefined) {\n            this.reset(memo[1]);\n            return memo[0];\n        }\n        const $scope$oldMemoSafe = this.memoSafe;\n        this.memoSafe = false;\n        this.$scope$Constraint$memo.set($scope$pos.overallPos, [null, $scope$pos]);\n        let lastRes: Nullable<Constraint> = null;\n        let lastPos: PosInfo = $scope$pos;\n        for(;;) {\n            this.reset($scope$pos);\n            const res = fn();\n            const end = this.mark();\n            if(end.overallPos <= lastPos.overallPos)\n                break;\n            lastRes = res;\n            lastPos = end;\n            this.$scope$Constraint$memo.set($scope$pos.overallPos, [lastRes, lastPos]);\n        }\n        this.reset(lastPos);\n        this.memoSafe = $scope$oldMemoSafe;\n        return lastRes;\n    }\n    public matchConstraint_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_1> {\n        return this.matchConstraintAnd($$dpth + 1, $$cr);\n    }\n    public matchConstraint_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_2> {\n        return this.matchConstraintOr($$dpth + 1, $$cr);\n    }\n    public matchConstraint_3($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_3> {\n        return this.matchDistribution($$dpth + 1, $$cr);\n    }\n    public matchConstraint_4($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_4> {\n        return this.matchResponse($$dpth + 1, $$cr);\n    }\n    public matchConstraint_5($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_5> {\n        return this.matchSuitRange($$dpth + 1, $$cr);\n    }\n    public matchConstraint_6($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_6> {\n        return this.matchSuitBound($$dpth + 1, $$cr);\n    }\n    public matchConstraint_7($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_7> {\n        return this.matchPointRange($$dpth + 1, $$cr);\n    }\n    public matchConstraint_8($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_8> {\n        return this.matchPointBound($$dpth + 1, $$cr);\n    }\n    public matchConstraintOr($$dpth: number, $$cr?: ErrorTracker): Nullable<ConstraintOr> {\n        return this.run<ConstraintOr>($$dpth,\n            () => {\n                let $scope$left: Nullable<Constraint>;\n                let $scope$right: Nullable<Constraint>;\n                let $$res: Nullable<ConstraintOr> = null;\n                if (true\n                    && ($scope$left = this.matchConstraint($$dpth + 1, $$cr)) !== null\n                    && this.matchConstraintOr_$0($$dpth + 1, $$cr) !== null\n                    && ($scope$right = this.matchConstraint($$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.ConstraintOr, left: $scope$left, right: $scope$right};\n                }\n                return $$res;\n            });\n    }\n    public matchConstraintOr_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<ConstraintOr_$0> {\n        return this.choice<ConstraintOr_$0>([\n            () => this.matchConstraintOr_$0_1($$dpth + 1, $$cr),\n            () => this.matchConstraintOr_$0_2($$dpth + 1, $$cr),\n        ]);\n    }\n    public matchConstraintOr_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<ConstraintOr_$0_1> {\n        return this.regexAccept(String.raw`(?: or )`, $$dpth + 1, $$cr);\n    }\n    public matchConstraintOr_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<ConstraintOr_$0_2> {\n        return this.regexAccept(String.raw`(?: / )`, $$dpth + 1, $$cr);\n    }\n    public matchConstraintAnd($$dpth: number, $$cr?: ErrorTracker): Nullable<ConstraintAnd> {\n        return this.run<ConstraintAnd>($$dpth,\n            () => {\n                let $scope$constraints: Nullable<ConstraintList>;\n                let $$res: Nullable<ConstraintAnd> = null;\n                if (true\n                    && this.regexAccept(String.raw`(?:\\()`, $$dpth + 1, $$cr) !== null\n                    && ($scope$constraints = this.matchConstraintList($$dpth + 1, $$cr)) !== null\n                    && this.regexAccept(String.raw`(?:\\))`, $$dpth + 1, $$cr) !== null\n                ) {\n                    $$res = {kind: ASTKinds.ConstraintAnd, constraints: $scope$constraints};\n                }\n                return $$res;\n            });\n    }\n    public matchPointRange($$dpth: number, $$cr?: ErrorTracker): Nullable<PointRange> {\n        return this.run<PointRange>($$dpth,\n            () => {\n                let $scope$lower: Nullable<Number>;\n                let $scope$upper: Nullable<Number>;\n                let $$res: Nullable<PointRange> = null;\n                if (true\n                    && ($scope$lower = this.matchNumber($$dpth + 1, $$cr)) !== null\n                    && this.regexAccept(String.raw`(?:-)`, $$dpth + 1, $$cr) !== null\n                    && ($scope$upper = this.matchNumber($$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.PointRange, lower: $scope$lower, upper: $scope$upper};\n                }\n                return $$res;\n            });\n    }\n    public matchPointBound($$dpth: number, $$cr?: ErrorTracker): Nullable<PointBound> {\n        return this.run<PointBound>($$dpth,\n            () => {\n                let $scope$value: Nullable<Number>;\n                let $scope$qualifier: Nullable<BoundQualifier>;\n                let $$res: Nullable<PointBound> = null;\n                if (true\n                    && ($scope$value = this.matchNumber($$dpth + 1, $$cr)) !== null\n                    && ($scope$qualifier = this.matchBoundQualifier($$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.PointBound, value: $scope$value, qualifier: $scope$qualifier};\n                }\n                return $$res;\n            });\n    }\n    public matchSuitRange($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitRange> {\n        return this.run<SuitRange>($$dpth,\n            () => {\n                let $scope$lower: Nullable<Digit>;\n                let $scope$upper: Nullable<Digit>;\n                let $scope$suit: Nullable<SuitRangeSpecifier>;\n                let $$res: Nullable<SuitRange> = null;\n                if (true\n                    && ($scope$lower = this.matchDigit($$dpth + 1, $$cr)) !== null\n                    && this.regexAccept(String.raw`(?:-)`, $$dpth + 1, $$cr) !== null\n                    && ($scope$upper = this.matchDigit($$dpth + 1, $$cr)) !== null\n                    && ($scope$suit = this.matchSuitRangeSpecifier($$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.SuitRange, lower: $scope$lower, upper: $scope$upper, suit: $scope$suit};\n                }\n                return $$res;\n            });\n    }\n    public matchSuitBound($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitBound> {\n        return this.run<SuitBound>($$dpth,\n            () => {\n                let $scope$value: Nullable<Number>;\n                let $scope$qualifier: Nullable<BoundQualifier>;\n                let $scope$suit: Nullable<SuitRangeSpecifier>;\n                let $$res: Nullable<SuitBound> = null;\n                if (true\n                    && ($scope$value = this.matchNumber($$dpth + 1, $$cr)) !== null\n                    && ($scope$qualifier = this.matchBoundQualifier($$dpth + 1, $$cr)) !== null\n                    && ($scope$suit = this.matchSuitRangeSpecifier($$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.SuitBound, value: $scope$value, qualifier: $scope$qualifier, suit: $scope$suit};\n                }\n                return $$res;\n            });\n    }\n    public matchSuitRangeSpecifier($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitRangeSpecifier> {\n        return this.choice<SuitRangeSpecifier>([\n            () => this.matchSuitRangeSpecifier_1($$dpth + 1, $$cr),\n            () => this.matchSuitRangeSpecifier_2($$dpth + 1, $$cr),\n            () => this.matchSuitRangeSpecifier_3($$dpth + 1, $$cr),\n        ]);\n    }\n    public matchSuitRangeSpecifier_1($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitRangeSpecifier_1> {\n        return this.matchMajor($$dpth + 1, $$cr);\n    }\n    public matchSuitRangeSpecifier_2($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitRangeSpecifier_2> {\n        return this.matchMinor($$dpth + 1, $$cr);\n    }\n    public matchSuitRangeSpecifier_3($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitRangeSpecifier_3> {\n        return this.matchSuit($$dpth + 1, $$cr);\n    }\n    public matchOtherMajor($$dpth: number, $$cr?: ErrorTracker): Nullable<OtherMajor> {\n        return this.run<OtherMajor>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<OtherMajor> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:oM)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.OtherMajor, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchOtherMinor($$dpth: number, $$cr?: ErrorTracker): Nullable<OtherMinor> {\n        return this.run<OtherMinor>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<OtherMinor> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:om)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.OtherMinor, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchBoundQualifier($$dpth: number, $$cr?: ErrorTracker): Nullable<BoundQualifier> {\n        return this.choice<BoundQualifier>([\n            () => this.matchBoundQualifier_1($$dpth + 1, $$cr),\n            () => this.matchBoundQualifier_2($$dpth + 1, $$cr),\n            () => this.matchBoundQualifier_3($$dpth + 1, $$cr),\n        ]);\n    }\n    public matchBoundQualifier_1($$dpth: number, $$cr?: ErrorTracker): Nullable<BoundQualifier_1> {\n        return this.matchPlus($$dpth + 1, $$cr);\n    }\n    public matchBoundQualifier_2($$dpth: number, $$cr?: ErrorTracker): Nullable<BoundQualifier_2> {\n        return this.matchMinus($$dpth + 1, $$cr);\n    }\n    public matchBoundQualifier_3($$dpth: number, $$cr?: ErrorTracker): Nullable<BoundQualifier_3> {\n        return this.matchEquals($$dpth + 1, $$cr);\n    }\n    public matchPlus($$dpth: number, $$cr?: ErrorTracker): Nullable<Plus> {\n        return this.run<Plus>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Plus> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:\\+)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Plus, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchMinus($$dpth: number, $$cr?: ErrorTracker): Nullable<Minus> {\n        return this.run<Minus>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Minus> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:\\-)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Minus, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchEquals($$dpth: number, $$cr?: ErrorTracker): Nullable<Equals> {\n        return this.choice<Equals>([\n            () => this.matchEquals_1($$dpth + 1, $$cr),\n            () => this.matchEquals_2($$dpth + 1, $$cr),\n        ]);\n    }\n    public matchEquals_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Equals_1> {\n        return this.run<Equals_1>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Equals_1> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:=)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Equals_1, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchEquals_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Equals_2> {\n        return this.run<Equals_2>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Equals_2> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Equals_2, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchDistribution($$dpth: number, $$cr?: ErrorTracker): Nullable<Distribution> {\n        return this.choice<Distribution>([\n            () => this.matchDistribution_1($$dpth + 1, $$cr),\n            () => this.matchDistribution_2($$dpth + 1, $$cr),\n            () => this.matchDistribution_3($$dpth + 1, $$cr),\n            () => this.matchDistribution_4($$dpth + 1, $$cr),\n        ]);\n    }\n    public matchDistribution_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Distribution_1> {\n        return this.matchBalanced($$dpth + 1, $$cr);\n    }\n    public matchDistribution_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Distribution_2> {\n        return this.matchSemiBalanced($$dpth + 1, $$cr);\n    }\n    public matchDistribution_3($$dpth: number, $$cr?: ErrorTracker): Nullable<Distribution_3> {\n        return this.matchUnbalanced($$dpth + 1, $$cr);\n    }\n    public matchDistribution_4($$dpth: number, $$cr?: ErrorTracker): Nullable<Distribution_4> {\n        return this.matchShape($$dpth + 1, $$cr);\n    }\n    public matchBalanced($$dpth: number, $$cr?: ErrorTracker): Nullable<Balanced> {\n        return this.run<Balanced>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Balanced> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:BAL)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Balanced, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchSemiBalanced($$dpth: number, $$cr?: ErrorTracker): Nullable<SemiBalanced> {\n        return this.run<SemiBalanced>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<SemiBalanced> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:semiBAL)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.SemiBalanced, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchUnbalanced($$dpth: number, $$cr?: ErrorTracker): Nullable<Unbalanced> {\n        return this.run<Unbalanced>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Unbalanced> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:unBAL)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Unbalanced, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchShape($$dpth: number, $$cr?: ErrorTracker): Nullable<Shape> {\n        return this.run<Shape>($$dpth,\n            () => {\n                let $scope$S: Nullable<Digit>;\n                let $scope$H: Nullable<Digit>;\n                let $scope$D: Nullable<Digit>;\n                let $scope$C: Nullable<Digit>;\n                let $$res: Nullable<Shape> = null;\n                if (true\n                    && ($scope$S = this.matchDigit($$dpth + 1, $$cr)) !== null\n                    && ($scope$H = this.matchDigit($$dpth + 1, $$cr)) !== null\n                    && ($scope$D = this.matchDigit($$dpth + 1, $$cr)) !== null\n                    && ($scope$C = this.matchDigit($$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Shape, S: $scope$S, H: $scope$H, D: $scope$D, C: $scope$C};\n                }\n                return $$res;\n            });\n    }\n    public matchResponse($$dpth: number, $$cr?: ErrorTracker): Nullable<Response> {\n        return this.choice<Response>([\n            () => this.matchResponse_1($$dpth + 1, $$cr),\n            () => this.matchResponse_2($$dpth + 1, $$cr),\n            () => this.matchResponse_3($$dpth + 1, $$cr),\n            () => this.matchResponse_4($$dpth + 1, $$cr),\n        ]);\n    }\n    public matchResponse_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Response_1> {\n        return this.matchForceOneRound($$dpth + 1, $$cr);\n    }\n    public matchResponse_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Response_2> {\n        return this.matchForceGame($$dpth + 1, $$cr);\n    }\n    public matchResponse_3($$dpth: number, $$cr?: ErrorTracker): Nullable<Response_3> {\n        return this.matchForceSlam($$dpth + 1, $$cr);\n    }\n    public matchResponse_4($$dpth: number, $$cr?: ErrorTracker): Nullable<Response_4> {\n        return this.matchRelay($$dpth + 1, $$cr);\n    }\n    public matchForceOneRound($$dpth: number, $$cr?: ErrorTracker): Nullable<ForceOneRound> {\n        return this.run<ForceOneRound>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<ForceOneRound> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:F1)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.ForceOneRound, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchForceGame($$dpth: number, $$cr?: ErrorTracker): Nullable<ForceGame> {\n        return this.run<ForceGame>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<ForceGame> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:FG)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.ForceGame, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchForceSlam($$dpth: number, $$cr?: ErrorTracker): Nullable<ForceSlam> {\n        return this.run<ForceSlam>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<ForceSlam> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:FS)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.ForceSlam, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchRelay($$dpth: number, $$cr?: ErrorTracker): Nullable<Relay> {\n        return this.run<Relay>($$dpth,\n            () => {\n                let $scope$level: Nullable<Number>;\n                let $scope$strain: Nullable<Strain>;\n                let $$res: Nullable<Relay> = null;\n                if (true\n                    && ($scope$level = this.matchNumber($$dpth + 1, $$cr)) !== null\n                    && ($scope$strain = this.matchStrain($$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Relay, level: $scope$level, strain: $scope$strain};\n                }\n                return $$res;\n            });\n    }\n    public matchDigit($$dpth: number, $$cr?: ErrorTracker): Nullable<Digit> {\n        return this.run<Digit>($$dpth,\n            () => {\n                let $scope$literal: Nullable<string>;\n                let $$res: Nullable<Digit> = null;\n                if (true\n                    && ($scope$literal = this.regexAccept(String.raw`(?:[0-9])`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = new Digit($scope$literal);\n                }\n                return $$res;\n            });\n    }\n    public matchNumber($$dpth: number, $$cr?: ErrorTracker): Nullable<Number> {\n        return this.run<Number>($$dpth,\n            () => {\n                let $scope$literal: Nullable<string>;\n                let $$res: Nullable<Number> = null;\n                if (true\n                    && ($scope$literal = this.regexAccept(String.raw`(?:[0-9]+)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = new Number($scope$literal);\n                }\n                return $$res;\n            });\n    }\n    public test(): boolean {\n        const mrk = this.mark();\n        const res = this.matchStart(0);\n        const ans = res !== null;\n        this.reset(mrk);\n        return ans;\n    }\n    public parse(): ParseResult {\n        const mrk = this.mark();\n        const res = this.matchStart(0);\n        if (res)\n            return {ast: res, errs: []};\n        this.reset(mrk);\n        const rec = new ErrorTracker();\n        this.clearMemos();\n        this.matchStart(0, rec);\n        const err = rec.getErr()\n        return {ast: res, errs: err !== null ? [err] : []}\n    }\n    public mark(): PosInfo {\n        return this.pos;\n    }\n    private loop<T>(func: $$RuleType<T>, star: boolean = false): Nullable<T[]> {\n        const mrk = this.mark();\n        const res: T[] = [];\n        for (;;) {\n            const t = func();\n            if (t === null) {\n                break;\n            }\n            res.push(t);\n        }\n        if (star || res.length > 0) {\n            return res;\n        }\n        this.reset(mrk);\n        return null;\n    }\n    private run<T>($$dpth: number, fn: $$RuleType<T>): Nullable<T> {\n        const mrk = this.mark();\n        const res = fn()\n        if (res !== null)\n            return res;\n        this.reset(mrk);\n        return null;\n    }\n    private choice<T>(fns: Array<$$RuleType<T>>): Nullable<T> {\n        for (const f of fns) {\n            const res = f();\n            if (res !== null) {\n                return res;\n            }\n        }\n        return null;\n    }\n    private regexAccept(match: string, dpth: number, cr?: ErrorTracker): Nullable<string> {\n        return this.run<string>(dpth,\n            () => {\n                const reg = new RegExp(match, \"y\");\n                const mrk = this.mark();\n                reg.lastIndex = mrk.overallPos;\n                const res = this.tryConsume(reg);\n                if(cr) {\n                    cr.record(mrk, res, {\n                        kind: \"RegexMatch\",\n                        // We substring from 3 to len - 1 to strip off the\n                        // non-capture group syntax added as a WebKit workaround\n                        literal: match.substring(3, match.length - 1),\n                        negated: this.negating,\n                    });\n                }\n                return res;\n            });\n    }\n    private tryConsume(reg: RegExp): Nullable<string> {\n        const res = reg.exec(this.input);\n        if (res) {\n            let lineJmp = 0;\n            let lind = -1;\n            for (let i = 0; i < res[0].length; ++i) {\n                if (res[0][i] === \"\\n\") {\n                    ++lineJmp;\n                    lind = i;\n                }\n            }\n            this.pos = {\n                overallPos: reg.lastIndex,\n                line: this.pos.line + lineJmp,\n                offset: lind === -1 ? this.pos.offset + res[0].length : (res[0].length - lind - 1)\n            };\n            return res[0];\n        }\n        return null;\n    }\n    private noConsume<T>(fn: $$RuleType<T>): Nullable<T> {\n        const mrk = this.mark();\n        const res = fn();\n        this.reset(mrk);\n        return res;\n    }\n    private negate<T>(fn: $$RuleType<T>): Nullable<boolean> {\n        const mrk = this.mark();\n        const oneg = this.negating;\n        this.negating = !oneg;\n        const res = fn();\n        this.negating = oneg;\n        this.reset(mrk);\n        return res === null ? true : null;\n    }\n    private memoise<K>(rule: $$RuleType<K>, memo: Map<number, [Nullable<K>, PosInfo]>): Nullable<K> {\n        const $scope$pos = this.mark();\n        const $scope$memoRes = memo.get($scope$pos.overallPos);\n        if(this.memoSafe && $scope$memoRes !== undefined) {\n        this.reset($scope$memoRes[1]);\n        return $scope$memoRes[0];\n        }\n        const $scope$result = rule();\n        if(this.memoSafe)\n        memo.set($scope$pos.overallPos, [$scope$result, this.mark()]);\n        return $scope$result;\n    }\n    private match$EOF(et?: ErrorTracker): Nullable<{kind: ASTKinds.$EOF}> {\n        const res: {kind: ASTKinds.$EOF} | null = this.finished() ? { kind: ASTKinds.$EOF } : null;\n        if(et)\n            et.record(this.mark(), res, { kind: \"EOF\", negated: this.negating });\n        return res;\n    }\n}\nexport function parse(s: string): ParseResult {\n    const p = new Parser(s);\n    return p.parse();\n}\nexport interface ParseResult {\n    ast: Nullable<Start>;\n    errs: SyntaxErr[];\n}\nexport interface PosInfo {\n    readonly overallPos: number;\n    readonly line: number;\n    readonly offset: number;\n}\nexport interface RegexMatch {\n    readonly kind: \"RegexMatch\";\n    readonly negated: boolean;\n    readonly literal: string;\n}\nexport type EOFMatch = { kind: \"EOF\"; negated: boolean };\nexport type MatchAttempt = RegexMatch | EOFMatch;\nexport class SyntaxErr {\n    public pos: PosInfo;\n    public expmatches: MatchAttempt[];\n    constructor(pos: PosInfo, expmatches: MatchAttempt[]) {\n        this.pos = pos;\n        this.expmatches = [...expmatches];\n    }\n    public toString(): string {\n        return `Syntax Error at line ${this.pos.line}:${this.pos.offset}. Expected one of ${this.expmatches.map(x => x.kind === \"EOF\" ? \" EOF\" : ` ${x.negated ? 'not ': ''}'${x.literal}'`)}`;\n    }\n}\nclass ErrorTracker {\n    private mxpos: PosInfo = {overallPos: -1, line: -1, offset: -1};\n    private regexset: Set<string> = new Set();\n    private pmatches: MatchAttempt[] = [];\n    public record(pos: PosInfo, result: any, att: MatchAttempt) {\n        if ((result === null) === att.negated)\n            return;\n        if (pos.overallPos > this.mxpos.overallPos) {\n            this.mxpos = pos;\n            this.pmatches = [];\n            this.regexset.clear()\n        }\n        if (this.mxpos.overallPos === pos.overallPos) {\n            if(att.kind === \"RegexMatch\") {\n                if(!this.regexset.has(att.literal))\n                    this.pmatches.push(att);\n                this.regexset.add(att.literal);\n            } else {\n                this.pmatches.push(att);\n            }\n        }\n    }\n    public getErr(): SyntaxErr | null {\n        if (this.mxpos.overallPos !== -1)\n            return new SyntaxErr(this.mxpos, this.pmatches);\n        return null;\n    }\n}","import { apply, eq, number, option, ord, readonlyArray as RA, readonlyArray, readonlyNonEmptyArray, readonlyNonEmptyArray as RNEA, readonlyRecord, readonlySet, readonlySet as RS, readonlyTuple, readonlyTuple as RT } from \"fp-ts\"\nimport { flow, pipe } from \"fp-ts/lib/function\"\nimport { first } from 'fp-ts/lib/Semigroup'\nimport { Deck, eqCard, Hand, ordCard, Suit, suits } from \"./deck\"\n\nexport const directions = ['N', 'E', 'S', 'W'] as const\nexport type Direction = typeof directions[number]\n\nexport type Deal = ReadonlyMap<Direction, Hand>\nexport type Player = {\n  direction: Direction\n  hand: Hand\n}\n\nexport const deal = (deck: Deck) : Deal =>\n  pipe(deck,\n    RA.chunksOf(13),\n    RA.zip(directions),\n    RA.map(flow(\n      RT.mapFst(RS.fromReadonlyArray(eqCard)),\n      RT.swap)),\n    x => new Map(x))\n\nexport const vulnerabilities = [\"Neither\", \"NorthSouth\", \"EastWest\", \"Both\"] as const\nexport type Vulnerability = typeof vulnerabilities[number]\n\n\nexport const strains = [...suits, 'N'] as const\nexport type Strain = typeof strains[number]\nexport interface Board {\n  number: number\n  dealer: Direction\n  deal: Deal\n  vulnerability: Vulnerability\n}\n\nconst boneChart = (boardNumber: number) : Vulnerability => {\n  switch ((boardNumber % 16) + 1) {\n    case 1: case 8: case 11: case 14: return \"Neither\"\n    case 2: case 5: case 12: case 15: return \"NorthSouth\"\n    case 3: case 6: case 9:  case 16: return \"EastWest\"\n    case 4: case 7: case 10: case 13: return \"Both\"\n    default: throw Error(\"Not possible\")\n  }\n}\n\nexport const makeBoard = (number: number) => (deal: Deal) : Board => ({\n  number,\n  dealer: directions[(number - 1) % directions.length],\n  deal,\n  vulnerability: boneChart(number)\n})\n\nexport interface Contract {\n  level: number\n  strain: Strain\n}\nexport const contracts : ReadonlyArray<Contract> =\n  apply.sequenceS(readonlyArray.Apply)(({\n    level: readonlyArray.makeBy(7, level => level + 1),\n    strain: strains\n  }))\n\nexport type NonContractBid = \"Pass\" | \"Double\" | \"Redouble\"\nexport type ContractBid = Contract\nexport type Bid = NonContractBid | ContractBid\n\nexport type Auction = RNEA.ReadonlyNonEmptyArray<Bid>\nexport type NonPassAuction = Auction & [...Auction, \"Pass\", \"Pass\", \"Pass\"]\nexport type PassAuction = Auction & [\"Pass\", \"Pass\", \"Pass\", \"Pass\"]\nexport type CompletedAuction = NonPassAuction | PassAuction\n\nexport interface BoardWithAuction extends Board {\n  auction: Auction \n}\nexport interface BoardWithCompletedAuction extends BoardWithAuction {\n  auction: CompletedAuction\n}\n\nexport type Shape = readonly [number, number, number, number]\nexport const zeroShape: Shape = [0, 0, 0, 0]\nexport const sortShape = (s: Shape) => pipe(s, readonlyArray.sort(ord.reverse(number.Ord))) as Shape\nexport const makeShape = (...counts: Shape) =>\n  pipe(counts, sortShape)\nexport const eqShape : eq.Eq<Shape> =\n  eq.contramap(sortShape)(readonlyArray.getEq(number.Eq))\n\nexport type SpecificShape = Record<Suit, number>\nexport const makeSpecificShape = (s: number, h: number, d: number, c: number) : SpecificShape => ({\n  S: s,\n  H: h,\n  D: d,\n  C: c\n})\nexport const zeroSpecificShape = makeSpecificShape(0, 0, 0, 0)\n\nexport const getHandSpecificShape = (hand: Hand) : SpecificShape =>\n  pipe(hand,\n    readonlySet.toReadonlyArray(ordCard),\n    readonlyNonEmptyArray.fromReadonlyArray,\n    option.fold(() => zeroSpecificShape, flow(\n      readonlyNonEmptyArray.groupBy(c => c.suit),\n      readonlyRecord.map(x => x.length),\n      readonlyRecord.union(first<number>())(zeroSpecificShape),\n      (suits: readonlyRecord.ReadonlyRecord<Suit, number>) => suits)))\n\nexport const getHandShape = (hand: Hand) : Shape =>\n  pipe(hand,\n    getHandSpecificShape,\n    readonlyRecord.toReadonlyArray,\n    readonlyArray.map(readonlyTuple.snd),\n    suitCounts => readonlyArray.mapWithIndex((idx, _) =>\n      pipe(suitCounts, readonlyArray.lookup(idx), option.getOrElse(() => 0)))(zeroShape)) as Shape","/* AutoGenerated Code, changes may be overwritten\n* INPUT GRAMMAR:\n* Start := hand=Hand $\n* Hand := S=Suit '\\.' H=Suit '\\.' D=Suit '\\.' C=Suit\n* Suit := cards=Card*\n* Card := c='[AKQJT2-9]'\n*   .rank = number {\n*     const rankStrings = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A']\n*     return rankStrings.indexOf(c) + 2\n*   }\n* // ValidChar := '[AKQJT2-9.]{16}' // 13 + 3 dots\n*/\ntype Nullable<T> = T | null;\ntype $$RuleType<T> = () => Nullable<T>;\ninterface ASTNodeIntf {\n    kind: ASTKinds;\n}\nexport enum ASTKinds {\n    Start = \"Start\",\n    Hand = \"Hand\",\n    Suit = \"Suit\",\n    Card = \"Card\",\n    $EOF = \"$EOF\",\n}\nexport interface Start {\n    kind: ASTKinds.Start;\n    hand: Hand;\n}\nexport interface Hand {\n    kind: ASTKinds.Hand;\n    S: Suit;\n    H: Suit;\n    D: Suit;\n    C: Suit;\n}\nexport interface Suit {\n    kind: ASTKinds.Suit;\n    cards: Card[];\n}\nexport class Card {\n    public kind: ASTKinds.Card = ASTKinds.Card;\n    public c: string;\n    public rank: number;\n    constructor(c: string){\n        this.c = c;\n        this.rank = ((): number => {\n        const rankStrings = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A']\n    return rankStrings.indexOf(c) + 2\n        })();\n    }\n}\nexport class Parser {\n    private readonly input: string;\n    private pos: PosInfo;\n    private negating: boolean = false;\n    private memoSafe: boolean = true;\n    constructor(input: string) {\n        this.pos = {overallPos: 0, line: 1, offset: 0};\n        this.input = input;\n    }\n    public reset(pos: PosInfo) {\n        this.pos = pos;\n    }\n    public finished(): boolean {\n        return this.pos.overallPos === this.input.length;\n    }\n    public clearMemos(): void {\n    }\n    public matchStart($$dpth: number, $$cr?: ErrorTracker): Nullable<Start> {\n        return this.run<Start>($$dpth,\n            () => {\n                let $scope$hand: Nullable<Hand>;\n                let $$res: Nullable<Start> = null;\n                if (true\n                    && ($scope$hand = this.matchHand($$dpth + 1, $$cr)) !== null\n                    && this.match$EOF($$cr) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Start, hand: $scope$hand};\n                }\n                return $$res;\n            });\n    }\n    public matchHand($$dpth: number, $$cr?: ErrorTracker): Nullable<Hand> {\n        return this.run<Hand>($$dpth,\n            () => {\n                let $scope$S: Nullable<Suit>;\n                let $scope$H: Nullable<Suit>;\n                let $scope$D: Nullable<Suit>;\n                let $scope$C: Nullable<Suit>;\n                let $$res: Nullable<Hand> = null;\n                if (true\n                    && ($scope$S = this.matchSuit($$dpth + 1, $$cr)) !== null\n                    && this.regexAccept(String.raw`(?:\\.)`, $$dpth + 1, $$cr) !== null\n                    && ($scope$H = this.matchSuit($$dpth + 1, $$cr)) !== null\n                    && this.regexAccept(String.raw`(?:\\.)`, $$dpth + 1, $$cr) !== null\n                    && ($scope$D = this.matchSuit($$dpth + 1, $$cr)) !== null\n                    && this.regexAccept(String.raw`(?:\\.)`, $$dpth + 1, $$cr) !== null\n                    && ($scope$C = this.matchSuit($$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Hand, S: $scope$S, H: $scope$H, D: $scope$D, C: $scope$C};\n                }\n                return $$res;\n            });\n    }\n    public matchSuit($$dpth: number, $$cr?: ErrorTracker): Nullable<Suit> {\n        return this.run<Suit>($$dpth,\n            () => {\n                let $scope$cards: Nullable<Card[]>;\n                let $$res: Nullable<Suit> = null;\n                if (true\n                    && ($scope$cards = this.loop<Card>(() => this.matchCard($$dpth + 1, $$cr), true)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Suit, cards: $scope$cards};\n                }\n                return $$res;\n            });\n    }\n    public matchCard($$dpth: number, $$cr?: ErrorTracker): Nullable<Card> {\n        return this.run<Card>($$dpth,\n            () => {\n                let $scope$c: Nullable<string>;\n                let $$res: Nullable<Card> = null;\n                if (true\n                    && ($scope$c = this.regexAccept(String.raw`(?:[AKQJT2-9])`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = new Card($scope$c);\n                }\n                return $$res;\n            });\n    }\n    public test(): boolean {\n        const mrk = this.mark();\n        const res = this.matchStart(0);\n        const ans = res !== null;\n        this.reset(mrk);\n        return ans;\n    }\n    public parse(): ParseResult {\n        const mrk = this.mark();\n        const res = this.matchStart(0);\n        if (res)\n            return {ast: res, errs: []};\n        this.reset(mrk);\n        const rec = new ErrorTracker();\n        this.clearMemos();\n        this.matchStart(0, rec);\n        const err = rec.getErr()\n        return {ast: res, errs: err !== null ? [err] : []}\n    }\n    public mark(): PosInfo {\n        return this.pos;\n    }\n    private loop<T>(func: $$RuleType<T>, star: boolean = false): Nullable<T[]> {\n        const mrk = this.mark();\n        const res: T[] = [];\n        for (;;) {\n            const t = func();\n            if (t === null) {\n                break;\n            }\n            res.push(t);\n        }\n        if (star || res.length > 0) {\n            return res;\n        }\n        this.reset(mrk);\n        return null;\n    }\n    private run<T>($$dpth: number, fn: $$RuleType<T>): Nullable<T> {\n        const mrk = this.mark();\n        const res = fn()\n        if (res !== null)\n            return res;\n        this.reset(mrk);\n        return null;\n    }\n    private choice<T>(fns: Array<$$RuleType<T>>): Nullable<T> {\n        for (const f of fns) {\n            const res = f();\n            if (res !== null) {\n                return res;\n            }\n        }\n        return null;\n    }\n    private regexAccept(match: string, dpth: number, cr?: ErrorTracker): Nullable<string> {\n        return this.run<string>(dpth,\n            () => {\n                const reg = new RegExp(match, \"y\");\n                const mrk = this.mark();\n                reg.lastIndex = mrk.overallPos;\n                const res = this.tryConsume(reg);\n                if(cr) {\n                    cr.record(mrk, res, {\n                        kind: \"RegexMatch\",\n                        // We substring from 3 to len - 1 to strip off the\n                        // non-capture group syntax added as a WebKit workaround\n                        literal: match.substring(3, match.length - 1),\n                        negated: this.negating,\n                    });\n                }\n                return res;\n            });\n    }\n    private tryConsume(reg: RegExp): Nullable<string> {\n        const res = reg.exec(this.input);\n        if (res) {\n            let lineJmp = 0;\n            let lind = -1;\n            for (let i = 0; i < res[0].length; ++i) {\n                if (res[0][i] === \"\\n\") {\n                    ++lineJmp;\n                    lind = i;\n                }\n            }\n            this.pos = {\n                overallPos: reg.lastIndex,\n                line: this.pos.line + lineJmp,\n                offset: lind === -1 ? this.pos.offset + res[0].length : (res[0].length - lind - 1)\n            };\n            return res[0];\n        }\n        return null;\n    }\n    private noConsume<T>(fn: $$RuleType<T>): Nullable<T> {\n        const mrk = this.mark();\n        const res = fn();\n        this.reset(mrk);\n        return res;\n    }\n    private negate<T>(fn: $$RuleType<T>): Nullable<boolean> {\n        const mrk = this.mark();\n        const oneg = this.negating;\n        this.negating = !oneg;\n        const res = fn();\n        this.negating = oneg;\n        this.reset(mrk);\n        return res === null ? true : null;\n    }\n    private memoise<K>(rule: $$RuleType<K>, memo: Map<number, [Nullable<K>, PosInfo]>): Nullable<K> {\n        const $scope$pos = this.mark();\n        const $scope$memoRes = memo.get($scope$pos.overallPos);\n        if(this.memoSafe && $scope$memoRes !== undefined) {\n        this.reset($scope$memoRes[1]);\n        return $scope$memoRes[0];\n        }\n        const $scope$result = rule();\n        if(this.memoSafe)\n        memo.set($scope$pos.overallPos, [$scope$result, this.mark()]);\n        return $scope$result;\n    }\n    private match$EOF(et?: ErrorTracker): Nullable<{kind: ASTKinds.$EOF}> {\n        const res: {kind: ASTKinds.$EOF} | null = this.finished() ? { kind: ASTKinds.$EOF } : null;\n        if(et)\n            et.record(this.mark(), res, { kind: \"EOF\", negated: this.negating });\n        return res;\n    }\n}\nexport function parse(s: string): ParseResult {\n    const p = new Parser(s);\n    return p.parse();\n}\nexport interface ParseResult {\n    ast: Nullable<Start>;\n    errs: SyntaxErr[];\n}\nexport interface PosInfo {\n    readonly overallPos: number;\n    readonly line: number;\n    readonly offset: number;\n}\nexport interface RegexMatch {\n    readonly kind: \"RegexMatch\";\n    readonly negated: boolean;\n    readonly literal: string;\n}\nexport type EOFMatch = { kind: \"EOF\"; negated: boolean };\nexport type MatchAttempt = RegexMatch | EOFMatch;\nexport class SyntaxErr {\n    public pos: PosInfo;\n    public expmatches: MatchAttempt[];\n    constructor(pos: PosInfo, expmatches: MatchAttempt[]) {\n        this.pos = pos;\n        this.expmatches = [...expmatches];\n    }\n    public toString(): string {\n        return `Syntax Error at line ${this.pos.line}:${this.pos.offset}. Expected one of ${this.expmatches.map(x => x.kind === \"EOF\" ? \" EOF\" : ` ${x.negated ? 'not ': ''}'${x.literal}'`)}`;\n    }\n}\nclass ErrorTracker {\n    private mxpos: PosInfo = {overallPos: -1, line: -1, offset: -1};\n    private regexset: Set<string> = new Set();\n    private pmatches: MatchAttempt[] = [];\n    public record(pos: PosInfo, result: any, att: MatchAttempt) {\n        if ((result === null) === att.negated)\n            return;\n        if (pos.overallPos > this.mxpos.overallPos) {\n            this.mxpos = pos;\n            this.pmatches = [];\n            this.regexset.clear()\n        }\n        if (this.mxpos.overallPos === pos.overallPos) {\n            if(att.kind === \"RegexMatch\") {\n                if(!this.regexset.has(att.literal))\n                    this.pmatches.push(att);\n                this.regexset.add(att.literal);\n            } else {\n                this.pmatches.push(att);\n            }\n        }\n    }\n    public getErr(): SyntaxErr | null {\n        if (this.mxpos.overallPos !== -1)\n            return new SyntaxErr(this.mxpos, this.pmatches);\n        return null;\n    }\n}","import { readonlyArray, readonlyRecord } from 'fp-ts'\nimport { pipe } from 'fp-ts/lib/function'\nimport { Strain, zeroSpecificShape } from '../model/bridge'\nimport { ConstrainedBid, Constraint, SuitRangeSpecifier } from '../model/constraints'\nimport { Suit } from '../model/deck'\nimport * as AST from '../parse/bid.peg.g'\n\nexport const map = (c: AST.ConstraintList) =>\n  pipe(c, readonlyArray.map(c => constraintFromAST(c.constraint)))\n\nexport const suitFromAST = (s: AST.Suit) : Suit =>\n  s.kind === AST.ASTKinds.Club    ? 'C' :\n  s.kind === AST.ASTKinds.Diamond ? 'D' :\n  s.kind === AST.ASTKinds.Heart   ? 'H' :\n                                    'S'\n\nexport const strainFromAST = (s: AST.Strain) : Strain =>\n  s.kind === AST.ASTKinds.Notrump ? 'N' :\n  suitFromAST(s)\n\nexport const suitSpecifierFromAST = (s: AST.SuitRangeSpecifier) : SuitRangeSpecifier =>\n  s.kind === AST.ASTKinds.Major ? \"Major\" :\n  s.kind === AST.ASTKinds.Minor ? \"Minor\" :\n  suitFromAST(s)\n\nexport const constraintFromAST = (c: AST.Constraint) : Constraint => {\n  if (c.kind === AST.ASTKinds.ConstraintAnd) {\n    let result = map(c.constraints)\n    if (result.length === 1) {\n      return result[0]\n    } else {\n      return {\n        type: \"Conjunction\",\n        constraints: map(c.constraints)\n      }\n    }\n  } else if (c.kind === AST.ASTKinds.ConstraintOr) {\n    const [left, right] = [constraintFromAST(c.left), constraintFromAST(c.right)]\n    const flatten = (c: Constraint) => c.type === \"Disjunction\" ? c.constraints : [c]\n    return {\n      type: \"Disjunction\",\n      constraints: [...flatten(left), ...flatten(right)]\n    }\n  } else if (c.kind === AST.ASTKinds.PointRange) {\n    return {\n      type: \"PointRange\",\n      min: c.lower.value,\n      max: c.upper.value\n    }\n  } else if (c.kind === AST.ASTKinds.PointBound) {\n    return {\n      type: \"PointRange\",\n      min: c.qualifier.kind === AST.ASTKinds.Plus ? c.value.value : 0,\n      max: c.qualifier.kind === AST.ASTKinds.Minus ? c.value.value : 37\n    }\n  } else if (c.kind === AST.ASTKinds.SuitRange) {\n    return {\n      type: \"SuitRange\",\n      min: c.lower.value,\n      max: c.upper.value,\n      suit: suitSpecifierFromAST(c.suit)\n    }\n  } else if (c.kind === AST.ASTKinds.SuitBound) {\n    return {\n      type: \"SuitRange\",\n      min: c.qualifier.kind === AST.ASTKinds.Plus ? c.value.value : 0,\n      max: c.qualifier.kind === AST.ASTKinds.Minus ? c.value.value : 13,\n      suit: suitSpecifierFromAST(c.suit)\n    }\n  } else if (c.kind === AST.ASTKinds.Shape) {\n    return {\n      type: \"SpecificShape\",\n      suits: pipe(zeroSpecificShape, readonlyRecord.mapWithIndex((s, _) => c[s].value))\n    }\n  } else if (c.kind === AST.ASTKinds.Relay) {\n    return {\n      type: \"Relay\",\n      bid: {\n        level: c.level.value,\n        strain: strainFromAST(c.strain)\n      }\n    }\n  } else {\n    return { type: c.kind }\n  }\n}\n\nexport const bidFromAST = (bid: AST.Bid) : ConstrainedBid => ({\n  bid: {\n    level: bid.level.value,\n    strain: strainFromAST(bid.bid as AST.Strain),\n  },\n  constraint: pipe(bid.constraints,\n    readonlyArray.map(c => constraintFromAST(c.constraint)),\n    constraints => constraints.length === 1 ? constraints[0] : ({\n      type: \"Conjunction\",\n      constraints\n    }))\n})\n\nexport const parseBid = AST.parse\n","import * as AST from '../parse/hand.peg.g'\n\nimport { Card, Hand, Rank, RankC, Suit, eqCard, suits } from \"../model/deck\"\nimport { readonlyArray, readonlySet } from \"fp-ts\"\n\nimport { Right } from \"fp-ts/lib/Either\"\nimport { pipe } from \"fp-ts/lib/function\"\n\nconst suitFromAST = (hand: AST.Hand) => (suit: Suit) : ReadonlyArray<Card> =>\n  pipe(hand[suit].cards,\n    readonlyArray.map(card => ({ suit, rank: (RankC.decode(card.rank) as Right<Rank>).right })))\n\nexport const handFromAST = (hand: AST.Hand) : Hand =>\n  pipe(suits,\n    readonlyArray.map(suitFromAST(hand)),\n    readonlyArray.flatten,\n    readonlySet.fromReadonlyArray(eqCard))\n\nexport const parseHand = AST.parse","import * as DE from 'io-ts/lib/DecodeError'\nimport * as FS from 'io-ts/lib/FreeSemigroup'\nimport * as d from 'io-ts/Decoder'\n\nimport { bidFromAST, parseBid } from './bid';\nimport { constant, flow, pipe } from \"fp-ts/lib/function\";\nimport { either, option, readonlyNonEmptyArray } from \"fp-ts\";\nimport { handFromAST, parseHand } from './hand';\n\nexport interface PosInfo {\n  readonly overallPos: number;\n  readonly line: number;\n  readonly offset: number;\n}\nexport interface RegexMatch {\n  readonly kind: \"RegexMatch\";\n  readonly negated: boolean;\n  readonly literal: string;\n}\nexport type EOFMatch = { kind: \"EOF\"; negated: boolean };\nexport type MatchAttempt = RegexMatch | EOFMatch;\ninterface SyntaxErr {\n  pos: PosInfo;\n  expmatches: MatchAttempt[];\n  toString(): string\n}\ninterface ParseResult<T> {\n  ast: T | null;\n  errs: SyntaxErr[];\n}\n// above is generalized from generated tsPEG code\n\nconst convertErrors = (errs: ReadonlyArray<SyntaxErr>): d.DecodeError =>\n  pipe(errs,\n    readonlyNonEmptyArray.fromReadonlyArray,\n    option.fold(constant(d.error(null, \"No syntax errors reported\")),\n      readonlyNonEmptyArray.foldMapWithIndex(FS.getSemigroup<DE.DecodeError<string>>())((i, err) =>\n        FS.of(DE.index(i, \"required\",\n          FS.of(DE.leaf({\n            pos: err.pos,\n            expmatches: err.expmatches\n          }, err.toString())))))))\n\nconst parseResultToEither = <T>(result: ParseResult<T>) =>\n  either.fromNullable(result.errs)(result.ast)\n\nconst getDecoder = <T>(parser: (input: string) => ParseResult<T>) : d.Decoder<string, T> =>\n  pipe(\n    d.string,\n    d.parse(flow(parser, parseResultToEither, either.mapLeft(convertErrors))))\n\nexport const decodeBid = flow(\n  getDecoder(parseBid).decode,\n  either.map(x => bidFromAST(x.bid)))\n\nexport const decodeHand = flow(\n  getDecoder(parseHand).decode,\n  either.map(x => handFromAST(x.hand)))","import { createSlice, PayloadAction } from \"@reduxjs/toolkit\"\nimport { either, option, readonlyArray, separated, tree } from 'fp-ts'\nimport { flow, identity, pipe } from \"fp-ts/lib/function\"\nimport { castDraft } from \"immer\"\nimport { decodeBid } from \"../parse\"\n\n\ninterface Node {\n  blockKey?: string\n  text: string\n  bid?: ReturnType<typeof decodeBid>\n}\n\ntype State = {\n  system: tree.Tree<Node>\n}\nconst getRoot = () => tree.make<Node>({ text: \"root\" })\nconst initialState: State = {\n  system: getRoot()\n}\n\nconst getPath = (blockKey: string) =>\n  flow(\n    tree.fold<Node, option.Option<ReadonlyArray<Node>>>((node, path) => {\n      if (node.blockKey === blockKey) {\n        return option.some([node])\n      } else {\n        return pipe(path,\n          readonlyArray.findFirstMap(identity),\n          option.map(readonlyArray.prepend(node)))\n      }\n    }),\n    option.chain(readonlyArray.tail))\n\n\nconst flatten =\n  tree.reduce<Node, readonly Node[]>([], (items, a) =>\n    pipe(items, readonlyArray.append(a)))\n\nexport interface BlockItem {\n  key: string\n  text: string\n  depth: number\n}\n\nconst buildTree = (items: BlockItem[]) => {\n  const root = getRoot()\n  var parents = [root]\n  items.forEach(item => {\n    const curr = parents[item.depth + 1] = { value: { blockKey: item.key, text: item.text, bid: decodeBid(item.text) }, forest: [] }\n    parents[item.depth].forest.push(curr)\n  })\n  return root\n}\n\nconst name = 'system'\nconst slice = createSlice({\n  name,\n  initialState,\n  reducers: {\n    setSystem: (state, action: PayloadAction<BlockItem[]>) => {\n      state.system = pipe(buildTree(action.payload), castDraft)\n    }\n  }\n})\n\nexport const { setSystem } = slice.actions\n\nexport const selectNode = (state: State, blockKey: string) =>\n  pipe(getPath(blockKey)(state.system),\n    option.chain(readonlyArray.last),\n    option.toNullable)\n\nexport const selectPath = (state: State, blockKey: string) =>\n  pipe(\n    getPath(blockKey)(state.system),\n    option.toNullable)\n\nexport const selectBids = (state: State, blockKey: string) =>\n  pipe(\n    getPath(blockKey)(state.system),\n    option.getOrElse(() => [] as readonly Node[]),\n    readonlyArray.map(n => option.fromNullable(n.bid)),\n    readonlyArray.compact,\n    readonlyArray.sequence(either.Applicative))\n\nexport const selectRules = (state: State) =>\n  pipe(\n    state.system,\n    flatten,\n    readonlyArray.map(n => option.fromNullable(n.bid)),\n    readonlyArray.compact,\n  )\n\nexport const selectErrors =\n  flow(\n    selectRules,\n    readonlyArray.separate,\n    separated.left)\n\nexport default slice.reducer","import { number, ord, readonlyArray, readonlySet, record } from 'fp-ts'\nimport { eqStrict } from 'fp-ts/lib/Eq'\nimport { pipe } from 'fp-ts/lib/function'\nimport { Bid, ContractBid, eqShape, getHandShape, getHandSpecificShape, makeShape, Shape, SpecificShape } from './bridge'\nimport { Card, Hand, ordCard, Suit } from './deck'\n\n\nexport interface ConstraintPointRange {\n  type: \"PointRange\"\n  min: number\n  max: number\n}\n\nexport type SuitRangeSpecifier = \"Major\" | \"Minor\" | Suit // | \"OtherMajor\" | \"OtherMinor\"\nexport interface ConstraintSuitRange {\n  type: \"SuitRange\"\n  suit: SuitRangeSpecifier\n  min: number\n  max: number\n}\n\nexport interface ConstraintConjunction {\n  type: \"Conjunction\"\n  constraints: ReadonlyArray<Constraint>\n}\n\nexport interface ConstraintDisjunction {\n  type: \"Disjunction\"\n  constraints: ReadonlyArray<Constraint>\n}\n\ninterface ConstraintShape {\n  type: \"Shape\"\n  counts: Shape\n}\n\nexport interface ConstraintSpecificShape {\n  type: \"SpecificShape\",\n  suits: SpecificShape\n}\n\n\nexport interface ConstraintDistribution {\n  type: \"Balanced\" | \"SemiBalanced\" | \"Unbalanced\"\n}\n\nexport interface ConstraintResponse {\n  type: \"ForceOneRound\" | \"ForceGame\" | \"ForceSlam\"\n}\n\nexport interface ConstraintRelayResponse {\n  type: \"Relay\",\n  bid: ContractBid\n}\n\nexport type Constraint =\n  | ConstraintConjunction\n  | ConstraintDisjunction\n  | ConstraintPointRange\n  | ConstraintSuitRange\n  | ConstraintDistribution\n  | ConstraintShape\n  | ConstraintSpecificShape\n  | ConstraintResponse\n  | ConstraintRelayResponse\n\nexport interface ConstrainedBid {\n  bid: Bid\n  constraint: Constraint\n}\n\nexport const getCardHcp = (card: Card) =>\n  ord.max(number.Ord)(0, card.rank - 10)\n\nexport const getHcp = (hand: Hand) =>\n  pipe(hand,\n    readonlySet.toReadonlyArray(ordCard),\n    readonlyArray.foldMap(number.MonoidSum)(getCardHcp))\n\nexport const isSpecificShape = (hand: Hand) => (shape: SpecificShape) =>\n  pipe(hand, getHandSpecificShape, suits => record.getEq(eqStrict).equals(suits, shape))\n\nexport const isSuitRange = (hand: Hand) => (range: ConstraintSuitRange) => {\n  const getSuitsToCheck: readonly Suit[] =\n    range.suit === \"Major\" ? [\"S\", \"H\"] :\n    range.suit === \"Minor\" ? [\"D\", \"C\"] :\n    [range.suit]\n  return pipe(hand, getHandSpecificShape, shape =>\n    pipe(getSuitsToCheck, readonlyArray.exists(s => {\n      return ord.between(number.Ord)(range.min, range.max)(shape[s])\n    })))\n}\n\nexport const isShape = (hand: Hand) => (shape: Shape) =>\n  eqShape.equals(shape, getHandShape(hand))\n\nexport const isBalanced = (hand: Hand) =>\n  pipe([\n    makeShape(4, 3, 3, 3),\n    makeShape(5, 3, 3, 2),\n    makeShape(4, 4, 3, 2),\n    makeShape(5, 5, 3, 2),\n  ], readonlyArray.exists(isShape(hand)))\n\nexport const isSemiBalanced = (hand: Hand) =>\n  pipe([\n    makeShape(5, 4, 2, 2),\n    makeShape(6, 3, 2, 2)\n  ], readonlyArray.exists(isShape(hand)))\n\nexport const satisfies = (hand: Hand) => (c: Constraint) : boolean => {\n  if (c.type === \"Conjunction\") {\n    return pipe(c.constraints, readonlyArray.every(satisfies(hand)))\n  } else if (c.type === \"Disjunction\") {\n    return pipe(c.constraints, readonlyArray.exists(satisfies(hand)))\n  } else if (c.type === \"PointRange\") {\n    return pipe(hand, getHcp, ord.between(number.Ord)(c.min, c.max))\n  } else if (c.type === \"SuitRange\") {\n    return isSuitRange(hand)(c)\n  } else if (c.type === \"Balanced\") {\n    return isBalanced(hand)\n  } else if (c.type === \"SemiBalanced\") {\n    return isBalanced(hand) || isSemiBalanced(hand)\n  } else if (c.type === \"Unbalanced\") {\n    return !(isBalanced(hand) || isSemiBalanced(hand))\n  } else if (c.type === \"Shape\") {\n    return isShape(hand)(c.counts)\n  } else if (c.type === \"SpecificShape\") {\n    return isSpecificShape(hand)(c.suits)\n  } else {\n    // todo\n    return false\n  }\n}\n","import { createSlice, PayloadAction } from \"@reduxjs/toolkit\"\nimport { either, option } from \"fp-ts\"\nimport { pipe } from \"fp-ts/lib/function\"\nimport { castDraft } from \"immer\"\nimport * as D from 'io-ts/Decoder'\nimport { Constraint, satisfies } from '../model/constraints'\nimport { decodeHand } from '../parse'\n\nconst name = 'selection'\ninterface State {\n  selectedBlockKey: option.Option<string>\n  opener?: ReturnType<typeof decodeHand>\n  responder?: ReturnType<typeof decodeHand>\n}\nconst initialState : State = {\n  selectedBlockKey: option.none,\n}\nconst slice = createSlice({\n  name,\n  initialState,\n  reducers: {\n    setSelectedBlockKey: (state, action: PayloadAction<option.Option<string>>) => {\n      state.selectedBlockKey = action.payload\n    },\n    setHand: {\n      reducer: (state, action: PayloadAction<string, string, \"opener\" | \"responder\">) => {\n        state[action.meta] = pipe(action.payload, decodeHand, castDraft)\n      },\n      prepare: (payload, meta) => ({ payload, meta })\n    }\n  }\n})\n\nexport const { setSelectedBlockKey, setHand } = slice.actions\nexport default slice.reducer\n\nexport const selectTestConstraint = (state: State, constraint: Constraint) =>\n  pipe(state.opener,\n    either.fromNullable(D.error(undefined, \"No hand defined yet\")),\n    either.flatten,\n    either.exists(hand => satisfies(hand)(constraint)))","import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';\nimport type { RootState, AppDispatch } from './store';\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\n","import 'draft-js/dist/Draft.css';\n\nimport { BlockItem, setSystem } from '../reducers/system';\nimport { Editor as DraftJsEditor, EditorState, RichUtils, getDefaultKeyBinding } from 'draft-js';\nimport React, { useCallback, useEffect } from 'react';\n\nimport { option } from 'fp-ts';\nimport { setSelectedBlockKey } from '../reducers/selection';\nimport { useAppDispatch } from '../app/hooks';\n\nconst getItemsFromBlocks = (editorState: EditorState) =>\n  editorState.getCurrentContent().getBlockMap().toArray().map<BlockItem>(x => ({\n    key: x.getKey(),\n    text: x.getText(),\n    depth: x.getDepth()\n  }))\n\nconst Editor = () => {\n  const [editorState, setEditorState] = React.useState(() => EditorState.createEmpty());\n  const dispatch = useAppDispatch()\n\n  const onChange = useCallback((editorState: EditorState) => {\n    setEditorState(editorState)\n    dispatch(setSystem(getItemsFromBlocks(editorState)))\n    dispatch(setSelectedBlockKey(option.some(editorState.getSelection().getFocusKey())))\n  }, [dispatch])\n\n  useEffect(() => {\n    setEditorState(() => RichUtils.toggleBlockType(editorState, 'unordered-list-item'))\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [])\n  \n  return (\n    <DraftJsEditor\n      editorState={editorState}\n      onChange={onChange}\n      // https://github.com/facebook/draft-js/blob/master/examples/draft-0-10-0/rich/rich.html#L61\n      keyBindingFn={e => {\n        if (e.keyCode === 9 /* TAB */) {\n          const newEditorState = RichUtils.onTab(e, editorState, 10, /* maxDepth */);\n          if (newEditorState !== editorState) {\n            onChange(newEditorState)\n          }\n          return null;\n        }\n        return getDefaultKeyBinding(e);\n      }}\n    />\n  )\n}\n\nexport default Editor","import { either, option, readonlyArray } from 'fp-ts'\nimport { pipe } from 'fp-ts/lib/function'\nimport { RootState } from '../app/store'\nimport { ConstrainedBid, satisfies } from '../model/constraints'\nimport { Hand } from '../model/deck'\nimport selection from './selection'\nimport system, { selectBids } from './system'\n\nconst reducers = {\n  system,\n  selection\n}\nexport default reducers\n\nfunction* alternate(opener: Hand, responder: Hand) {\n  while (true) { yield opener; yield responder }\n}\n\nconst unfold = (length: number) => <T>(g: Generator<T>) : readonly T[] => {\n  const val = g.next()\n  return val.done || length === 0 ? [] : [val.value, ...unfold(length - 1)(g)]\n}\n\nconst walkNodesWithHands = (opener: Hand, responder: Hand) => (bids: ReadonlyArray<ConstrainedBid>) =>\n  pipe(\n    alternate(opener, responder),\n    unfold(bids.length),\n    readonlyArray.zip(bids),\n    readonlyArray.every(([hand, bid]) => satisfies(hand)(bid.constraint)))\n\nexport const selectHandsSatisfySelectedPath = (state: RootState) =>\n  pipe(option.Do,\n    option.apS('blockKey', state.selection.selectedBlockKey),\n    option.apS('opener', option.fromNullable(state.selection.opener)),\n    option.apS('responder', option.fromNullable(state.selection.responder)),\n    option.chain(o => pipe(either.Do,\n      either.apS('opener', o.opener),\n      either.apS('responder', o.responder),\n      either.apS('bids', selectBids(state.system, o.blockKey)),\n      either.map(e => walkNodesWithHands(e.opener, e.responder)(e.bids)),\n      option.fromEither)),\n    option.toNullable)\n\n  // pipe(state.selection.selectedBlockKey,\n  //   option.map(blockKey => selectBids(state.system, blockKey)),\n  //   option.chain(option.fromEither),\n  //   option.map(walkNodesWithHands(state.selection.opener))","import { either, option, readonlyArray, readonlyRecord, readonlyTuple } from \"fp-ts\"\nimport { Either } from \"fp-ts/lib/Either\"\nimport { pipe } from \"fp-ts/lib/function\"\nimport { DecodeError } from \"io-ts/Decoder\"\nimport { draw } from \"io-ts/lib/Decoder\"\nimport { useCallback, useState } from \"react\"\nimport styled from \"styled-components\"\nimport { useAppDispatch, useAppSelector } from \"../app/hooks\"\nimport * as Deck from \"../model/deck\"\nimport { selectHandsSatisfySelectedPath } from \"../reducers\"\nimport { setHand } from \"../reducers/selection\"\nimport { selectErrors, selectNode, selectPath } from \"../reducers/system\"\n\ninterface DecodeProps<T> {\n  value: Either<DecodeError, T>\n  children: (value: T) => JSX.Element\n  onError?: (error: DecodeError) => JSX.Element\n}\nconst Decode = <T extends {}>({value, children: onSuccess, onError }: DecodeProps<T>) => \n  pipe(value, either.fold(\n    e => onError ? onError(e) : <span>{draw(e)}</span>,\n    onSuccess))\n\ninterface HandProps {\n  type: \"opener\" | \"responder\"\n}\nconst HandInput = ({ type }: HandProps) => {\n  const dispatch = useAppDispatch()\n  const [value, setValue] = useState<string>(\"\")\n  const onSetHand = useCallback((hand: string) => {\n    setValue(hand)\n    dispatch(setHand(hand, type))\n  }, [dispatch, type])\n  return <input type=\"text\" placeholder=\"AKQJ.T987.654.32\" value={value} onChange={e => onSetHand(e.target.value)} />\n}\n\nconst RankList = styled.ol `\n  padding-left: 0;\n`\n\nconst RankListItem = styled.li `\n  list-style-type: none;\n  display: inline;\n  float: left;\n`\n\ninterface RankProps {\n  rank: Deck.Rank\n}\nconst Rank = ({ rank }: RankProps) =>\n  <RankListItem>{Deck.ranks[rank - 2]}</RankListItem>\n\ninterface SuitProps {\n  suit: Deck.Suit\n  ranks: ReadonlyArray<Deck.Rank>\n}\n\nconst HandCol = styled.th `\n  width: 15em;\n`\n\nconst SuitList = styled.ol `\n  white-space: nowrap;\n  padding-left: 0;\n  list-style: decimal url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) inside;\n`\n\nconst SuitListItem = styled.li `\n  display: inline;\n  &::before {\n    display: inline;\n    float: left;\n    margin-left: 5px;\n  }\n  &.S::before { content: \"\"; color: #0000FF; }\n  &.H::before { content: \"\"; color: #FF0000; }\n  &.D::before { content: \"\"; color: #FFA500; }\n  &.C::before { content: \"\"; color: #32CD32; }\n`\n\nconst Suit = ({ suit, ranks }: SuitProps) => {\n  return <SuitListItem className={suit}>\n    <RankList>\n      {ranks.map((r, i) => <Rank key={i} rank={r} />)}\n      {ranks.length === 0 && <RankListItem>-</RankListItem> }\n    </RankList>\n </SuitListItem>\n}\n\nconst Hand = ({ type }: HandProps) => {\n  const hand = useAppSelector(state => state.selection[type])\n  return <>{hand &&\n    <Decode value={hand}>{hand => {\n      const groupedHand = Deck.groupHandBySuits(hand)\n      return (\n        <SuitList>\n          {pipe(groupedHand,\n            readonlyRecord.mapWithIndex((suit, ranks) =>\n              <Suit key={suit} suit={suit} ranks={ranks} />),\n            readonlyRecord.toReadonlyArray,\n            readonlyArray.sort(Deck.getOrdGroupedHand<JSX.Element>()),\n            readonlyArray.map(readonlyTuple.snd))}\n        </SuitList>\n      )}}\n    </Decode>\n  }</>\n}\n\nconst SelectionDetails = () => {\n  const selected = useAppSelector(state => state.selection.selectedBlockKey)\n\n  const path = useAppSelector(state => pipe(selected, option.map(s => selectPath(state.system, s)), option.toNullable))\n  const bid = useAppSelector(state => pipe(selected,\n    option.chain(s => pipe(selectNode(state.system, s), option.fromNullable)),\n    option.chain(n => pipe(n.bid, option.fromNullable)),\n    option.chain(option.fromEither),\n    option.toNullable))\n  const errors = useAppSelector(state => selectErrors(state.system))\n  const satisfies = useAppSelector(selectHandsSatisfySelectedPath)\n\n  return (\n    <div>\n      {errors.length > 0 && <section>\n        <h3>Errors</h3>\n        <ul>{errors.map((e, i) => <li key={i}>{draw(e)}</li>)}</ul>\n        </section>}\n\n      {path && <section>\n        <h3>Selected Path</h3>\n        {path.map(x => x.text).join(\" > \")}\n      </section>}\n\n      {bid && <section>\n        <h3>Selected Bid</h3>\n        {pipe(bid, option.fromNullable, option.map(JSON.stringify), option.toNullable)}\n      </section>}\n\n      <section>\n        <h3>Test Hands</h3>\n        <table>\n          <thead>\n            <tr>\n              <HandCol>Opener</HandCol>\n              <HandCol>Responder</HandCol>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><HandInput type=\"opener\" /></td>\n              <td><HandInput type=\"responder\" /></td>\n            </tr>\n            <tr>\n              <td><Hand type=\"opener\" /></td>\n              <td><Hand type=\"responder\" /></td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      {satisfies !== null && <section>\n        <h3>Satisfies</h3>\n        {satisfies.toString()}\n      </section>}\n    </div>\n  )\n}\n\nexport default SelectionDetails","import Editor from './Editor';\nimport SelectionDetails from './SelectionDetails';\n\nconst App = () => {\n  return (\n    <div className=\"App\">\n      <div style={{display: \"inline-block\", width: '50%'}}> \n        <Editor />\n        ---\n        <SelectionDetails />\n      </div>\n      {/* <div style={{display: \"inline-block\", width: '50%'}}>\n        <TestHand\n      </div> */}\n    </div>\n  )\n}\n\nexport default App\n","import { Action, ThunkAction, configureStore } from '@reduxjs/toolkit';\n\nimport reducer from '../reducers';\n\nexport const store = configureStore({\n  reducer: reducer\n});\n\nexport type AppDispatch = typeof store.dispatch;\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppThunk<ReturnType = void> = ThunkAction<\n  ReturnType,\n  RootState,\n  unknown,\n  Action<string>\n>;\n","import './index.css';\n\nimport * as serviceWorker from './serviceWorker';\n\nimport App from './components';\nimport { Provider } from 'react-redux';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { store } from './app/store';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}