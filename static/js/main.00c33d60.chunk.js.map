{"version":3,"sources":["workers/dds.worker.ts","workers/deal.worker.ts","workers/satisfies.worker.ts","webpack:///./src/workers/dds.worker.ts?517b","webpack:///./src/workers/deal.worker.ts?9d69","webpack:///./src/workers/satisfies.worker.ts?62d8","serviceWorker.ts","model/serialization.ts","model/evaluation.ts","parse/bid.peg.g.ts","app/hooks.ts","lib/object.ts","lib/index.ts","model/deck.ts","model/bridge.ts","model/job.ts","model/score.ts","model/analyze.ts","services/server.ts","lib/pool.ts","services/idb.ts","workers/index.ts","reducers/generator.ts","model/stats.ts","reducers/profile.ts","model/system.ts","model/system/core.ts","model/system/expander.ts","model/system/validation.ts","parse/hand.peg.g.ts","parse/bid.ts","parse/hand.ts","parse/index.ts","reducers/system.ts","components/core/HandView.tsx","components/core/DoubleDummyResultView.tsx","components/stats/SolutionStats.tsx","components/core/BidPath.tsx","components/core/Fractional.tsx","components/core/Percentage.tsx","components/stats/StatsPath.tsx","components/Analyses.tsx","model/system/satisfaction.ts","reducers/selection.ts","components/Editor.tsx","components/Errors.tsx","components/Jobs.tsx","components/SelectionDetails.tsx","reducers/settings.ts","components/Settings.tsx","reducers/index.ts","components/core/Monad.tsx","components/SelectionGenerators.tsx","components/HandEditor.tsx","components/TestHands.tsx","components/index.tsx","app/store.ts","index.tsx"],"names":["inst","wrap","Worker","module","exports","f","this","Boolean","window","location","hostname","match","i","s","h","d","c","ASTKinds","useAppDispatch","useDispatch","useAppSelector","useSelector","get","key","obj","assertUnreachable","x","Error","JSON","stringify","ordAscending","array","pipe","number","Ord","ord","contramap","indexOf","ordDescending","flow","reverse","suits","eqSuit","eq","eqStrict","ordSuitDescending","rankStrings","RankB","t","RankC","is","validate","r","eqRank","ordRankAscending","ordRankDescending","ranks","readonlyArray","mapWithIndex","idx","_","decode","right","honors","takeRight","rankFromString","findIndex","r2","string","Eq","equals","option","chain","lookup","eqCard","struct","suit","rank","ordCardDescending","getMonoid","concat","cards","RNEA","makeBy","Math","floor","getOrdGroupedHand","zeroGroupedHand","S","H","D","C","groupHandBySuits","hand","readonlySet","toReadonlyArray","fromReadonlyArray","fold","groupBy","readonlyRecord","map","union","getUnionMonoid","engine","MersenneTwister19937","autoSeed","newDeck","shuffle","directions","eqDirection","eqHand","RS","getEq","eqDeal","strains","eqStrain","ordStrain","minors","boneChart","dealer","deal","boardNumber","nonContractBids","eqNonContractBid","isNonContractBid","b","RA","elem","eqContractBid","level","strain","ordContractBid","contractBids","apply","sequenceS","Apply","sort","isContractBid","eqBid","fromEquals","y","modifier","DateNumberB","now","Date","getTime","getGenericProgress","job","type","progress","initProgress","value","O","some","unitsDone","updateDate","speed","none","updateProgress","M","p","avg","alt","GenerationIdB","id","UuidTool","isUuid","AnalysisIdB","zeroAnalysis","paths","newUuid","name","length","generations","ConstrainedBidPathHashC","hash","getBidPathHash","cb","objectHash","initJobProgress","JobIdB","estimatedTimeRemaining","Do","apS","startDate","bind","o","unitsInitial","serializedHandL","iso","decodedSerializedHandL","either","reverseGet","getUuidQuads","fromPredicate","Uuid","uuid","toBytes","takeLeft","byte","unfold","DealUuidB","reduce","replicate","counts","directionIndex","every","count","dealUuidToDeal","encode","readonlyNonEmptyArray","zip","card","readonlyTuple","fst","snd","encodeDealAsUuid","foldMapWithIndex","trivial","direction","chunksOf","toArray","toString","serializedDealL","serializedBoardL","serializedContractBidL","bid","parseInt","charAt","serializedBidL","SerializedBidPathB","split","serializedBidPathL","intersperse","foldMap","Monoid","identity","contractPointMultiplier","contractModMultiplier","subtractBookTricks","tricks","making","contract","oddTricks","getOddTricks","fromEither","whenMaking","info","constant","contractPoints","vulnerableMultiplier","isVulnerable","getModified","doubledPenalties","partScorePoints","score","scoreComponents","overtrickPoints","overtricks","getOrElseW","multiplier","slamPoints","modifierPoints","penaltyPoints","swap","undertricks","MonoidSum","gamePoints","ScoreC","flattenNestedCounts","flap","traverseWithIndex","writer","getApplicative","tell","cs","pass","evaluate","table","RR","inner","outer","outerKey","innerKey","transpose","initialBids","prepend","getHcp","max","zeroShape","sortShape","makeShape","eqShape","zeroSpecificShape","getHandSpecificShape","semigroup","first","getHandShape","suitCounts","getOrElse","baseUrl","process","safeFetch","taskEither","tryCatchK","toError","ping","fetch","chainTaskK","response","text","filterOrElse","getRequestBody","hcp","shape","toUndefined","getRequestBodyWithoutSolution","postDeals","deals","task","of","body","method","pool","ctor","doWork","input$","maxParallel","navigator","hardwareConcurrency","Observable","resultObserver","idleWorker$$","Subject","completed","sent","finished","workers","index","cachedWorker","factory","terminate","processing","sub","tap","worker","finalize","complete","forEach","mergeMap","item","from","next","subscribe","w","unsubscribe","deleteDb","TE","tryCatch","deleteDB","getDb","openDB","upgrade","db","createObjectStore","createIndex","getByIndex","getAllFromIndex","getBatchIdsByGenerationId","generationId","row","batchId","uniq","deleteByGenerationId","transaction","chainFirst","tran","objectStore","getAllKeys","traverseArray","delete","done","observeSolutions","vulnerability","DDSWorker","getResult","ObE","bimap","board","slice","createSlice","initialState","jobs","reducers","scheduleJob","state","action","analysisId","estimatedUnitsInitial","push","castDraft","payload","parameter","context","dependsOn","completedDate","running","error","startJob","find","j","jobId","completeJob","reducer","meta","splice","prepare","constVoid","removeJob","reportDeals","jobType","reportSatisfies","result","getUnionSemigroup","testedCount","path","satisfiesCount","reportSolutions","solutions","keys","actions","selectJobById","memoize","findFirst","generateDeals","append","DealWorker","genDeals","observeDeals","err","concatWith","generateSatisfies","fromTaskEither","fromObservable","bindTo","isRight","Ob","group","SatisfiesWorker","satisfiesBatch","observeSatisfies","withJobType","action$","state$","filter","a","generator","epics","ObO","EMPTY","results","SerializedKeyL","columns","sequenceT","aggregate","rollup","object","mapFst","head","getStats","ddt","fromFoldable","Foldable","aq","ct","totalRows","average","mean","stdev","analyses","selectedAnalysis","addAnalysis","analysis","deleteAnalysis","removeAnalysis","selectAnalysis","has","setAnalysisName","addJobToAnalysis","dealCount","satisfies","solutionStats","g","generation","RT","stats","bidPath","isNone","profile","fromTask","observableEither","selectAllAnalyses","selectSelectedAnalysis","selectAnalysisById","selectGenerationByAnalysis","flatten","forest","T","items","getPathForest","make","getAllLeafPaths","node","getSemigroup","filterMap","extendTreeWithSiblings","eqA","siblings","u","difference","extendForestWithSiblings","withImplicitPasses","bs","exists","syntax","collectErrors","traverse","TH","E","mapLeft","sequence","chainCollectedErrors","fa","getChain","constraintTrue","predFalse","constFalse","quantifier","constTrue","ps","m","P","getMonoidAny","forall","getMonoidAll","rangeCheck","range","between","min","isPointRange","isSuitRange","suitCompare","op","left","lt","leq","geq","gt","getComparator","toRankSet","contextualConstraintTypes","separate","isContextualConstraint","satisfiesBasic","suitHonors","cardSet","intersection","honorSet","isSubset","suitTop","compare","minRank","handShape","record","isSpecificShape","ordBid","fromCompare","ordConstrainedBid","zeroContext","force","primarySuit","secondarySuit","contextL","Lens","fromProp","bidL","pathL","forceL","primarySuitL","secondarySuitL","contextO","Optional","fromOptionProp","forceO","quantifierS","ofS","satisfiesContextual","recur","constraints","existsS","constraint","not","modify","set","splitAt","tail","higher","lower","gets","optionT","Functor","otherSuit","satisfiesS","isSuit","syntaxTrue","syntaxFalse","pathReversed","empty","traversed","labels","RM","pathReversedL","siblingsL","traversedL","labelsL","eqSyntacticBid","sb","otherwise","rights","takeLeftWhile","wrapShapes","syntaxBalanced","syntaxSemiBalanced","expandSpecifier","specifier","pure","expandOnce","Applicative","wilt","separated","these","fromOptions","connective","Monad","fromOption","definition","c0","upsertAt","labelDef","labelRef","eitherT","sequenceArray","expand","modifyContext","modifiers","expandBid","apSecond","e","reason","traversePeers","expandPeers","expandedBid","expandedChildForest","bidPathSorted","forestSorted","tree","validateS","n","resetForce","continueForce","updateForceS","isGameLevel","isSlamLevel","ap","checkPassS","isSome","getOption","boolean","checkFinal","pathIsSound","apFirst","forestIsSound","validateTree","Digit","literal","kind","Number","Parser","input","pos","negating","memoSafe","$scope$Constraint$memo","Map","overallPos","line","offset","clear","$$dpth","$$cr","run","$scope$spec","$$res","matchBidSpec","match$EOF","Start","spec","$scope$bid","$scope$constraints","matchBid","matchBidSpecConstraintList","BidSpec","regexAccept","String","raw","matchConstraintList","BidSpecConstraintList","choice","matchBid_1","matchBid_2","matchContractBid","matchNonContractBid","$scope$level","$scope$specifier","matchDigit","matchStrainSpecifier","ContractBid","matchStrainSpecifier_1","matchStrainSpecifier_2","matchStrainSpecifier_3","matchStrainSpecifier_4","matchWildcard","matchMajor","matchMinor","matchStrain","$scope$v","Wildcard","v","Major","Minor","matchPass","Pass","matchStrain_1","matchStrain_2","matchSuit","matchNotrump","matchSuit_1","matchSuit_2","matchSuit_3","matchSuit_4","matchClub","matchDiamond","matchHeart","matchSpade","Club","Diamond","Heart","Spade","Notrump","Honor","loop","matchConstraintListItem","$scope$constraint","matchConstraint","ConstraintListItem","$scope$pos","mark","memo","undefined","reset","$scope$oldMemoSafe","lastRes","lastPos","res","matchConstraint_1","matchConstraint_2","matchConstraint_3","matchConstraint_4","matchConstraint_5","matchConstraint_6","matchConstraint_7","matchConstraint_8","matchConstraint_9","matchConstraint_10","matchConstraint_11","matchConstraint_12","matchConstraint_13","matchConstraint_14","matchConstraint_15","matchConstraint_16","matchConstraint_17","matchConstraint_18","end","matchConst","matchOr","matchAnd","matchNot","matchOtherwise","matchDistribution","matchResponse","matchSuitRange","matchSuitBound","matchSuitComparison","matchSuitHonors","matchSuitTop","matchSuitRank","matchPointRange","matchPointBound","matchOtherBid","matchLabelDef","matchLabelRef","matchConst_1","matchConst_2","matchTrue","matchFalse","True","False","$scope$left","$scope$right","Or","And","matchNot_$0","Not","matchNot_$0_1","matchNot_$0_2","Otherwise","$scope$lower","$scope$upper","matchNumber","PointRange","upper","$scope$value","$scope$qualifier","matchBoundQualifier","PointBound","qualifier","$scope$suit","matchSuitSpecifier","SuitRange","SuitBound","matchSuitSpecifier_1","matchSuitSpecifier_2","matchSuitSpecifier_3","matchSuitSpecifier_4","matchSuitSpecifier_5","matchSuitSpecifier_6","matchOtherMajor","matchOtherMinor","OtherMajor","OtherMinor","$scope$op","matchSuitComparisonOperator","SuitComparison","matchSuitComparisonOperator_1","matchSuitComparisonOperator_2","matchSuitComparisonOperator_3","matchSuitComparisonOperator_4","matchSuitComparisonOperator_5","SuitComparisonOperator_1","SuitComparisonOperator_2","SuitComparisonOperator_3","SuitComparisonOperator_4","SuitComparisonOperator_5","$scope$honors","matchHonor","SuitHonors","$scope$x","$scope$y","SuitTop","matchBoundQualifier_1","matchBoundQualifier_2","matchBoundQualifier_3","matchPlus","matchMinus","matchEquals","Plus","Minus","Equals","$scope$strain","OtherBid","matchDistribution_1","matchDistribution_2","matchDistribution_3","matchDistribution_4","matchDistribution_5","matchBalanced","matchSemiBalanced","matchUnbalanced","matchAnyShape","matchSpecificShape","Balanced","SemiBalanced","Unbalanced","AnyShape","$scope$S","$scope$H","$scope$D","$scope$C","SpecificShape","matchSuitRank_1","matchSuitRank_2","matchPrimary","matchSecondary","Primary","Secondary","matchResponse_1","matchResponse_2","matchResponse_3","matchResponse_4","matchForceOneRound","matchForceGame","matchForceSlam","matchRelay","ForceOneRound","ForceGame","ForceSlam","Relay","$scope$label","matchLabel","LabelDef","label","LabelRef","Label","$scope$literal","mrk","ans","matchStart","ast","errs","rec","ErrorTracker","clearMemos","getErr","func","star","fn","fns","dpth","cr","reg","RegExp","lastIndex","tryConsume","substring","negated","exec","lineJmp","lind","oneg","rule","$scope$memoRes","$scope$result","et","$EOF","SyntaxErr","expmatches","mxpos","regexset","Set","pmatches","att","add","getConnectiveItems","AST","suitSpecifier","bindValueQualifier","constraintList","fromArray","parseBid","parse","Card","$scope$hand","matchHand","Hand","$scope$cards","matchCard","Suit","$scope$c","parseHand","handE","cur","convertErrors","FS","actual","DE","parseResultToEither","fromNullable","getDecoder","parser","decodeBid","bidSpec","constrainedBid","decodeHand","eqBlockKey","decodedBidAdapter","createEntityAdapter","system","decodedBids","getInitialState","setSystem","root","parents","curr","depth","buildForest","removeConstraintsByBlockKey","removeMany","cacheSystemConstraints","setMany","constrainedBidSelectors","getSelectors","getCachedBidByKey","constrainedBids","fromNullableK","selectById","selectBidByKey","selectBidPathUpToKey","findFirstMap","zero","selectRules","selectCompleteSyntaxForest","lefts","bids","options","implicitPass","selectCompleteConstraintForest","bidForest","selectSystemWithErrors","selectPristineSystem","getRightOnly","selectValidConstrainedBidPaths","getRight","selectCompleteBidPathUpToKey","fromEitherK","cbPath","selectCompleteBidByKey","last","eqBidPath","selectErrorTree","pathForest","getLeft","errors","selectErrorsByKey","RankList","styled","ol","RankListItem","li","RankView","SuitList","SuitListItem","SuitView","className","HandView","groupedHand","StrainSpan","span","DoubleDummyTableView","style","fontWeight","verticalAlign","round","DoubleDummyResultView","SolutionStats","SuitSpan","ContractBidView","NonContractBidView","BidView","BidPath","Fractional","numerator","denominator","decimalPlaces","pow","Percentage","StatsPath","FlexList","ul","FlexListItem","AnalysisView","toNullable","dispatch","onRemoveClick","useCallback","onSelectClick","onNameChange","onChange","target","onClick","StatsPathItem","pathHash","solveCount","len","useState","showTables","setShowTables","onSolveClick","satisfiedDeals","compact","solution","getDealsWithSolutionsByPath","StatsPathContainer","div","GenerationView","useMemo","onSatisfiesClick","getHash","SelectedAnalysis","generateCount","settings","onGenerateDealsClick","Analyses","onCreateClick","alternate","opener","responder","val","Gen","specialRelayCase","satisfiesPath","MonoidAll","selectedBlockKey","setHands","hands","createAsyncThunk","rejectWithValue","l","N","W","genBoardFromHands","observable","toTask","genUntilCondition","limit","condition","tailRec","deck","genMatchingOf","partition","setSelectedBlockKey","setHand","genOnce","getHandsMatchingPath","genHandsNotMatchingAnyOf","predicate","openerMinHcp","genHandsMatchingExactlyOneOf","genHandsMatchingMoreThanOneOf","extraReducers","builder","addCase","fulfilled","selectBlockKey","selectHand","EditorDiv","getDescriptorFromContentBlock","getKey","getText","getDepth","eqContentBlock","monoid","concatAll","getBlocks","editorState","getCurrentContent","getBlocksAsArray","Editor","EditorState","createEmpty","setEditorState","blocks","setBlocks","selection","setTimeout","localStorage","setItem","convertToRaw","newBlocks","same","removed","added","isEmpty","newSelectedBlockKey","getSelection","getFocusKey","useEffect","savedEditorState","getItem","createWithContent","convertFromRaw","RichUtils","toggleBlockType","keyBindingFn","keyCode","newEditorState","onTab","getDefaultKeyBinding","GridContainer","ExpandErrorView","ValidationErrorView","BidErrorsView","ErrorGrid","ErrorForest","flattenedForest","Errors","isPristine","isLeft","draw","DateView","date","_tag","JobList","JobListItem","JobView","onStartClick","timeRemaining","Jobs","SelectionDetails","selected","syntacticBid","data","setInitial","Object","setProperty","setSettingsProperty","setInitialSettings","SettingsItem","prop","onChanged","children","newValue","width","Settings","stored","newSettings","onDeleteDatabaseClick","reload","checked","rootEpic","combineEpics","generatorEpics","profileEpics","selectPathsSatisfyHands","Option","onSuccess","onNone","GenerateOnce","GenerateMatchZero","bidPaths","minHcp","setMinHcp","GenerateMatchOne","GenerateMatchMany","GenerateMatchSelected","SelectionGenerators","HandInput","setValue","storageKey","encodedHand","onSetHand","savedHand","placeholder","onBlur","HandCol","th","HandEditor","getResultCallback","TestHands","App","display","float","rel","href","epicMiddleware","createEpicMiddleware","store","configureStore","middleware","getDefaultMiddleware","ReactDOM","render","StrictMode","document","getElementById","serviceWorker","ready","then","registration","unregister","catch","console","message"],"mappings":"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","file":"static/js/main.00c33d60.chunk.js","sourcesContent":["var wrap = require('comlink').wrap,Worker = require(\"!worker-loader?{}!/home/runner/work/bridge/bridge/node_modules/comlink-loader/dist/comlink-worker-loader.js!/home/runner/work/bridge/bridge/node_modules/react-scripts/node_modules/babel-loader/lib/index.js??ref--5-oneOf-2!/home/runner/work/bridge/bridge/src/workers/dds.worker.ts\"),inst;module.exports = function f() {if (this instanceof f) return wrap(Worker());return inst || (inst = wrap(Worker()));};","var wrap = require('comlink').wrap,Worker = require(\"!worker-loader?{}!/home/runner/work/bridge/bridge/node_modules/comlink-loader/dist/comlink-worker-loader.js!/home/runner/work/bridge/bridge/node_modules/react-scripts/node_modules/babel-loader/lib/index.js??ref--5-oneOf-2!/home/runner/work/bridge/bridge/src/workers/deal.worker.ts\"),inst;module.exports = function f() {if (this instanceof f) return wrap(Worker());return inst || (inst = wrap(Worker()));};","var wrap = require('comlink').wrap,Worker = require(\"!worker-loader?{}!/home/runner/work/bridge/bridge/node_modules/comlink-loader/dist/comlink-worker-loader.js!/home/runner/work/bridge/bridge/node_modules/react-scripts/node_modules/babel-loader/lib/index.js??ref--5-oneOf-2!/home/runner/work/bridge/bridge/src/workers/satisfies.worker.ts\"),inst;module.exports = function f() {if (this instanceof f) return wrap(Worker());return inst || (inst = wrap(Worker()));};","module.exports = function() {\n  return new Worker(__webpack_public_path__ + \"612c7bff16da9beb6d2f.worker.js\");\n};","module.exports = function() {\n  return new Worker(__webpack_public_path__ + \"3526eb52208353fc29c6.worker.js\");\n};","module.exports = function() {\n  return new Worker(__webpack_public_path__ + \"8d6c793164bf6eee339e.worker.js\");\n};","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import { array, either, option, ord, readonlyArray, readonlyNonEmptyArray, readonlyRecord, readonlySet, readonlyTuple, refinement, string } from 'fp-ts';\nimport { Either } from 'fp-ts/lib/Either';\nimport { flow, identity, pipe } from 'fp-ts/lib/function';\nimport { ReadonlyNonEmptyArray } from 'fp-ts/lib/ReadonlyNonEmptyArray';\nimport * as t from 'io-ts';\nimport * as D from 'io-ts/Decoder';\nimport * as E from 'io-ts/Encoder';\nimport * as iso from 'monocle-ts/Iso';\nimport { O } from 'ts-toolbelt';\nimport { Uuid, UuidLike, UuidTool } from 'uuid-tool';\n\nimport { decodeHand } from '../parse';\nimport { Bid, Board, ContractBid, Deal, directions, isNonContractBid, Strain } from './bridge';\nimport { Card, cards, eqCard, Hand, ordCardDescending } from './deck';\n\nexport type DecodedHand = ReturnType<typeof decodeHand>\nexport type SerializedHand = ReadonlyArray<Card>\nexport type DecodedSerializedHand = DecodedHand extends Either<infer L, unknown> ? either.Either<L, SerializedHand> : never\n\nexport const serializedHandL : iso.Iso<Hand, SerializedHand> = iso.iso(\n  readonlySet.toReadonlyArray(ordCardDescending),\n  readonlySet.fromReadonlyArray(eqCard)\n)\n\nconst liftEither = <E>() => <A, B>(i: iso.Iso<A, B>) => iso.iso<Either<E, A>, Either<E, B>>(either.map(i.get), either.map(i.reverseGet))\nexport const decodedSerializedHandL = liftEither<D.DecodeError>()(serializedHandL)\n\nexport const decodeUuid : D.Decoder<string, Uuid> = {\n  decode: flow(\n    either.fromPredicate(UuidTool.isUuid, s => D.error(s, \"Invalid uuid string\")),\n    either.map(s => new Uuid(s)))\n}\n\nconst MASK = 0b11 as const\nconst getUuidQuads = (uuid: UuidLike) => \n  pipe(new Uuid(uuid.id).toBytes(),\n    readonlyArray.takeLeft(13),\n    readonlyArray.chain(flow(byte =>\n      readonlyArray.unfold([byte, 4 as number] as const, ([byte, i]) =>\n        i === 0\n        ? option.none\n        : option.some([byte & MASK, [byte >> 2, i - 1]] as const)),\n        readonlyArray.reverse))) as ReadonlyNonEmptyArray<number>\n\nexport type SerializedDeal = t.Branded<UuidLike, { readonly Deal: unique symbol }>\nconst isDealUuid: refinement.Refinement<UuidLike, SerializedDeal> =\n  (uuid): uuid is SerializedDeal =>\n    pipe(uuid,\n      getUuidQuads,\n      readonlyArray.reduce(\n        array.replicate(4, 0 as number),\n        (counts, directionIndex) =>\n          { counts[directionIndex] += 1; return counts }),\n      readonlyArray.every(count => count === 13))\n\nconst DealUuidB = t.brand(t.type({ id: t.string }), isDealUuid, 'Deal')\n\nconst dealUuidToDeal: E.Encoder<Deal, SerializedDeal> = {\n  encode: flow(\n    getUuidQuads,\n    readonlyNonEmptyArray.zip(pipe(cards, readonlyNonEmptyArray.sort(ordCardDescending))),\n    readonlyNonEmptyArray.map(([idx, card]) => [directions[idx], card] as const),\n    readonlyNonEmptyArray.groupBy(readonlyTuple.fst),\n    readonlyRecord.map(flow(\n      readonlyNonEmptyArray.map(readonlyTuple.snd),\n      readonlySet.fromReadonlyArray(eqCard))))\n  }\n\ntype CardDirectionPair = readonly [Card, number]\nconst encodeDealAsUuid: E.Encoder<SerializedDeal, Deal> = {\n  encode: flow(\n    readonlyRecord.foldMapWithIndex(ord.trivial)(readonlyArray.getMonoid<CardDirectionPair>())((direction, cards) =>\n      pipe(cards,\n        readonlySet.toReadonlyArray<Card>(ord.trivial),\n        readonlyArray.map(c => [c, directions.indexOf(direction)]))),\n    readonlyArray.sort(ord.contramap((p: CardDirectionPair) => p[0])(ordCardDescending)),\n    readonlyArray.map(readonlyTuple.snd),\n    readonlyArray.chunksOf(4),\n    readonlyArray.map(readonlyArray.reduce(0, (byte, directionIndex) => (byte << 2) + directionIndex)),\n    readonlyArray.concat(readonlyArray.replicate(3, 0)),\n    readonlyArray.toArray,\n    x => (DealUuidB.decode({ id: new Uuid(x).toString() }) as either.Right<SerializedDeal>).right)\n  }\n\nexport const serializedDealL = iso.iso<Deal, SerializedDeal>(\n  encodeDealAsUuid.encode,\n  dealUuidToDeal.encode\n)\n\nexport type SerializedBoard = O.Update<Board, \"deal\", SerializedDeal>\nexport const serializedBoardL = iso.iso<Board, SerializedBoard>(\n  b => ({ ...b,\n    deal: serializedDealL.get(b.deal),\n  }),\n  b => ({ ...b,\n    deal: serializedDealL.reverseGet(b.deal),\n  })\n)\n\nexport type SerializedBidPath = t.Branded<string, { readonly BidPath: unique symbol }>\nexport const isBidPath: refinement.Refinement<string, SerializedBidPath> =\n  (s): s is SerializedBidPath =>\n    pipe(s,\n      string.split(\".\"),\n      readonlyArray.every(s => s.length === 2 || isNonContractBid(s)))\n\nexport const serializedContractBidL: iso.Iso<ContractBid, string> = iso.iso(\n  bid => `${bid.level}${bid.strain}`,\n  bid => ({\n    level: parseInt(bid.charAt(0)),\n    strain: bid.charAt(1) as Strain\n  })\n)\n\nexport const serializedBidL : iso.Iso<Bid, string> = iso.iso(\n  bid => isNonContractBid(bid) ? bid : serializedContractBidL.get(bid),\n  bid => isNonContractBid(bid) ? bid : serializedContractBidL.reverseGet(bid)\n)\n\nconst SerializedBidPathB = t.brand(t.string, isBidPath, \"BidPath\")\nexport const serializedBidPathL = iso.iso<readonlyNonEmptyArray.ReadonlyNonEmptyArray<Bid>, SerializedBidPath>(\n  flow(\n    readonlyArray.map(serializedBidL.get),\n    readonlyArray.intersperse(\".\"),\n    readonlyArray.foldMap(string.Monoid)(identity),\n    x => (SerializedBidPathB.decode(x) as either.Right<SerializedBidPath>).right),\n  flow(\n    string.split(\".\"),\n    readonlyNonEmptyArray.map(serializedBidL.reverseGet)))","import { eq, number, option, ord, readonlyArray, readonlyRecord, readonlySet, readonlyTuple, semigroup } from 'fp-ts';\nimport { flow, pipe } from 'fp-ts/lib/function';\n\nimport { groupHandBySuits, Hand, ordCardDescending, Rank, Suit } from './deck';\n\nexport const getRankHcp = (rank: Rank) =>\n  Math.max(0, rank - 10)\n\nexport const getHcp =\n  flow(\n    readonlySet.toReadonlyArray(ordCardDescending),\n    readonlyArray.foldMap(number.MonoidSum)(c => getRankHcp(c.rank)))\n\nexport type AnyShape = readonly [number, number, number, number]\nexport const zeroShape: AnyShape = [0, 0, 0, 0]\nexport const sortShape = (s: AnyShape) => pipe(s, readonlyArray.sort(ord.reverse(number.Ord))) as AnyShape\nexport const makeShape = (...counts: AnyShape) =>\n  pipe(counts, sortShape)\nexport const eqShape : eq.Eq<AnyShape> =\n  eq.contramap(sortShape)(readonlyArray.getEq(number.Eq))\n\nexport type SpecificShape = Record<Suit, number>\nexport const makeSpecificShape = (s: number, h: number, d: number, c: number) : SpecificShape => ({\n  S: s,\n  H: h,\n  D: d,\n  C: c\n})\nexport const zeroSpecificShape = makeSpecificShape(0, 0, 0, 0)\n\nexport const getHandSpecificShape = (hand: Hand) : SpecificShape =>\n  pipe(hand,\n    groupHandBySuits,\n    readonlyRecord.map(x => x.length),\n    readonlyRecord.union(semigroup.first<number>())(zeroSpecificShape),\n    (suits: readonlyRecord.ReadonlyRecord<Suit, number>) => suits)\n\nexport const getHandShape = (hand: Hand) : AnyShape =>\n  pipe(hand,\n    getHandSpecificShape,\n    readonlyRecord.toReadonlyArray,\n    readonlyArray.map(readonlyTuple.snd),\n    suitCounts => readonlyArray.mapWithIndex((idx, _) =>\n      pipe(suitCounts, readonlyArray.lookup(idx), option.getOrElse(() => 0)))(zeroShape)) as AnyShape","/* AutoGenerated Code, changes may be overwritten\n* INPUT GRAMMAR:\n* Start := spec=BidSpec $\n* BidSpec := bid=Bid constraints=BidSpecConstraintList?\n* BidSpecConstraintList := ': ' constraints=ConstraintList\n* Bid := ContractBid | NonContractBid\n* ContractBid := level=Digit specifier=StrainSpecifier\n* StrainSpecifier := Wildcard | Major | Minor | Strain\n* Wildcard := v='X'\n* Major := v='M'\n* Minor := v='m'\n* NonContractBid := Pass\n* Pass := v='P'\n* Strain := Suit | Notrump\n* Suit := Club | Diamond | Heart | Spade\n* Club := v='C'\n* Diamond := v='D'\n* Heart := v='H'\n* Spade := v='S'\n* Notrump := v='N' 'T'?\n* Honor := v='[AKQJT]'\n* ConstraintList := ConstraintListItem+\n* ConstraintListItem := constraint=Constraint ' '?\n* Constraint :=\n*     Const\n*   | Or\n*   | And\n*   | Not\n*   | Otherwise\n*   | Distribution\n*   | Response\n*   | SuitRange\n*   | SuitBound\n*   | SuitComparison\n*   | SuitHonors\n*   | SuitTop\n*   | SuitRank\n*   | PointRange\n*   | PointBound\n*   | OtherBid\n*   | LabelDef\n*   | LabelRef\n* Const := True | False\n* True := v='true'\n* False := v='false'\n* Or := left=Constraint ' or ' right=Constraint\n* And := '\\(' constraints=ConstraintList '\\)'\n* Not := {'not' | '!'} ' '? constraint=Constraint\n* Otherwise := v='else'\n* PointRange := lower=Number '-' upper=Number\n* PointBound := value=Number qualifier=BoundQualifier\n* SuitRange := lower=Digit '-' upper=Digit suit=SuitSpecifier\n* SuitBound := value=Number qualifier=BoundQualifier suit=SuitSpecifier\n* SuitSpecifier := Wildcard | Major | Minor | OtherMajor | OtherMinor | Suit\n* OtherMajor := v='oM'\n* OtherMinor := v='om'\n* SuitComparison := left=SuitSpecifier op=SuitComparisonOperator right=SuitSpecifier\n* SuitComparisonOperator := v='<=' | v='>=' | v='=' | v='<' | v='>'\n* SuitHonors := suit=SuitSpecifier honors=Honor+\n* SuitTop := suit=SuitSpecifier x='[0-5]' '/' y='[1-5]'\n* BoundQualifier := Plus | Minus | Equals\n* Plus := v='\\+'\n* Minus := v='\\-'\n* Equals := v='='\n* OtherBid := level=Number strain=Strain\n* Distribution := Balanced | SemiBalanced | Unbalanced | AnyShape | SpecificShape\n* Balanced := v='BAL'\n* SemiBalanced := v='semiBAL'\n* Unbalanced := v='unBAL'\n* AnyShape := v='[0-9]{4}' '\\*'\n* SpecificShape := S=Digit H=Digit D=Digit C=Digit\n* SuitRank := Primary | Secondary\n* Primary := suit=SuitSpecifier '1'\n* Secondary := suit=SuitSpecifier '2'\n* Response := ForceOneRound | ForceGame | ForceSlam | Relay\n* ForceOneRound := v='F1'\n* ForceGame := v='FG'\n* ForceSlam := v='FS'\n* Relay := '->' bid=OtherBid\n* LabelDef := '\\'' label=Label '\\': ' constraints=ConstraintList\n* LabelRef := '\\'' label=Label '\\''\n* Label := v='[0-9a-zA-z-_]+'\n* Digit := literal='[0-9]'\n*   .value = number { return parseInt(literal) }\n* Number := literal='[0-9]+'\n*   .value = number { return parseInt(literal) }\n*/\ntype Nullable<T> = T | null;\ntype $$RuleType<T> = () => Nullable<T>;\ninterface ASTNodeIntf {\n    kind: ASTKinds;\n}\nexport enum ASTKinds {\n    Start = \"Start\",\n    BidSpec = \"BidSpec\",\n    BidSpecConstraintList = \"BidSpecConstraintList\",\n    Bid_1 = \"Bid_1\",\n    Bid_2 = \"Bid_2\",\n    ContractBid = \"ContractBid\",\n    StrainSpecifier_1 = \"StrainSpecifier_1\",\n    StrainSpecifier_2 = \"StrainSpecifier_2\",\n    StrainSpecifier_3 = \"StrainSpecifier_3\",\n    StrainSpecifier_4 = \"StrainSpecifier_4\",\n    Wildcard = \"Wildcard\",\n    Major = \"Major\",\n    Minor = \"Minor\",\n    NonContractBid = \"NonContractBid\",\n    Pass = \"Pass\",\n    Strain_1 = \"Strain_1\",\n    Strain_2 = \"Strain_2\",\n    Suit_1 = \"Suit_1\",\n    Suit_2 = \"Suit_2\",\n    Suit_3 = \"Suit_3\",\n    Suit_4 = \"Suit_4\",\n    Club = \"Club\",\n    Diamond = \"Diamond\",\n    Heart = \"Heart\",\n    Spade = \"Spade\",\n    Notrump = \"Notrump\",\n    Honor = \"Honor\",\n    ConstraintList = \"ConstraintList\",\n    ConstraintListItem = \"ConstraintListItem\",\n    Constraint_1 = \"Constraint_1\",\n    Constraint_2 = \"Constraint_2\",\n    Constraint_3 = \"Constraint_3\",\n    Constraint_4 = \"Constraint_4\",\n    Constraint_5 = \"Constraint_5\",\n    Constraint_6 = \"Constraint_6\",\n    Constraint_7 = \"Constraint_7\",\n    Constraint_8 = \"Constraint_8\",\n    Constraint_9 = \"Constraint_9\",\n    Constraint_10 = \"Constraint_10\",\n    Constraint_11 = \"Constraint_11\",\n    Constraint_12 = \"Constraint_12\",\n    Constraint_13 = \"Constraint_13\",\n    Constraint_14 = \"Constraint_14\",\n    Constraint_15 = \"Constraint_15\",\n    Constraint_16 = \"Constraint_16\",\n    Constraint_17 = \"Constraint_17\",\n    Constraint_18 = \"Constraint_18\",\n    Const_1 = \"Const_1\",\n    Const_2 = \"Const_2\",\n    True = \"True\",\n    False = \"False\",\n    Or = \"Or\",\n    And = \"And\",\n    Not = \"Not\",\n    Not_$0_1 = \"Not_$0_1\",\n    Not_$0_2 = \"Not_$0_2\",\n    Otherwise = \"Otherwise\",\n    PointRange = \"PointRange\",\n    PointBound = \"PointBound\",\n    SuitRange = \"SuitRange\",\n    SuitBound = \"SuitBound\",\n    SuitSpecifier_1 = \"SuitSpecifier_1\",\n    SuitSpecifier_2 = \"SuitSpecifier_2\",\n    SuitSpecifier_3 = \"SuitSpecifier_3\",\n    SuitSpecifier_4 = \"SuitSpecifier_4\",\n    SuitSpecifier_5 = \"SuitSpecifier_5\",\n    SuitSpecifier_6 = \"SuitSpecifier_6\",\n    OtherMajor = \"OtherMajor\",\n    OtherMinor = \"OtherMinor\",\n    SuitComparison = \"SuitComparison\",\n    SuitComparisonOperator_1 = \"SuitComparisonOperator_1\",\n    SuitComparisonOperator_2 = \"SuitComparisonOperator_2\",\n    SuitComparisonOperator_3 = \"SuitComparisonOperator_3\",\n    SuitComparisonOperator_4 = \"SuitComparisonOperator_4\",\n    SuitComparisonOperator_5 = \"SuitComparisonOperator_5\",\n    SuitHonors = \"SuitHonors\",\n    SuitTop = \"SuitTop\",\n    BoundQualifier_1 = \"BoundQualifier_1\",\n    BoundQualifier_2 = \"BoundQualifier_2\",\n    BoundQualifier_3 = \"BoundQualifier_3\",\n    Plus = \"Plus\",\n    Minus = \"Minus\",\n    Equals = \"Equals\",\n    OtherBid = \"OtherBid\",\n    Distribution_1 = \"Distribution_1\",\n    Distribution_2 = \"Distribution_2\",\n    Distribution_3 = \"Distribution_3\",\n    Distribution_4 = \"Distribution_4\",\n    Distribution_5 = \"Distribution_5\",\n    Balanced = \"Balanced\",\n    SemiBalanced = \"SemiBalanced\",\n    Unbalanced = \"Unbalanced\",\n    AnyShape = \"AnyShape\",\n    SpecificShape = \"SpecificShape\",\n    SuitRank_1 = \"SuitRank_1\",\n    SuitRank_2 = \"SuitRank_2\",\n    Primary = \"Primary\",\n    Secondary = \"Secondary\",\n    Response_1 = \"Response_1\",\n    Response_2 = \"Response_2\",\n    Response_3 = \"Response_3\",\n    Response_4 = \"Response_4\",\n    ForceOneRound = \"ForceOneRound\",\n    ForceGame = \"ForceGame\",\n    ForceSlam = \"ForceSlam\",\n    Relay = \"Relay\",\n    LabelDef = \"LabelDef\",\n    LabelRef = \"LabelRef\",\n    Label = \"Label\",\n    Digit = \"Digit\",\n    Number = \"Number\",\n    $EOF = \"$EOF\",\n}\nexport interface Start {\n    kind: ASTKinds.Start;\n    spec: BidSpec;\n}\nexport interface BidSpec {\n    kind: ASTKinds.BidSpec;\n    bid: Bid;\n    constraints: Nullable<BidSpecConstraintList>;\n}\nexport interface BidSpecConstraintList {\n    kind: ASTKinds.BidSpecConstraintList;\n    constraints: ConstraintList;\n}\nexport type Bid = Bid_1 | Bid_2;\nexport type Bid_1 = ContractBid;\nexport type Bid_2 = NonContractBid;\nexport interface ContractBid {\n    kind: ASTKinds.ContractBid;\n    level: Digit;\n    specifier: StrainSpecifier;\n}\nexport type StrainSpecifier = StrainSpecifier_1 | StrainSpecifier_2 | StrainSpecifier_3 | StrainSpecifier_4;\nexport type StrainSpecifier_1 = Wildcard;\nexport type StrainSpecifier_2 = Major;\nexport type StrainSpecifier_3 = Minor;\nexport type StrainSpecifier_4 = Strain;\nexport interface Wildcard {\n    kind: ASTKinds.Wildcard;\n    v: string;\n}\nexport interface Major {\n    kind: ASTKinds.Major;\n    v: string;\n}\nexport interface Minor {\n    kind: ASTKinds.Minor;\n    v: string;\n}\nexport type NonContractBid = Pass;\nexport interface Pass {\n    kind: ASTKinds.Pass;\n    v: string;\n}\nexport type Strain = Strain_1 | Strain_2;\nexport type Strain_1 = Suit;\nexport type Strain_2 = Notrump;\nexport type Suit = Suit_1 | Suit_2 | Suit_3 | Suit_4;\nexport type Suit_1 = Club;\nexport type Suit_2 = Diamond;\nexport type Suit_3 = Heart;\nexport type Suit_4 = Spade;\nexport interface Club {\n    kind: ASTKinds.Club;\n    v: string;\n}\nexport interface Diamond {\n    kind: ASTKinds.Diamond;\n    v: string;\n}\nexport interface Heart {\n    kind: ASTKinds.Heart;\n    v: string;\n}\nexport interface Spade {\n    kind: ASTKinds.Spade;\n    v: string;\n}\nexport interface Notrump {\n    kind: ASTKinds.Notrump;\n    v: string;\n}\nexport interface Honor {\n    kind: ASTKinds.Honor;\n    v: string;\n}\nexport type ConstraintList = ConstraintListItem[];\nexport interface ConstraintListItem {\n    kind: ASTKinds.ConstraintListItem;\n    constraint: Constraint;\n}\nexport type Constraint = Constraint_1 | Constraint_2 | Constraint_3 | Constraint_4 | Constraint_5 | Constraint_6 | Constraint_7 | Constraint_8 | Constraint_9 | Constraint_10 | Constraint_11 | Constraint_12 | Constraint_13 | Constraint_14 | Constraint_15 | Constraint_16 | Constraint_17 | Constraint_18;\nexport type Constraint_1 = Const;\nexport type Constraint_2 = Or;\nexport type Constraint_3 = And;\nexport type Constraint_4 = Not;\nexport type Constraint_5 = Otherwise;\nexport type Constraint_6 = Distribution;\nexport type Constraint_7 = Response;\nexport type Constraint_8 = SuitRange;\nexport type Constraint_9 = SuitBound;\nexport type Constraint_10 = SuitComparison;\nexport type Constraint_11 = SuitHonors;\nexport type Constraint_12 = SuitTop;\nexport type Constraint_13 = SuitRank;\nexport type Constraint_14 = PointRange;\nexport type Constraint_15 = PointBound;\nexport type Constraint_16 = OtherBid;\nexport type Constraint_17 = LabelDef;\nexport type Constraint_18 = LabelRef;\nexport type Const = Const_1 | Const_2;\nexport type Const_1 = True;\nexport type Const_2 = False;\nexport interface True {\n    kind: ASTKinds.True;\n    v: string;\n}\nexport interface False {\n    kind: ASTKinds.False;\n    v: string;\n}\nexport interface Or {\n    kind: ASTKinds.Or;\n    left: Constraint;\n    right: Constraint;\n}\nexport interface And {\n    kind: ASTKinds.And;\n    constraints: ConstraintList;\n}\nexport interface Not {\n    kind: ASTKinds.Not;\n    constraint: Constraint;\n}\nexport type Not_$0 = Not_$0_1 | Not_$0_2;\nexport type Not_$0_1 = string;\nexport type Not_$0_2 = string;\nexport interface Otherwise {\n    kind: ASTKinds.Otherwise;\n    v: string;\n}\nexport interface PointRange {\n    kind: ASTKinds.PointRange;\n    lower: Number;\n    upper: Number;\n}\nexport interface PointBound {\n    kind: ASTKinds.PointBound;\n    value: Number;\n    qualifier: BoundQualifier;\n}\nexport interface SuitRange {\n    kind: ASTKinds.SuitRange;\n    lower: Digit;\n    upper: Digit;\n    suit: SuitSpecifier;\n}\nexport interface SuitBound {\n    kind: ASTKinds.SuitBound;\n    value: Number;\n    qualifier: BoundQualifier;\n    suit: SuitSpecifier;\n}\nexport type SuitSpecifier = SuitSpecifier_1 | SuitSpecifier_2 | SuitSpecifier_3 | SuitSpecifier_4 | SuitSpecifier_5 | SuitSpecifier_6;\nexport type SuitSpecifier_1 = Wildcard;\nexport type SuitSpecifier_2 = Major;\nexport type SuitSpecifier_3 = Minor;\nexport type SuitSpecifier_4 = OtherMajor;\nexport type SuitSpecifier_5 = OtherMinor;\nexport type SuitSpecifier_6 = Suit;\nexport interface OtherMajor {\n    kind: ASTKinds.OtherMajor;\n    v: string;\n}\nexport interface OtherMinor {\n    kind: ASTKinds.OtherMinor;\n    v: string;\n}\nexport interface SuitComparison {\n    kind: ASTKinds.SuitComparison;\n    left: SuitSpecifier;\n    op: SuitComparisonOperator;\n    right: SuitSpecifier;\n}\nexport type SuitComparisonOperator = SuitComparisonOperator_1 | SuitComparisonOperator_2 | SuitComparisonOperator_3 | SuitComparisonOperator_4 | SuitComparisonOperator_5;\nexport interface SuitComparisonOperator_1 {\n    kind: ASTKinds.SuitComparisonOperator_1;\n    v: string;\n}\nexport interface SuitComparisonOperator_2 {\n    kind: ASTKinds.SuitComparisonOperator_2;\n    v: string;\n}\nexport interface SuitComparisonOperator_3 {\n    kind: ASTKinds.SuitComparisonOperator_3;\n    v: string;\n}\nexport interface SuitComparisonOperator_4 {\n    kind: ASTKinds.SuitComparisonOperator_4;\n    v: string;\n}\nexport interface SuitComparisonOperator_5 {\n    kind: ASTKinds.SuitComparisonOperator_5;\n    v: string;\n}\nexport interface SuitHonors {\n    kind: ASTKinds.SuitHonors;\n    suit: SuitSpecifier;\n    honors: Honor[];\n}\nexport interface SuitTop {\n    kind: ASTKinds.SuitTop;\n    suit: SuitSpecifier;\n    x: string;\n    y: string;\n}\nexport type BoundQualifier = BoundQualifier_1 | BoundQualifier_2 | BoundQualifier_3;\nexport type BoundQualifier_1 = Plus;\nexport type BoundQualifier_2 = Minus;\nexport type BoundQualifier_3 = Equals;\nexport interface Plus {\n    kind: ASTKinds.Plus;\n    v: string;\n}\nexport interface Minus {\n    kind: ASTKinds.Minus;\n    v: string;\n}\nexport interface Equals {\n    kind: ASTKinds.Equals;\n    v: string;\n}\nexport interface OtherBid {\n    kind: ASTKinds.OtherBid;\n    level: Number;\n    strain: Strain;\n}\nexport type Distribution = Distribution_1 | Distribution_2 | Distribution_3 | Distribution_4 | Distribution_5;\nexport type Distribution_1 = Balanced;\nexport type Distribution_2 = SemiBalanced;\nexport type Distribution_3 = Unbalanced;\nexport type Distribution_4 = AnyShape;\nexport type Distribution_5 = SpecificShape;\nexport interface Balanced {\n    kind: ASTKinds.Balanced;\n    v: string;\n}\nexport interface SemiBalanced {\n    kind: ASTKinds.SemiBalanced;\n    v: string;\n}\nexport interface Unbalanced {\n    kind: ASTKinds.Unbalanced;\n    v: string;\n}\nexport interface AnyShape {\n    kind: ASTKinds.AnyShape;\n    v: string;\n}\nexport interface SpecificShape {\n    kind: ASTKinds.SpecificShape;\n    S: Digit;\n    H: Digit;\n    D: Digit;\n    C: Digit;\n}\nexport type SuitRank = SuitRank_1 | SuitRank_2;\nexport type SuitRank_1 = Primary;\nexport type SuitRank_2 = Secondary;\nexport interface Primary {\n    kind: ASTKinds.Primary;\n    suit: SuitSpecifier;\n}\nexport interface Secondary {\n    kind: ASTKinds.Secondary;\n    suit: SuitSpecifier;\n}\nexport type Response = Response_1 | Response_2 | Response_3 | Response_4;\nexport type Response_1 = ForceOneRound;\nexport type Response_2 = ForceGame;\nexport type Response_3 = ForceSlam;\nexport type Response_4 = Relay;\nexport interface ForceOneRound {\n    kind: ASTKinds.ForceOneRound;\n    v: string;\n}\nexport interface ForceGame {\n    kind: ASTKinds.ForceGame;\n    v: string;\n}\nexport interface ForceSlam {\n    kind: ASTKinds.ForceSlam;\n    v: string;\n}\nexport interface Relay {\n    kind: ASTKinds.Relay;\n    bid: OtherBid;\n}\nexport interface LabelDef {\n    kind: ASTKinds.LabelDef;\n    label: Label;\n    constraints: ConstraintList;\n}\nexport interface LabelRef {\n    kind: ASTKinds.LabelRef;\n    label: Label;\n}\nexport interface Label {\n    kind: ASTKinds.Label;\n    v: string;\n}\nexport class Digit {\n    public kind: ASTKinds.Digit = ASTKinds.Digit;\n    public literal: string;\n    public value: number;\n    constructor(literal: string){\n        this.literal = literal;\n        this.value = ((): number => {\n        return parseInt(literal)\n        })();\n    }\n}\nexport class Number {\n    public kind: ASTKinds.Number = ASTKinds.Number;\n    public literal: string;\n    public value: number;\n    constructor(literal: string){\n        this.literal = literal;\n        this.value = ((): number => {\n        return parseInt(literal)\n        })();\n    }\n}\nexport class Parser {\n    private readonly input: string;\n    private pos: PosInfo;\n    private negating: boolean = false;\n    private memoSafe: boolean = true;\n    constructor(input: string) {\n        this.pos = {overallPos: 0, line: 1, offset: 0};\n        this.input = input;\n    }\n    public reset(pos: PosInfo) {\n        this.pos = pos;\n    }\n    public finished(): boolean {\n        return this.pos.overallPos === this.input.length;\n    }\n    public clearMemos(): void {\n        this.$scope$Constraint$memo.clear();\n    }\n    protected $scope$Constraint$memo: Map<number, [Nullable<Constraint>, PosInfo]> = new Map();\n    public matchStart($$dpth: number, $$cr?: ErrorTracker): Nullable<Start> {\n        return this.run<Start>($$dpth,\n            () => {\n                let $scope$spec: Nullable<BidSpec>;\n                let $$res: Nullable<Start> = null;\n                if (true\n                    && ($scope$spec = this.matchBidSpec($$dpth + 1, $$cr)) !== null\n                    && this.match$EOF($$cr) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Start, spec: $scope$spec};\n                }\n                return $$res;\n            });\n    }\n    public matchBidSpec($$dpth: number, $$cr?: ErrorTracker): Nullable<BidSpec> {\n        return this.run<BidSpec>($$dpth,\n            () => {\n                let $scope$bid: Nullable<Bid>;\n                let $scope$constraints: Nullable<Nullable<BidSpecConstraintList>>;\n                let $$res: Nullable<BidSpec> = null;\n                if (true\n                    && ($scope$bid = this.matchBid($$dpth + 1, $$cr)) !== null\n                    && (($scope$constraints = this.matchBidSpecConstraintList($$dpth + 1, $$cr)) || true)\n                ) {\n                    $$res = {kind: ASTKinds.BidSpec, bid: $scope$bid, constraints: $scope$constraints};\n                }\n                return $$res;\n            });\n    }\n    public matchBidSpecConstraintList($$dpth: number, $$cr?: ErrorTracker): Nullable<BidSpecConstraintList> {\n        return this.run<BidSpecConstraintList>($$dpth,\n            () => {\n                let $scope$constraints: Nullable<ConstraintList>;\n                let $$res: Nullable<BidSpecConstraintList> = null;\n                if (true\n                    && this.regexAccept(String.raw`(?:: )`, $$dpth + 1, $$cr) !== null\n                    && ($scope$constraints = this.matchConstraintList($$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.BidSpecConstraintList, constraints: $scope$constraints};\n                }\n                return $$res;\n            });\n    }\n    public matchBid($$dpth: number, $$cr?: ErrorTracker): Nullable<Bid> {\n        return this.choice<Bid>([\n            () => this.matchBid_1($$dpth + 1, $$cr),\n            () => this.matchBid_2($$dpth + 1, $$cr),\n        ]);\n    }\n    public matchBid_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Bid_1> {\n        return this.matchContractBid($$dpth + 1, $$cr);\n    }\n    public matchBid_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Bid_2> {\n        return this.matchNonContractBid($$dpth + 1, $$cr);\n    }\n    public matchContractBid($$dpth: number, $$cr?: ErrorTracker): Nullable<ContractBid> {\n        return this.run<ContractBid>($$dpth,\n            () => {\n                let $scope$level: Nullable<Digit>;\n                let $scope$specifier: Nullable<StrainSpecifier>;\n                let $$res: Nullable<ContractBid> = null;\n                if (true\n                    && ($scope$level = this.matchDigit($$dpth + 1, $$cr)) !== null\n                    && ($scope$specifier = this.matchStrainSpecifier($$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.ContractBid, level: $scope$level, specifier: $scope$specifier};\n                }\n                return $$res;\n            });\n    }\n    public matchStrainSpecifier($$dpth: number, $$cr?: ErrorTracker): Nullable<StrainSpecifier> {\n        return this.choice<StrainSpecifier>([\n            () => this.matchStrainSpecifier_1($$dpth + 1, $$cr),\n            () => this.matchStrainSpecifier_2($$dpth + 1, $$cr),\n            () => this.matchStrainSpecifier_3($$dpth + 1, $$cr),\n            () => this.matchStrainSpecifier_4($$dpth + 1, $$cr),\n        ]);\n    }\n    public matchStrainSpecifier_1($$dpth: number, $$cr?: ErrorTracker): Nullable<StrainSpecifier_1> {\n        return this.matchWildcard($$dpth + 1, $$cr);\n    }\n    public matchStrainSpecifier_2($$dpth: number, $$cr?: ErrorTracker): Nullable<StrainSpecifier_2> {\n        return this.matchMajor($$dpth + 1, $$cr);\n    }\n    public matchStrainSpecifier_3($$dpth: number, $$cr?: ErrorTracker): Nullable<StrainSpecifier_3> {\n        return this.matchMinor($$dpth + 1, $$cr);\n    }\n    public matchStrainSpecifier_4($$dpth: number, $$cr?: ErrorTracker): Nullable<StrainSpecifier_4> {\n        return this.matchStrain($$dpth + 1, $$cr);\n    }\n    public matchWildcard($$dpth: number, $$cr?: ErrorTracker): Nullable<Wildcard> {\n        return this.run<Wildcard>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Wildcard> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:X)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Wildcard, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchMajor($$dpth: number, $$cr?: ErrorTracker): Nullable<Major> {\n        return this.run<Major>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Major> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:M)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Major, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchMinor($$dpth: number, $$cr?: ErrorTracker): Nullable<Minor> {\n        return this.run<Minor>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Minor> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:m)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Minor, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchNonContractBid($$dpth: number, $$cr?: ErrorTracker): Nullable<NonContractBid> {\n        return this.matchPass($$dpth + 1, $$cr);\n    }\n    public matchPass($$dpth: number, $$cr?: ErrorTracker): Nullable<Pass> {\n        return this.run<Pass>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Pass> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:P)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Pass, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchStrain($$dpth: number, $$cr?: ErrorTracker): Nullable<Strain> {\n        return this.choice<Strain>([\n            () => this.matchStrain_1($$dpth + 1, $$cr),\n            () => this.matchStrain_2($$dpth + 1, $$cr),\n        ]);\n    }\n    public matchStrain_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Strain_1> {\n        return this.matchSuit($$dpth + 1, $$cr);\n    }\n    public matchStrain_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Strain_2> {\n        return this.matchNotrump($$dpth + 1, $$cr);\n    }\n    public matchSuit($$dpth: number, $$cr?: ErrorTracker): Nullable<Suit> {\n        return this.choice<Suit>([\n            () => this.matchSuit_1($$dpth + 1, $$cr),\n            () => this.matchSuit_2($$dpth + 1, $$cr),\n            () => this.matchSuit_3($$dpth + 1, $$cr),\n            () => this.matchSuit_4($$dpth + 1, $$cr),\n        ]);\n    }\n    public matchSuit_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Suit_1> {\n        return this.matchClub($$dpth + 1, $$cr);\n    }\n    public matchSuit_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Suit_2> {\n        return this.matchDiamond($$dpth + 1, $$cr);\n    }\n    public matchSuit_3($$dpth: number, $$cr?: ErrorTracker): Nullable<Suit_3> {\n        return this.matchHeart($$dpth + 1, $$cr);\n    }\n    public matchSuit_4($$dpth: number, $$cr?: ErrorTracker): Nullable<Suit_4> {\n        return this.matchSpade($$dpth + 1, $$cr);\n    }\n    public matchClub($$dpth: number, $$cr?: ErrorTracker): Nullable<Club> {\n        return this.run<Club>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Club> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:C)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Club, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchDiamond($$dpth: number, $$cr?: ErrorTracker): Nullable<Diamond> {\n        return this.run<Diamond>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Diamond> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:D)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Diamond, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchHeart($$dpth: number, $$cr?: ErrorTracker): Nullable<Heart> {\n        return this.run<Heart>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Heart> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:H)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Heart, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchSpade($$dpth: number, $$cr?: ErrorTracker): Nullable<Spade> {\n        return this.run<Spade>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Spade> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:S)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Spade, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchNotrump($$dpth: number, $$cr?: ErrorTracker): Nullable<Notrump> {\n        return this.run<Notrump>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Notrump> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:N)`, $$dpth + 1, $$cr)) !== null\n                    && ((this.regexAccept(String.raw`(?:T)`, $$dpth + 1, $$cr)) || true)\n                ) {\n                    $$res = {kind: ASTKinds.Notrump, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchHonor($$dpth: number, $$cr?: ErrorTracker): Nullable<Honor> {\n        return this.run<Honor>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Honor> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:[AKQJT])`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Honor, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchConstraintList($$dpth: number, $$cr?: ErrorTracker): Nullable<ConstraintList> {\n        return this.loop<ConstraintListItem>(() => this.matchConstraintListItem($$dpth + 1, $$cr), false);\n    }\n    public matchConstraintListItem($$dpth: number, $$cr?: ErrorTracker): Nullable<ConstraintListItem> {\n        return this.run<ConstraintListItem>($$dpth,\n            () => {\n                let $scope$constraint: Nullable<Constraint>;\n                let $$res: Nullable<ConstraintListItem> = null;\n                if (true\n                    && ($scope$constraint = this.matchConstraint($$dpth + 1, $$cr)) !== null\n                    && ((this.regexAccept(String.raw`(?: )`, $$dpth + 1, $$cr)) || true)\n                ) {\n                    $$res = {kind: ASTKinds.ConstraintListItem, constraint: $scope$constraint};\n                }\n                return $$res;\n            });\n    }\n    public matchConstraint($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint> {\n        const fn = () => {\n            return this.choice<Constraint>([\n                () => this.matchConstraint_1($$dpth + 1, $$cr),\n                () => this.matchConstraint_2($$dpth + 1, $$cr),\n                () => this.matchConstraint_3($$dpth + 1, $$cr),\n                () => this.matchConstraint_4($$dpth + 1, $$cr),\n                () => this.matchConstraint_5($$dpth + 1, $$cr),\n                () => this.matchConstraint_6($$dpth + 1, $$cr),\n                () => this.matchConstraint_7($$dpth + 1, $$cr),\n                () => this.matchConstraint_8($$dpth + 1, $$cr),\n                () => this.matchConstraint_9($$dpth + 1, $$cr),\n                () => this.matchConstraint_10($$dpth + 1, $$cr),\n                () => this.matchConstraint_11($$dpth + 1, $$cr),\n                () => this.matchConstraint_12($$dpth + 1, $$cr),\n                () => this.matchConstraint_13($$dpth + 1, $$cr),\n                () => this.matchConstraint_14($$dpth + 1, $$cr),\n                () => this.matchConstraint_15($$dpth + 1, $$cr),\n                () => this.matchConstraint_16($$dpth + 1, $$cr),\n                () => this.matchConstraint_17($$dpth + 1, $$cr),\n                () => this.matchConstraint_18($$dpth + 1, $$cr),\n            ]);\n        };\n        const $scope$pos = this.mark();\n        const memo = this.$scope$Constraint$memo.get($scope$pos.overallPos);\n        if(memo !== undefined) {\n            this.reset(memo[1]);\n            return memo[0];\n        }\n        const $scope$oldMemoSafe = this.memoSafe;\n        this.memoSafe = false;\n        this.$scope$Constraint$memo.set($scope$pos.overallPos, [null, $scope$pos]);\n        let lastRes: Nullable<Constraint> = null;\n        let lastPos: PosInfo = $scope$pos;\n        for(;;) {\n            this.reset($scope$pos);\n            const res = fn();\n            const end = this.mark();\n            if(end.overallPos <= lastPos.overallPos)\n                break;\n            lastRes = res;\n            lastPos = end;\n            this.$scope$Constraint$memo.set($scope$pos.overallPos, [lastRes, lastPos]);\n        }\n        this.reset(lastPos);\n        this.memoSafe = $scope$oldMemoSafe;\n        return lastRes;\n    }\n    public matchConstraint_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_1> {\n        return this.matchConst($$dpth + 1, $$cr);\n    }\n    public matchConstraint_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_2> {\n        return this.matchOr($$dpth + 1, $$cr);\n    }\n    public matchConstraint_3($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_3> {\n        return this.matchAnd($$dpth + 1, $$cr);\n    }\n    public matchConstraint_4($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_4> {\n        return this.matchNot($$dpth + 1, $$cr);\n    }\n    public matchConstraint_5($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_5> {\n        return this.matchOtherwise($$dpth + 1, $$cr);\n    }\n    public matchConstraint_6($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_6> {\n        return this.matchDistribution($$dpth + 1, $$cr);\n    }\n    public matchConstraint_7($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_7> {\n        return this.matchResponse($$dpth + 1, $$cr);\n    }\n    public matchConstraint_8($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_8> {\n        return this.matchSuitRange($$dpth + 1, $$cr);\n    }\n    public matchConstraint_9($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_9> {\n        return this.matchSuitBound($$dpth + 1, $$cr);\n    }\n    public matchConstraint_10($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_10> {\n        return this.matchSuitComparison($$dpth + 1, $$cr);\n    }\n    public matchConstraint_11($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_11> {\n        return this.matchSuitHonors($$dpth + 1, $$cr);\n    }\n    public matchConstraint_12($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_12> {\n        return this.matchSuitTop($$dpth + 1, $$cr);\n    }\n    public matchConstraint_13($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_13> {\n        return this.matchSuitRank($$dpth + 1, $$cr);\n    }\n    public matchConstraint_14($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_14> {\n        return this.matchPointRange($$dpth + 1, $$cr);\n    }\n    public matchConstraint_15($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_15> {\n        return this.matchPointBound($$dpth + 1, $$cr);\n    }\n    public matchConstraint_16($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_16> {\n        return this.matchOtherBid($$dpth + 1, $$cr);\n    }\n    public matchConstraint_17($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_17> {\n        return this.matchLabelDef($$dpth + 1, $$cr);\n    }\n    public matchConstraint_18($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_18> {\n        return this.matchLabelRef($$dpth + 1, $$cr);\n    }\n    public matchConst($$dpth: number, $$cr?: ErrorTracker): Nullable<Const> {\n        return this.choice<Const>([\n            () => this.matchConst_1($$dpth + 1, $$cr),\n            () => this.matchConst_2($$dpth + 1, $$cr),\n        ]);\n    }\n    public matchConst_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Const_1> {\n        return this.matchTrue($$dpth + 1, $$cr);\n    }\n    public matchConst_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Const_2> {\n        return this.matchFalse($$dpth + 1, $$cr);\n    }\n    public matchTrue($$dpth: number, $$cr?: ErrorTracker): Nullable<True> {\n        return this.run<True>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<True> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:true)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.True, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchFalse($$dpth: number, $$cr?: ErrorTracker): Nullable<False> {\n        return this.run<False>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<False> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:false)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.False, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchOr($$dpth: number, $$cr?: ErrorTracker): Nullable<Or> {\n        return this.run<Or>($$dpth,\n            () => {\n                let $scope$left: Nullable<Constraint>;\n                let $scope$right: Nullable<Constraint>;\n                let $$res: Nullable<Or> = null;\n                if (true\n                    && ($scope$left = this.matchConstraint($$dpth + 1, $$cr)) !== null\n                    && this.regexAccept(String.raw`(?: or )`, $$dpth + 1, $$cr) !== null\n                    && ($scope$right = this.matchConstraint($$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Or, left: $scope$left, right: $scope$right};\n                }\n                return $$res;\n            });\n    }\n    public matchAnd($$dpth: number, $$cr?: ErrorTracker): Nullable<And> {\n        return this.run<And>($$dpth,\n            () => {\n                let $scope$constraints: Nullable<ConstraintList>;\n                let $$res: Nullable<And> = null;\n                if (true\n                    && this.regexAccept(String.raw`(?:\\()`, $$dpth + 1, $$cr) !== null\n                    && ($scope$constraints = this.matchConstraintList($$dpth + 1, $$cr)) !== null\n                    && this.regexAccept(String.raw`(?:\\))`, $$dpth + 1, $$cr) !== null\n                ) {\n                    $$res = {kind: ASTKinds.And, constraints: $scope$constraints};\n                }\n                return $$res;\n            });\n    }\n    public matchNot($$dpth: number, $$cr?: ErrorTracker): Nullable<Not> {\n        return this.run<Not>($$dpth,\n            () => {\n                let $scope$constraint: Nullable<Constraint>;\n                let $$res: Nullable<Not> = null;\n                if (true\n                    && this.matchNot_$0($$dpth + 1, $$cr) !== null\n                    && ((this.regexAccept(String.raw`(?: )`, $$dpth + 1, $$cr)) || true)\n                    && ($scope$constraint = this.matchConstraint($$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Not, constraint: $scope$constraint};\n                }\n                return $$res;\n            });\n    }\n    public matchNot_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Not_$0> {\n        return this.choice<Not_$0>([\n            () => this.matchNot_$0_1($$dpth + 1, $$cr),\n            () => this.matchNot_$0_2($$dpth + 1, $$cr),\n        ]);\n    }\n    public matchNot_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Not_$0_1> {\n        return this.regexAccept(String.raw`(?:not)`, $$dpth + 1, $$cr);\n    }\n    public matchNot_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Not_$0_2> {\n        return this.regexAccept(String.raw`(?:!)`, $$dpth + 1, $$cr);\n    }\n    public matchOtherwise($$dpth: number, $$cr?: ErrorTracker): Nullable<Otherwise> {\n        return this.run<Otherwise>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Otherwise> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:else)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Otherwise, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchPointRange($$dpth: number, $$cr?: ErrorTracker): Nullable<PointRange> {\n        return this.run<PointRange>($$dpth,\n            () => {\n                let $scope$lower: Nullable<Number>;\n                let $scope$upper: Nullable<Number>;\n                let $$res: Nullable<PointRange> = null;\n                if (true\n                    && ($scope$lower = this.matchNumber($$dpth + 1, $$cr)) !== null\n                    && this.regexAccept(String.raw`(?:-)`, $$dpth + 1, $$cr) !== null\n                    && ($scope$upper = this.matchNumber($$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.PointRange, lower: $scope$lower, upper: $scope$upper};\n                }\n                return $$res;\n            });\n    }\n    public matchPointBound($$dpth: number, $$cr?: ErrorTracker): Nullable<PointBound> {\n        return this.run<PointBound>($$dpth,\n            () => {\n                let $scope$value: Nullable<Number>;\n                let $scope$qualifier: Nullable<BoundQualifier>;\n                let $$res: Nullable<PointBound> = null;\n                if (true\n                    && ($scope$value = this.matchNumber($$dpth + 1, $$cr)) !== null\n                    && ($scope$qualifier = this.matchBoundQualifier($$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.PointBound, value: $scope$value, qualifier: $scope$qualifier};\n                }\n                return $$res;\n            });\n    }\n    public matchSuitRange($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitRange> {\n        return this.run<SuitRange>($$dpth,\n            () => {\n                let $scope$lower: Nullable<Digit>;\n                let $scope$upper: Nullable<Digit>;\n                let $scope$suit: Nullable<SuitSpecifier>;\n                let $$res: Nullable<SuitRange> = null;\n                if (true\n                    && ($scope$lower = this.matchDigit($$dpth + 1, $$cr)) !== null\n                    && this.regexAccept(String.raw`(?:-)`, $$dpth + 1, $$cr) !== null\n                    && ($scope$upper = this.matchDigit($$dpth + 1, $$cr)) !== null\n                    && ($scope$suit = this.matchSuitSpecifier($$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.SuitRange, lower: $scope$lower, upper: $scope$upper, suit: $scope$suit};\n                }\n                return $$res;\n            });\n    }\n    public matchSuitBound($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitBound> {\n        return this.run<SuitBound>($$dpth,\n            () => {\n                let $scope$value: Nullable<Number>;\n                let $scope$qualifier: Nullable<BoundQualifier>;\n                let $scope$suit: Nullable<SuitSpecifier>;\n                let $$res: Nullable<SuitBound> = null;\n                if (true\n                    && ($scope$value = this.matchNumber($$dpth + 1, $$cr)) !== null\n                    && ($scope$qualifier = this.matchBoundQualifier($$dpth + 1, $$cr)) !== null\n                    && ($scope$suit = this.matchSuitSpecifier($$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.SuitBound, value: $scope$value, qualifier: $scope$qualifier, suit: $scope$suit};\n                }\n                return $$res;\n            });\n    }\n    public matchSuitSpecifier($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitSpecifier> {\n        return this.choice<SuitSpecifier>([\n            () => this.matchSuitSpecifier_1($$dpth + 1, $$cr),\n            () => this.matchSuitSpecifier_2($$dpth + 1, $$cr),\n            () => this.matchSuitSpecifier_3($$dpth + 1, $$cr),\n            () => this.matchSuitSpecifier_4($$dpth + 1, $$cr),\n            () => this.matchSuitSpecifier_5($$dpth + 1, $$cr),\n            () => this.matchSuitSpecifier_6($$dpth + 1, $$cr),\n        ]);\n    }\n    public matchSuitSpecifier_1($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitSpecifier_1> {\n        return this.matchWildcard($$dpth + 1, $$cr);\n    }\n    public matchSuitSpecifier_2($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitSpecifier_2> {\n        return this.matchMajor($$dpth + 1, $$cr);\n    }\n    public matchSuitSpecifier_3($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitSpecifier_3> {\n        return this.matchMinor($$dpth + 1, $$cr);\n    }\n    public matchSuitSpecifier_4($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitSpecifier_4> {\n        return this.matchOtherMajor($$dpth + 1, $$cr);\n    }\n    public matchSuitSpecifier_5($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitSpecifier_5> {\n        return this.matchOtherMinor($$dpth + 1, $$cr);\n    }\n    public matchSuitSpecifier_6($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitSpecifier_6> {\n        return this.matchSuit($$dpth + 1, $$cr);\n    }\n    public matchOtherMajor($$dpth: number, $$cr?: ErrorTracker): Nullable<OtherMajor> {\n        return this.run<OtherMajor>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<OtherMajor> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:oM)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.OtherMajor, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchOtherMinor($$dpth: number, $$cr?: ErrorTracker): Nullable<OtherMinor> {\n        return this.run<OtherMinor>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<OtherMinor> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:om)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.OtherMinor, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchSuitComparison($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitComparison> {\n        return this.run<SuitComparison>($$dpth,\n            () => {\n                let $scope$left: Nullable<SuitSpecifier>;\n                let $scope$op: Nullable<SuitComparisonOperator>;\n                let $scope$right: Nullable<SuitSpecifier>;\n                let $$res: Nullable<SuitComparison> = null;\n                if (true\n                    && ($scope$left = this.matchSuitSpecifier($$dpth + 1, $$cr)) !== null\n                    && ($scope$op = this.matchSuitComparisonOperator($$dpth + 1, $$cr)) !== null\n                    && ($scope$right = this.matchSuitSpecifier($$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.SuitComparison, left: $scope$left, op: $scope$op, right: $scope$right};\n                }\n                return $$res;\n            });\n    }\n    public matchSuitComparisonOperator($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitComparisonOperator> {\n        return this.choice<SuitComparisonOperator>([\n            () => this.matchSuitComparisonOperator_1($$dpth + 1, $$cr),\n            () => this.matchSuitComparisonOperator_2($$dpth + 1, $$cr),\n            () => this.matchSuitComparisonOperator_3($$dpth + 1, $$cr),\n            () => this.matchSuitComparisonOperator_4($$dpth + 1, $$cr),\n            () => this.matchSuitComparisonOperator_5($$dpth + 1, $$cr),\n        ]);\n    }\n    public matchSuitComparisonOperator_1($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitComparisonOperator_1> {\n        return this.run<SuitComparisonOperator_1>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<SuitComparisonOperator_1> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:<=)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.SuitComparisonOperator_1, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchSuitComparisonOperator_2($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitComparisonOperator_2> {\n        return this.run<SuitComparisonOperator_2>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<SuitComparisonOperator_2> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:>=)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.SuitComparisonOperator_2, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchSuitComparisonOperator_3($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitComparisonOperator_3> {\n        return this.run<SuitComparisonOperator_3>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<SuitComparisonOperator_3> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:=)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.SuitComparisonOperator_3, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchSuitComparisonOperator_4($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitComparisonOperator_4> {\n        return this.run<SuitComparisonOperator_4>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<SuitComparisonOperator_4> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:<)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.SuitComparisonOperator_4, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchSuitComparisonOperator_5($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitComparisonOperator_5> {\n        return this.run<SuitComparisonOperator_5>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<SuitComparisonOperator_5> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:>)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.SuitComparisonOperator_5, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchSuitHonors($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitHonors> {\n        return this.run<SuitHonors>($$dpth,\n            () => {\n                let $scope$suit: Nullable<SuitSpecifier>;\n                let $scope$honors: Nullable<Honor[]>;\n                let $$res: Nullable<SuitHonors> = null;\n                if (true\n                    && ($scope$suit = this.matchSuitSpecifier($$dpth + 1, $$cr)) !== null\n                    && ($scope$honors = this.loop<Honor>(() => this.matchHonor($$dpth + 1, $$cr), false)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.SuitHonors, suit: $scope$suit, honors: $scope$honors};\n                }\n                return $$res;\n            });\n    }\n    public matchSuitTop($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitTop> {\n        return this.run<SuitTop>($$dpth,\n            () => {\n                let $scope$suit: Nullable<SuitSpecifier>;\n                let $scope$x: Nullable<string>;\n                let $scope$y: Nullable<string>;\n                let $$res: Nullable<SuitTop> = null;\n                if (true\n                    && ($scope$suit = this.matchSuitSpecifier($$dpth + 1, $$cr)) !== null\n                    && ($scope$x = this.regexAccept(String.raw`(?:[0-5])`, $$dpth + 1, $$cr)) !== null\n                    && this.regexAccept(String.raw`(?:/)`, $$dpth + 1, $$cr) !== null\n                    && ($scope$y = this.regexAccept(String.raw`(?:[1-5])`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.SuitTop, suit: $scope$suit, x: $scope$x, y: $scope$y};\n                }\n                return $$res;\n            });\n    }\n    public matchBoundQualifier($$dpth: number, $$cr?: ErrorTracker): Nullable<BoundQualifier> {\n        return this.choice<BoundQualifier>([\n            () => this.matchBoundQualifier_1($$dpth + 1, $$cr),\n            () => this.matchBoundQualifier_2($$dpth + 1, $$cr),\n            () => this.matchBoundQualifier_3($$dpth + 1, $$cr),\n        ]);\n    }\n    public matchBoundQualifier_1($$dpth: number, $$cr?: ErrorTracker): Nullable<BoundQualifier_1> {\n        return this.matchPlus($$dpth + 1, $$cr);\n    }\n    public matchBoundQualifier_2($$dpth: number, $$cr?: ErrorTracker): Nullable<BoundQualifier_2> {\n        return this.matchMinus($$dpth + 1, $$cr);\n    }\n    public matchBoundQualifier_3($$dpth: number, $$cr?: ErrorTracker): Nullable<BoundQualifier_3> {\n        return this.matchEquals($$dpth + 1, $$cr);\n    }\n    public matchPlus($$dpth: number, $$cr?: ErrorTracker): Nullable<Plus> {\n        return this.run<Plus>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Plus> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:\\+)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Plus, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchMinus($$dpth: number, $$cr?: ErrorTracker): Nullable<Minus> {\n        return this.run<Minus>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Minus> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:\\-)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Minus, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchEquals($$dpth: number, $$cr?: ErrorTracker): Nullable<Equals> {\n        return this.run<Equals>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Equals> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:=)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Equals, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchOtherBid($$dpth: number, $$cr?: ErrorTracker): Nullable<OtherBid> {\n        return this.run<OtherBid>($$dpth,\n            () => {\n                let $scope$level: Nullable<Number>;\n                let $scope$strain: Nullable<Strain>;\n                let $$res: Nullable<OtherBid> = null;\n                if (true\n                    && ($scope$level = this.matchNumber($$dpth + 1, $$cr)) !== null\n                    && ($scope$strain = this.matchStrain($$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.OtherBid, level: $scope$level, strain: $scope$strain};\n                }\n                return $$res;\n            });\n    }\n    public matchDistribution($$dpth: number, $$cr?: ErrorTracker): Nullable<Distribution> {\n        return this.choice<Distribution>([\n            () => this.matchDistribution_1($$dpth + 1, $$cr),\n            () => this.matchDistribution_2($$dpth + 1, $$cr),\n            () => this.matchDistribution_3($$dpth + 1, $$cr),\n            () => this.matchDistribution_4($$dpth + 1, $$cr),\n            () => this.matchDistribution_5($$dpth + 1, $$cr),\n        ]);\n    }\n    public matchDistribution_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Distribution_1> {\n        return this.matchBalanced($$dpth + 1, $$cr);\n    }\n    public matchDistribution_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Distribution_2> {\n        return this.matchSemiBalanced($$dpth + 1, $$cr);\n    }\n    public matchDistribution_3($$dpth: number, $$cr?: ErrorTracker): Nullable<Distribution_3> {\n        return this.matchUnbalanced($$dpth + 1, $$cr);\n    }\n    public matchDistribution_4($$dpth: number, $$cr?: ErrorTracker): Nullable<Distribution_4> {\n        return this.matchAnyShape($$dpth + 1, $$cr);\n    }\n    public matchDistribution_5($$dpth: number, $$cr?: ErrorTracker): Nullable<Distribution_5> {\n        return this.matchSpecificShape($$dpth + 1, $$cr);\n    }\n    public matchBalanced($$dpth: number, $$cr?: ErrorTracker): Nullable<Balanced> {\n        return this.run<Balanced>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Balanced> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:BAL)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Balanced, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchSemiBalanced($$dpth: number, $$cr?: ErrorTracker): Nullable<SemiBalanced> {\n        return this.run<SemiBalanced>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<SemiBalanced> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:semiBAL)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.SemiBalanced, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchUnbalanced($$dpth: number, $$cr?: ErrorTracker): Nullable<Unbalanced> {\n        return this.run<Unbalanced>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Unbalanced> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:unBAL)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Unbalanced, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchAnyShape($$dpth: number, $$cr?: ErrorTracker): Nullable<AnyShape> {\n        return this.run<AnyShape>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<AnyShape> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:[0-9]{4})`, $$dpth + 1, $$cr)) !== null\n                    && this.regexAccept(String.raw`(?:\\*)`, $$dpth + 1, $$cr) !== null\n                ) {\n                    $$res = {kind: ASTKinds.AnyShape, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchSpecificShape($$dpth: number, $$cr?: ErrorTracker): Nullable<SpecificShape> {\n        return this.run<SpecificShape>($$dpth,\n            () => {\n                let $scope$S: Nullable<Digit>;\n                let $scope$H: Nullable<Digit>;\n                let $scope$D: Nullable<Digit>;\n                let $scope$C: Nullable<Digit>;\n                let $$res: Nullable<SpecificShape> = null;\n                if (true\n                    && ($scope$S = this.matchDigit($$dpth + 1, $$cr)) !== null\n                    && ($scope$H = this.matchDigit($$dpth + 1, $$cr)) !== null\n                    && ($scope$D = this.matchDigit($$dpth + 1, $$cr)) !== null\n                    && ($scope$C = this.matchDigit($$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.SpecificShape, S: $scope$S, H: $scope$H, D: $scope$D, C: $scope$C};\n                }\n                return $$res;\n            });\n    }\n    public matchSuitRank($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitRank> {\n        return this.choice<SuitRank>([\n            () => this.matchSuitRank_1($$dpth + 1, $$cr),\n            () => this.matchSuitRank_2($$dpth + 1, $$cr),\n        ]);\n    }\n    public matchSuitRank_1($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitRank_1> {\n        return this.matchPrimary($$dpth + 1, $$cr);\n    }\n    public matchSuitRank_2($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitRank_2> {\n        return this.matchSecondary($$dpth + 1, $$cr);\n    }\n    public matchPrimary($$dpth: number, $$cr?: ErrorTracker): Nullable<Primary> {\n        return this.run<Primary>($$dpth,\n            () => {\n                let $scope$suit: Nullable<SuitSpecifier>;\n                let $$res: Nullable<Primary> = null;\n                if (true\n                    && ($scope$suit = this.matchSuitSpecifier($$dpth + 1, $$cr)) !== null\n                    && this.regexAccept(String.raw`(?:1)`, $$dpth + 1, $$cr) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Primary, suit: $scope$suit};\n                }\n                return $$res;\n            });\n    }\n    public matchSecondary($$dpth: number, $$cr?: ErrorTracker): Nullable<Secondary> {\n        return this.run<Secondary>($$dpth,\n            () => {\n                let $scope$suit: Nullable<SuitSpecifier>;\n                let $$res: Nullable<Secondary> = null;\n                if (true\n                    && ($scope$suit = this.matchSuitSpecifier($$dpth + 1, $$cr)) !== null\n                    && this.regexAccept(String.raw`(?:2)`, $$dpth + 1, $$cr) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Secondary, suit: $scope$suit};\n                }\n                return $$res;\n            });\n    }\n    public matchResponse($$dpth: number, $$cr?: ErrorTracker): Nullable<Response> {\n        return this.choice<Response>([\n            () => this.matchResponse_1($$dpth + 1, $$cr),\n            () => this.matchResponse_2($$dpth + 1, $$cr),\n            () => this.matchResponse_3($$dpth + 1, $$cr),\n            () => this.matchResponse_4($$dpth + 1, $$cr),\n        ]);\n    }\n    public matchResponse_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Response_1> {\n        return this.matchForceOneRound($$dpth + 1, $$cr);\n    }\n    public matchResponse_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Response_2> {\n        return this.matchForceGame($$dpth + 1, $$cr);\n    }\n    public matchResponse_3($$dpth: number, $$cr?: ErrorTracker): Nullable<Response_3> {\n        return this.matchForceSlam($$dpth + 1, $$cr);\n    }\n    public matchResponse_4($$dpth: number, $$cr?: ErrorTracker): Nullable<Response_4> {\n        return this.matchRelay($$dpth + 1, $$cr);\n    }\n    public matchForceOneRound($$dpth: number, $$cr?: ErrorTracker): Nullable<ForceOneRound> {\n        return this.run<ForceOneRound>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<ForceOneRound> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:F1)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.ForceOneRound, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchForceGame($$dpth: number, $$cr?: ErrorTracker): Nullable<ForceGame> {\n        return this.run<ForceGame>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<ForceGame> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:FG)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.ForceGame, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchForceSlam($$dpth: number, $$cr?: ErrorTracker): Nullable<ForceSlam> {\n        return this.run<ForceSlam>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<ForceSlam> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:FS)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.ForceSlam, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchRelay($$dpth: number, $$cr?: ErrorTracker): Nullable<Relay> {\n        return this.run<Relay>($$dpth,\n            () => {\n                let $scope$bid: Nullable<OtherBid>;\n                let $$res: Nullable<Relay> = null;\n                if (true\n                    && this.regexAccept(String.raw`(?:->)`, $$dpth + 1, $$cr) !== null\n                    && ($scope$bid = this.matchOtherBid($$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Relay, bid: $scope$bid};\n                }\n                return $$res;\n            });\n    }\n    public matchLabelDef($$dpth: number, $$cr?: ErrorTracker): Nullable<LabelDef> {\n        return this.run<LabelDef>($$dpth,\n            () => {\n                let $scope$label: Nullable<Label>;\n                let $scope$constraints: Nullable<ConstraintList>;\n                let $$res: Nullable<LabelDef> = null;\n                if (true\n                    && this.regexAccept(String.raw`(?:\\')`, $$dpth + 1, $$cr) !== null\n                    && ($scope$label = this.matchLabel($$dpth + 1, $$cr)) !== null\n                    && this.regexAccept(String.raw`(?:\\': )`, $$dpth + 1, $$cr) !== null\n                    && ($scope$constraints = this.matchConstraintList($$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.LabelDef, label: $scope$label, constraints: $scope$constraints};\n                }\n                return $$res;\n            });\n    }\n    public matchLabelRef($$dpth: number, $$cr?: ErrorTracker): Nullable<LabelRef> {\n        return this.run<LabelRef>($$dpth,\n            () => {\n                let $scope$label: Nullable<Label>;\n                let $$res: Nullable<LabelRef> = null;\n                if (true\n                    && this.regexAccept(String.raw`(?:\\')`, $$dpth + 1, $$cr) !== null\n                    && ($scope$label = this.matchLabel($$dpth + 1, $$cr)) !== null\n                    && this.regexAccept(String.raw`(?:\\')`, $$dpth + 1, $$cr) !== null\n                ) {\n                    $$res = {kind: ASTKinds.LabelRef, label: $scope$label};\n                }\n                return $$res;\n            });\n    }\n    public matchLabel($$dpth: number, $$cr?: ErrorTracker): Nullable<Label> {\n        return this.run<Label>($$dpth,\n            () => {\n                let $scope$v: Nullable<string>;\n                let $$res: Nullable<Label> = null;\n                if (true\n                    && ($scope$v = this.regexAccept(String.raw`(?:[0-9a-zA-z-_]+)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Label, v: $scope$v};\n                }\n                return $$res;\n            });\n    }\n    public matchDigit($$dpth: number, $$cr?: ErrorTracker): Nullable<Digit> {\n        return this.run<Digit>($$dpth,\n            () => {\n                let $scope$literal: Nullable<string>;\n                let $$res: Nullable<Digit> = null;\n                if (true\n                    && ($scope$literal = this.regexAccept(String.raw`(?:[0-9])`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = new Digit($scope$literal);\n                }\n                return $$res;\n            });\n    }\n    public matchNumber($$dpth: number, $$cr?: ErrorTracker): Nullable<Number> {\n        return this.run<Number>($$dpth,\n            () => {\n                let $scope$literal: Nullable<string>;\n                let $$res: Nullable<Number> = null;\n                if (true\n                    && ($scope$literal = this.regexAccept(String.raw`(?:[0-9]+)`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = new Number($scope$literal);\n                }\n                return $$res;\n            });\n    }\n    public test(): boolean {\n        const mrk = this.mark();\n        const res = this.matchStart(0);\n        const ans = res !== null;\n        this.reset(mrk);\n        return ans;\n    }\n    public parse(): ParseResult {\n        const mrk = this.mark();\n        const res = this.matchStart(0);\n        if (res)\n            return {ast: res, errs: []};\n        this.reset(mrk);\n        const rec = new ErrorTracker();\n        this.clearMemos();\n        this.matchStart(0, rec);\n        const err = rec.getErr()\n        return {ast: res, errs: err !== null ? [err] : []}\n    }\n    public mark(): PosInfo {\n        return this.pos;\n    }\n    private loop<T>(func: $$RuleType<T>, star: boolean = false): Nullable<T[]> {\n        const mrk = this.mark();\n        const res: T[] = [];\n        for (;;) {\n            const t = func();\n            if (t === null) {\n                break;\n            }\n            res.push(t);\n        }\n        if (star || res.length > 0) {\n            return res;\n        }\n        this.reset(mrk);\n        return null;\n    }\n    private run<T>($$dpth: number, fn: $$RuleType<T>): Nullable<T> {\n        const mrk = this.mark();\n        const res = fn()\n        if (res !== null)\n            return res;\n        this.reset(mrk);\n        return null;\n    }\n    private choice<T>(fns: Array<$$RuleType<T>>): Nullable<T> {\n        for (const f of fns) {\n            const res = f();\n            if (res !== null) {\n                return res;\n            }\n        }\n        return null;\n    }\n    private regexAccept(match: string, dpth: number, cr?: ErrorTracker): Nullable<string> {\n        return this.run<string>(dpth,\n            () => {\n                const reg = new RegExp(match, \"y\");\n                const mrk = this.mark();\n                reg.lastIndex = mrk.overallPos;\n                const res = this.tryConsume(reg);\n                if(cr) {\n                    cr.record(mrk, res, {\n                        kind: \"RegexMatch\",\n                        // We substring from 3 to len - 1 to strip off the\n                        // non-capture group syntax added as a WebKit workaround\n                        literal: match.substring(3, match.length - 1),\n                        negated: this.negating,\n                    });\n                }\n                return res;\n            });\n    }\n    private tryConsume(reg: RegExp): Nullable<string> {\n        const res = reg.exec(this.input);\n        if (res) {\n            let lineJmp = 0;\n            let lind = -1;\n            for (let i = 0; i < res[0].length; ++i) {\n                if (res[0][i] === \"\\n\") {\n                    ++lineJmp;\n                    lind = i;\n                }\n            }\n            this.pos = {\n                overallPos: reg.lastIndex,\n                line: this.pos.line + lineJmp,\n                offset: lind === -1 ? this.pos.offset + res[0].length : (res[0].length - lind - 1)\n            };\n            return res[0];\n        }\n        return null;\n    }\n    private noConsume<T>(fn: $$RuleType<T>): Nullable<T> {\n        const mrk = this.mark();\n        const res = fn();\n        this.reset(mrk);\n        return res;\n    }\n    private negate<T>(fn: $$RuleType<T>): Nullable<boolean> {\n        const mrk = this.mark();\n        const oneg = this.negating;\n        this.negating = !oneg;\n        const res = fn();\n        this.negating = oneg;\n        this.reset(mrk);\n        return res === null ? true : null;\n    }\n    private memoise<K>(rule: $$RuleType<K>, memo: Map<number, [Nullable<K>, PosInfo]>): Nullable<K> {\n        const $scope$pos = this.mark();\n        const $scope$memoRes = memo.get($scope$pos.overallPos);\n        if(this.memoSafe && $scope$memoRes !== undefined) {\n        this.reset($scope$memoRes[1]);\n        return $scope$memoRes[0];\n        }\n        const $scope$result = rule();\n        if(this.memoSafe)\n        memo.set($scope$pos.overallPos, [$scope$result, this.mark()]);\n        return $scope$result;\n    }\n    private match$EOF(et?: ErrorTracker): Nullable<{kind: ASTKinds.$EOF}> {\n        const res: {kind: ASTKinds.$EOF} | null = this.finished() ? { kind: ASTKinds.$EOF } : null;\n        if(et)\n            et.record(this.mark(), res, { kind: \"EOF\", negated: this.negating });\n        return res;\n    }\n}\nexport function parse(s: string): ParseResult {\n    const p = new Parser(s);\n    return p.parse();\n}\nexport interface ParseResult {\n    ast: Nullable<Start>;\n    errs: SyntaxErr[];\n}\nexport interface PosInfo {\n    readonly overallPos: number;\n    readonly line: number;\n    readonly offset: number;\n}\nexport interface RegexMatch {\n    readonly kind: \"RegexMatch\";\n    readonly negated: boolean;\n    readonly literal: string;\n}\nexport type EOFMatch = { kind: \"EOF\"; negated: boolean };\nexport type MatchAttempt = RegexMatch | EOFMatch;\nexport class SyntaxErr {\n    public pos: PosInfo;\n    public expmatches: MatchAttempt[];\n    constructor(pos: PosInfo, expmatches: MatchAttempt[]) {\n        this.pos = pos;\n        this.expmatches = [...expmatches];\n    }\n    public toString(): string {\n        return `Syntax Error at line ${this.pos.line}:${this.pos.offset}. Expected one of ${this.expmatches.map(x => x.kind === \"EOF\" ? \" EOF\" : ` ${x.negated ? 'not ': ''}'${x.literal}'`)}`;\n    }\n}\nclass ErrorTracker {\n    private mxpos: PosInfo = {overallPos: -1, line: -1, offset: -1};\n    private regexset: Set<string> = new Set();\n    private pmatches: MatchAttempt[] = [];\n    public record(pos: PosInfo, result: any, att: MatchAttempt) {\n        if ((result === null) === att.negated)\n            return;\n        if (pos.overallPos > this.mxpos.overallPos) {\n            this.mxpos = pos;\n            this.pmatches = [];\n            this.regexset.clear()\n        }\n        if (this.mxpos.overallPos === pos.overallPos) {\n            if(att.kind === \"RegexMatch\") {\n                if(!this.regexset.has(att.literal))\n                    this.pmatches.push(att);\n                this.regexset.add(att.literal);\n            } else {\n                this.pmatches.push(att);\n            }\n        }\n    }\n    public getErr(): SyntaxErr | null {\n        if (this.mxpos.overallPos !== -1)\n            return new SyntaxErr(this.mxpos, this.pmatches);\n        return null;\n    }\n}","import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';\nimport type { RootState, AppDispatch } from './store';\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\n","import ts from 'ts-toolbelt';\n\ntype Key = ts.Any.Key\n\nexport const map = <T, U>(obj: T, fn: (k: keyof T, v: T[keyof T], i: number) => any) =>\n  Object.fromEntries<U>(\n    (Object.entries(obj) as ([keyof T, T[keyof T]])[]).map(\n      ([k, v], i) => [k, fn(k, v, i)]))\n\nexport const hasProperty = <X extends {}, Y extends PropertyKey>(obj: X, prop: Y): obj is X & Record<Y, unknown> =>\n  obj.hasOwnProperty(prop)\n\nexport const get =\n  <P extends Key>(key: P) =>\n  <T extends Record<P, T[P]>>(obj: T) =>\n    obj[key]\nexport const getN =\n  <P extends Key>(key: P) =>\n  <T extends Partial<Record<P, T[P]>>>(obj: T) =>\n    obj[key]\n\nexport const set =\n  <P extends Key>(key: P) =>\n  <T extends Record<P, T[P]>>(value: T[P]) =>\n  (obj: T) => {\n    obj[key] = value\n  }\nexport const update =\n  <P extends Key>(key: P) =>\n  <T extends Record<P, T[P]>>(value: T[P]) =>\n  (obj: T) => { \n    set(key)(value)(obj)\n    return value\n  }","import { number, ord, readonlyNonEmptyArray } from 'fp-ts';\nimport { flow, pipe } from 'fp-ts/lib/function';\n\nexport const assertUnreachable = (x: never) => {\n  throw new Error (`shouldn't get here with ${JSON.stringify(x)}`)\n}\n\nexport const debug = <T>(x: T) => { debugger; return x }\n\nexport const ordAscending = <T>(array: readonlyNonEmptyArray.ReadonlyNonEmptyArray<T>) =>\n  pipe(number.Ord, ord.contramap<number, T>(x => array.indexOf(x)))\n\nexport const ordDescending = flow(ordAscending, ord.reverse)\n\n","import { either, eq, number, option, ord, readonlyArray, readonlyNonEmptyArray as RNEA, readonlyRecord, readonlySet, string } from 'fp-ts';\nimport { flow, pipe } from 'fp-ts/lib/function';\nimport * as t from 'io-ts';\nimport { MersenneTwister19937, shuffle } from 'random-js';\n\nimport { ordAscending, ordDescending } from '../lib';\n\nexport const suits = ['C', 'D', 'H', 'S'] as const\nexport type Suit = typeof suits[number]\nexport const eqSuit : eq.Eq<Suit> = eq.eqStrict\nexport const ordSuitDescending : ord.Ord<Suit> = ordDescending(suits)\nexport const ordSuitAscending : ord.Ord<Suit> = ordAscending(suits)\n\nexport const rankStrings = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'] as const\nexport type RankString = typeof rankStrings[number]\nconst RankB = t.brand(t.number, (i) : i is t.Branded<number, { readonly Rank: unique symbol }> => i >= 2 && i <= 14, 'Rank')\nexport const RankC = new t.Type('Rank', RankB.is, RankB.validate, r => rankStrings[r - 2])\nexport type Rank = t.TypeOf<typeof RankC>\nexport const eqRank : eq.Eq<Rank> = eq.eqStrict\nexport const ordRankAscending : ord.Ord<Rank> = number.Ord\nexport const ordRankDescending : ord.Ord<Rank> = pipe(ordRankAscending, ord.reverse)\nexport const ranks =\n  pipe(rankStrings,\n    readonlyArray.mapWithIndex((idx, _) =>\n      pipe(idx + 2,\n        RankC.decode,\n        x => (x as either.Right<Rank>).right)))\nexport const honors =\n  pipe(ranks, readonlyArray.takeRight(5))\nexport const rankFromString = (r: string) =>\n  pipe(rankStrings,\n    readonlyArray.findIndex(r2 => { return string.Eq.equals(r, r2) }),\n    option.chain(idx =>\n      pipe(ranks, readonlyArray.lookup(idx))))\n\nexport interface Card {\n  suit: Suit\n  rank: Rank\n}\nexport const eqCard : eq.Eq<Card> = eq.struct({\n  suit: eqSuit,\n  rank: eqRank\n})\nexport const ordCardDescending : ord.Ord<Card> = ord.getMonoid<Card>().concat(\n  pipe(ordSuitDescending, ord.contramap(c => c.suit)),\n  pipe(ordRankDescending, ord.contramap(c => c.rank))\n)\n\nexport const cards: RNEA.ReadonlyNonEmptyArray<Card> =\n  pipe(52, RNEA.makeBy(i => ({\n    suit: suits[Math.floor(i / 13)],\n    rank: (RankC.decode((i % 13) + 2) as either.Right<Rank>).right\n  })))\n\nexport type Hand = ReadonlySet<Card>\nexport type GroupedHand = readonlyRecord.ReadonlyRecord<Suit, ReadonlyArray<Rank>>\nexport const getOrdGroupedHand = <T>() =>\n  ord.contramap(([suit, _]: readonly [Suit, T]) => suit)(ordSuitDescending)\nexport const zeroGroupedHand : GroupedHand = ({\n  S: [],\n  H: [],\n  D: [],\n  C: [],\n})\n\nexport const groupHandBySuits = (hand: Hand) : GroupedHand =>\n  pipe(hand,\n    readonlySet.toReadonlyArray(ordCardDescending),\n    RNEA.fromReadonlyArray,\n    option.fold(() => zeroGroupedHand, flow(\n      RNEA.groupBy(c => c.suit),\n      readonlyRecord.map(RNEA.map(c => c.rank)),\n      readonlyRecord.union(readonlyArray.getUnionMonoid(eqRank))(zeroGroupedHand)\n    )))\n\nexport type Deck = RNEA.ReadonlyNonEmptyArray<Card>\n\nexport const engine = { engine: MersenneTwister19937.autoSeed() }\nexport const newDeck = () : Deck =>\n  shuffle(engine.engine, [...cards]) as unknown as Deck\n","import { apply, eq, number, ord, readonlyArray as RA, readonlyNonEmptyArray as RNEA, readonlyRecord, readonlySet as RS, readonlyTuple as RT, refinement, string } from 'fp-ts';\nimport { flow, pipe } from 'fp-ts/lib/function';\n\nimport { ordAscending } from '../lib';\nimport { Deck, eqCard, Hand, suits } from './deck';\n\nexport const directions = ['N', 'E', 'S', 'W'] as const\nexport type Direction = typeof directions[number]\nexport const eqDirection : eq.Eq<Direction> = string.Eq\nexport const ordDirection = ordAscending(directions)\n\nexport const partnerships = [\"NorthSouth\", \"EastWest\"] as const\nexport type Partnership = typeof partnerships[number]\nexport const eqPartnership : eq.Eq<Partnership> = string.Eq\nexport const ordPartnership = ordAscending(partnerships)\n\nexport const getPartnershipByDirection = (d: Direction): Partnership =>\n  (d === 'N' || d === 'S') ? \"NorthSouth\" : \"EastWest\"\n\nexport type Deal = readonlyRecord.ReadonlyRecord<Direction, Hand>\nexport type Player = {\n  direction: Direction\n  hand: Hand\n}\nexport const eqHand : eq.Eq<Hand> = RS.getEq(eqCard)\n\nexport const deal = (deck: Deck) : Deal =>\n  pipe(directions,\n    RNEA.zip(RNEA.chunksOf(13)(deck)),\n    RNEA.groupBy(RT.fst),\n    readonlyRecord.map(flow(RNEA.head, RT.snd, RS.fromReadonlyArray(eqCard))),\n    (x: readonlyRecord.ReadonlyRecord<Direction, Hand>) => x)\nexport const eqDeal : eq.Eq<Deal> =\n  readonlyRecord.getEq<Direction, Hand>(eqHand)\n\nexport const vulnerabilities = [\"Neither\", \"NorthSouth\", \"EastWest\", \"Both\"] as const\nexport type Vulnerability = typeof vulnerabilities[number]\n\nexport const getIsVulnerable = (dir: Direction, vul: Vulnerability) =>  \n  !(vul === \"Neither\") && ((vul === \"Both\") || getPartnershipByDirection(dir) === vul)\n\nexport const strains = [...suits, 'N'] as const\nexport type Strain = typeof strains[number]\nexport const eqStrain : eq.Eq<Strain> = eq.eqStrict\nexport const ordStrain : ord.Ord<Strain> = ordAscending(strains)\n\nexport const minors: ReadonlyArray<Strain> = ['C', 'D']\nexport const majors: ReadonlyArray<Strain> = ['H', 'S']\n\nexport interface Board {\n  dealer: Direction\n  deal: Deal\n}\nexport const eqBoard : eq.Eq<Board> = eq.struct({\n  dealer: eqDirection,\n  deal: eqDeal\n})\n\nexport interface BoardWithDetail extends Board {\n  number: number\n  vulnerability: Vulnerability\n}\n\nconst boneChart = (boardNumber: number) : Vulnerability => {\n  switch ((boardNumber % 16) + 1) {\n    case 1: case 8: case 11: case 14: return \"Neither\"\n    case 2: case 5: case 12: case 15: return \"NorthSouth\"\n    case 3: case 6: case 9:  case 16: return \"EastWest\"\n    case 4: case 7: case 10: case 13: return \"Both\"\n    default: throw Error(\"Not possible\")\n  }\n}\n\nexport const makeBoard = (number: number) => (deal: Deal) : BoardWithDetail => ({\n  number,\n  dealer: directions[(number - 1) % directions.length],\n  deal,\n  vulnerability: boneChart(number)\n})\n\nexport const nonContractBids = [\"Pass\", \"Double\", \"Redouble\"] as const\nexport type NonContractBid = typeof nonContractBids[number]\nexport const eqNonContractBid : eq.Eq<NonContractBid> = string.Eq\nexport const isNonContractBid = (b: unknown) : b is NonContractBid =>\n  typeof b === \"string\" && pipe(nonContractBids, RA.elem<string>(string.Eq)(b))\n\nexport interface ContractBid {\n  level: number\n  strain: Strain\n}\nexport const eqContractBid : eq.Eq<ContractBid> = eq.struct({\n  level: number.Eq,\n  strain: string.Eq\n})\nexport const ordContractBid : ord.Ord<ContractBid> =\n  ord.getMonoid<ContractBid>().concat(\n    pipe(number.Ord, ord.contramap(c => c.level)),\n    pipe(ordStrain, ord.contramap(c => c.strain))\n  )\nexport const contractBids : ReadonlyArray<ContractBid> =\n  pipe(\n    apply.sequenceS(RA.Apply)(({\n      level: RA.makeBy(7, level => level + 1),\n      strain: strains\n    })),\n    RA.sort(ordContractBid))\n\nexport type Bid = NonContractBid | ContractBid\nexport const isContractBid = (b: Bid): b is ContractBid => !isNonContractBid(b)\n\nexport const eqBid : eq.Eq<Bid> = eq.fromEquals((x, y) =>\n  (isNonContractBid(x) && isNonContractBid(y) && eqNonContractBid.equals(x, y)) ||\n  (!isNonContractBid(x) && !isNonContractBid(y) && eqContractBid.equals(x, y)))\n\nexport const isGameLevel = (bid: Bid) =>\n  isContractBid(bid) && ord.geq(ordContractBid)(bid, { level: 3, strain: \"N\" })\nexport const isSlamLevel = (bid: Bid) =>\n  isContractBid(bid) && ord.gt(ordContractBid)(bid, { level: 5, strain: \"N\" })\n\nexport const contractModifiers = [\"Undoubled\", \"Doubled\", \"Redoubled\"] as const\nexport type ContractModifier = typeof contractModifiers[number]\nexport interface Contract extends ContractBid {\n  modifier: ContractModifier\n}\nexport const eqContract : eq.Eq<Contract> = eq.struct({\n  level: number.Eq,\n  strain: string.Eq,\n  modifier: string.Eq\n})\nexport const fromBid = (bid: ContractBid): Contract =>\n  ({ ...bid, modifier: \"Undoubled\" })\n\nexport type Auction = RNEA.ReadonlyNonEmptyArray<Bid>\nconst consecutivePasses = [\"Pass\", \"Pass\", \"Pass\"] as const\nexport type NonPassAuction = Auction & [...Auction, ...typeof consecutivePasses]\nconst passout = [\"Pass\", \"Pass\", \"Pass\", \"Pass\"] as const\nexport type PassAuction = typeof passout\nexport type CompletedAuction = NonPassAuction | PassAuction\nexport const eqAuction : eq.Eq<Auction> = RNEA.getEq(eqBid)\nexport const isCompletedAuction : refinement.Refinement<Auction, CompletedAuction> = (a): a is CompletedAuction =>\n  a.length >= 4 &&\n  (eqAuction.equals(a, passout) || eqAuction.equals(a.slice(a.length - 3) as unknown as Auction, consecutivePasses))\n\nexport interface BoardWithAuction extends Board {\n  auction: Auction \n}\nexport interface BoardWithCompletedAuction extends BoardWithAuction {\n  auction: CompletedAuction\n}\n","import { either, magma, number, option as O, readonlyRecord as RR, semigroup } from 'fp-ts';\nimport { Right } from 'fp-ts/lib/Either';\nimport { Lazy, pipe } from 'fp-ts/lib/function';\nimport * as t from 'io-ts';\nimport objectHash from 'object-hash';\nimport { UuidTool } from 'uuid-tool';\n\nimport { assertUnreachable } from '../lib';\nimport { get } from '../lib/object';\nimport { SatisfiesResult } from '../workers';\nimport { DoubleDummyResult } from '../workers/dds.worker';\nimport { SerializedBidPath, SerializedDeal } from './serialization';\nimport { Stats } from './stats';\nimport { Path, Paths } from './system';\nimport { ConstrainedBid } from './system/core';\n\nexport const DateNumberB = t.brand(t.number, (d): d is t.Branded<number, { readonly Date: unique symbol }> => true, \"Date\")\nexport type DateNumber = t.TypeOf<typeof DateNumberB>\nexport const now : Lazy<DateNumber> = () => pipe(new Date().getTime(), DateNumberB.decode, x => (x as either.Right<DateNumber>).right)\n\nconst timeSpanC = t.tuple([DateNumberB, DateNumberB])\nexport type TimeSpan = t.TypeOf<typeof timeSpanC>\n\ninterface ProgressData<T> {\n  unitsDone: number\n  updateDate: DateNumber\n  speed: O.Option<number>\n  value: T\n}\ntype Progress<T> = O.Option<ProgressData<T>>\n\nexport const getGenericProgress = (job: Job) =>\n  job.type.progress as Progress<never>\n\nexport const initProgress = <T>(value: T): Progress<T> => O.some({\n  unitsDone: 0,\n  updateDate: now(),\n  speed: O.none,\n  value\n})\n\nconst SMOOTHING_FACTOR = 0.1\nexport const updateProgress = <T>(M: magma.Magma<T>) => (unitsDone: number) => (value: T) => (progress: Progress<T>): Progress<T> =>\n  pipe(progress,\n    O.map(p => {\n      const updateDate = now()\n      const speed = (updateDate - p.updateDate) / unitsDone\n      return {\n        unitsDone: p.unitsDone + unitsDone,\n        updateDate,\n        value: M.concat(p.value, value),\n        speed: pipe(p.speed,\n          O.map(avg => (1 - SMOOTHING_FACTOR) * avg + (SMOOTHING_FACTOR) * (\n            (updateDate - p.updateDate) / unitsDone)),\n          O.alt(() => O.some(speed)))\n      }\n    }))\n\nexport const GenerationIdB = t.brand(t.string, (id): id is t.Branded<string, { readonly GenerationId: unique symbol }> => UuidTool.isUuid(id), \"GenerationId\")\nexport type GenerationId = t.TypeOf<typeof GenerationIdB>\nexport const newGenerationId = () => (GenerationIdB.decode(UuidTool.newUuid()) as Right<GenerationId>).right\n\nexport type Satisfies = RR.ReadonlyRecord<SerializedBidPath, number>\nexport interface Generation {\n  id: GenerationId\n  dealCount: number\n  satisfies: O.Option<Satisfies>\n  solutionStats: RR.ReadonlyRecord<SerializedBidPath, Stats>\n}\nexport const zeroGeneration = (id: GenerationId, dealCount: number) : Generation => ({\n  id,\n  dealCount,\n  satisfies: O.none,\n  solutionStats: {}\n})\n\nexport const AnalysisIdB = t.brand(t.string, (id): id is t.Branded<string, { readonly AnalysisId: unique symbol }> => UuidTool.isUuid(id), \"AnalysisId\")\nexport type AnalysisId = t.TypeOf<typeof AnalysisIdB>\nconst newAnalysisId = () => (AnalysisIdB.decode(UuidTool.newUuid()) as Right<AnalysisId>).right\nexport interface Analysis {\n  id: AnalysisId\n  name: string\n  paths: Paths<ConstrainedBid>\n  generations: ReadonlyArray<Generation>\n}\nexport const zeroAnalysis = (paths: Paths<ConstrainedBid>) : Analysis => ({\n  id: newAnalysisId(),\n  name: `New analysis (${paths.length} paths)`,\n  paths,\n  generations: []\n})\n\nexport interface JobTypeGenerateDeals {\n  type: \"GenerateDeals\",\n  parameter: number\n  context: { generationId: GenerationId }\n  progress: Progress<number>\n}\nconst zeroGenerateDealsProgress = () => initProgress(0)\nexport const updateGenerateDealsProgress = (deals: ReadonlyArray<any>) =>\n  updateProgress\n    (number.MonoidSum)\n    (deals.length)\n    (deals.length)\n\nconst ConstrainedBidPathHashC = t.brand(t.string, (hash): hash is t.Branded<string, { readonly PathHash: unique symbol }> => true, \"PathHash\")\nexport type ConstrainedBidPathHash = t.TypeOf<typeof ConstrainedBidPathHashC>\nexport const getBidPathHash = (cb: Path<ConstrainedBid>) => (ConstrainedBidPathHashC.decode(objectHash(cb)) as Right<ConstrainedBidPathHash>).right\nexport interface JobTypeSatisfies {\n  type: \"Satisfies\",\n  parameter: Paths<ConstrainedBid>\n  context: JobTypeGenerateDeals[\"context\"]\n  progress: Progress<Satisfies>\n}\nconst zeroSatisfiesProgress = () => initProgress<Satisfies>({})\nexport const updateSatisfiesProgress = (result: SatisfiesResult) =>\n  updateProgress\n    (RR.getUnionSemigroup(number.MonoidSum))\n    (result.testedCount)\n    ({ [result.path]: result.satisfiesCount })\n\nexport type Solution = RR.ReadonlyRecord<SerializedDeal[\"id\"], DoubleDummyResult>\nexport interface JobTypeSolve {\n  type: \"Solve\",\n  parameter: ReadonlyArray<SerializedDeal>\n  context: { generationId: GenerationId, bidPath: SerializedBidPath }\n  progress: Progress<Solution>\n}\nconst zeroSolveProgress = () => initProgress<Solution>({})\nexport const updateSolveProgress = (solutions: Solution) =>\n  updateProgress\n    (RR.getUnionSemigroup(semigroup.first<DoubleDummyResult>()))\n    (pipe(solutions, RR.keys, keys => keys.length))\n    (solutions)\n\nexport type JobType =\n  | JobTypeGenerateDeals\n  | JobTypeSatisfies\n  | JobTypeSolve\n\nexport const initJobProgress = (type: JobType[\"type\"]) => {\n  switch (type) {\n    case \"GenerateDeals\": return zeroGenerateDealsProgress()\n    case \"Satisfies\": return zeroSatisfiesProgress()\n    case \"Solve\": return zeroSolveProgress()\n    default: return assertUnreachable(type)\n  }\n}\n\nexport const JobIdB = t.brand(t.string, (id): id is t.Branded<string, { readonly JobId: unique symbol }> => UuidTool.isUuid(id), \"JobId\")\nexport type JobId = t.TypeOf<typeof JobIdB>\nconst newJobId = () => (JobIdB.decode(UuidTool.newUuid()) as Right<JobId>).right\nexport interface Job {\n  id: JobId\n  analysisId: AnalysisId\n  dependsOn: ReadonlyArray<JobId>\n  type: JobType\n  unitsInitial: number\n  startDate: O.Option<DateNumber>\n  completedDate: O.Option<DateNumber>\n  running: boolean\n  error: O.Option<string>\n}\nexport const zeroJob = (analysisId: AnalysisId, estimatedUnitsInitial: number, type: JobType): Job => ({\n  id: newJobId(),\n  analysisId,\n  dependsOn: [],\n  type,\n  unitsInitial: estimatedUnitsInitial,\n  startDate: O.none,\n  completedDate: O.none,\n  running: false,\n  error: O.none\n})\n\nexport const unitsRemaining = (job: Job) =>\n  pipe(job,\n    getGenericProgress,\n    O.fold(() => 0, get('unitsDone')),\n    done => job.unitsInitial - done)\n\nexport const percentageRemaining = (job: Job) =>\n  pipe(job,\n    getGenericProgress,\n    O.fold(() => 0, get('unitsDone')),\n    done => Math.floor(done * 100 / job.unitsInitial))\n\nexport const elapsedTime = (job: Job) =>\n  pipe(O.Do,\n    O.apS('progress', pipe(job, getGenericProgress)),\n    O.apS('start', job.startDate),\n    O.map((o): TimeSpan => [o.progress.updateDate, o.start]))\n\nexport const estimatedTimeRemaining = (job: Job) =>\n  pipe(O.Do,\n    O.apS('start', job.startDate),\n    O.apS('progress', pipe(job, getGenericProgress)),\n    O.bind('speed', ({ progress }) => progress.speed),\n    O.map(o => o.speed * (job.unitsInitial - o.progress.unitsDone)))","import { either, eq, number, option, ord, readonlyArray, readonlyRecord, writer } from 'fp-ts';\nimport { constant, flow, identity, pipe } from 'fp-ts/lib/function';\nimport * as t from 'io-ts';\nimport { assertUnreachable } from '../lib';\nimport { Contract, ContractModifier, eqStrain, minors, Strain } from './bridge';\n\n\nexport interface ScoreInfo {\n  contract: Contract\n  tricks: number\n  isVulnerable: boolean\n}\n\ntype ScoreComponent = (info: ScoreInfo) => number\n\nconst contractPointMultiplier = (strain: Strain) => \n  pipe(minors, readonlyArray.elem(eqStrain)(strain)) ? 20 : 30\n\nconst contractModMultiplier = (modifier: ContractModifier) => {\n  switch (modifier) {\n    case \"Undoubled\": return 1\n    case \"Doubled\"  : return 2\n    case \"Redoubled\": return 4\n    default: return assertUnreachable(modifier)\n  }\n}\n\nconst contractFirstTrickModifier = (strain: Strain) =>\n  strain === \"N\" ? 10 : 0\n\nconst subtractBookTricks = (tricks: number) =>\n  tricks - 6\n\nexport const making = (contract: Contract, tricks: number) =>\n  pipe(\n    tricks,\n    subtractBookTricks,\n    either.fromPredicate(\n      oddTricks => oddTricks >= contract.level,\n      oddTricks => contract.level - oddTricks))\n\nconst getOddTricks =\n  flow(making, option.fromEither)\n\nconst getOvertricks = (contract: Contract, tricks: number) =>\n  pipe(making(contract, tricks),\n    option.fromEither,\n    option.map(oddTricks => oddTricks - contract.level))\n\nconst getUndertricks = (contract: Contract, tricks: number) =>\n  pipe(making(contract, tricks),\n    either.swap,\n    option.fromEither)\n\nconst whenMaking = (f: (oddTricks: number) => number) => (info: ScoreInfo) =>\n  pipe(getOddTricks(info.contract, info.tricks),\n    option.fold(constant(0), f))\n\nconst contractPoints: ScoreComponent = info =>\n  pipe(info, whenMaking(() =>\n    contractModMultiplier(info.contract.modifier) *\n    ((info.contract.level * contractPointMultiplier(info.contract.strain)) + contractFirstTrickModifier(info.contract.strain))))\n\nconst vulnerableMultiplier = (isVulnerable: boolean) =>\n  50 * (isVulnerable ? 2 : 1)\n\nconst getModified = (modifier: ContractModifier) : option.Option<\"Doubled\" | \"Redoubled\"> =>\n  modifier === \"Undoubled\" ? option.none : option.some(modifier)\n\nconst overtrickBonus = (isVulnerable: boolean, modifier: ContractModifier) => \n  pipe(modifier,\n    getModified,\n    option.map(contractModMultiplier),\n    option.map(x => x * vulnerableMultiplier(isVulnerable)))\n\nconst overtrickPoints: ScoreComponent = info =>\n  pipe(getOvertricks(info.contract, info.tricks),\n    option.fold(constant(0), overtricks =>\n      pipe(\n        overtrickBonus(info.isVulnerable, info.contract.modifier),\n        option.getOrElseW(() => contractPointMultiplier(info.contract.strain)),\n        multiplier => overtricks * multiplier)))\n\nconst slamPoints: ScoreComponent = info =>\n  pipe(info, whenMaking(oddTricks =>\n    (info.isVulnerable ? 1.5 : 1) *\n    (info.contract.level === 6 && oddTricks >= 6 ? 500 :\n      info.contract.level === 7 && oddTricks >= 7 ? 1000 : 0)))\n\nconst modifierPoints: ScoreComponent = info =>\n  pipe(info, whenMaking(() => {\n    switch (info.contract.modifier) {\n      case \"Undoubled\": return 0\n      case \"Doubled\"  : return 50\n      case \"Redoubled\": return 100\n      default: return assertUnreachable(info.contract.modifier)\n    }\n  }))\n\nconst doubledPenalties = [100, 200, 200, ...readonlyArray.replicate(10, 300)]\n\nconst penaltyPoints: ScoreComponent = info =>\n  pipe(getUndertricks(info.contract, info.tricks),\n    option.fold(constant(0), undertricks =>\n      pipe(info.contract.modifier,\n        getModified,\n        option.fold(\n          () => undertricks * vulnerableMultiplier(info.isVulnerable),\n          flow(contractModMultiplier,\n            multiplier => (multiplier / 2) * pipe(\n              doubledPenalties,\n              readonlyArray.takeLeft(undertricks + (info.isVulnerable ? 1 : 0)),\n              readonlyArray.foldMap(number.MonoidSum)(identity)))),\n        x => -x)))\n\nconst partScorePoints: ScoreComponent =\n  flow(contractPoints, score =>\n    score > 0 && score <= 100 ? 50 : 0)\n\nconst gamePoints: ScoreComponent = info =>\n  pipe(info, contractPoints, score =>\n    score >= 100 ? (info.isVulnerable ? 500 : 300) : 0)\n\nconst scoreComponents : readonlyRecord.ReadonlyRecord<string, ScoreComponent> = {\n  contractPoints : contractPoints,\n  overtrickPoints: overtrickPoints,\n  slamPoints     : slamPoints,\n  modifierPoints : modifierPoints,\n  penaltyPoints  : penaltyPoints,\n  partScorePoints: partScorePoints,\n  gamePoints     : gamePoints,\n}\n\nconst ScoreC = t.brand(t.number, (i) : i is t.Branded<number, { readonly Score: unique symbol }> => typeof i === \"number\", 'Score')\nexport type Score = t.TypeOf<typeof ScoreC>\nexport const zeroScore = (ScoreC.decode(0) as either.Right<Score>).right\nexport const eqScore : eq.Eq<Score> = number.Eq\nexport const ordScore : ord.Ord<Score> = pipe(number.Ord, ord.reverse)\n\nexport type ScoreComponentLog = readonly [string, number]\n\ntype W = ReadonlyArray<ScoreComponentLog>\nexport const scoreW = (info: ScoreInfo): writer.Writer<W, Score> => \n  pipe(\n    scoreComponents,\n    readonlyRecord.flap(info),\n    readonlyRecord.traverseWithIndex(writer.getApplicative(readonlyArray.getMonoid<ScoreComponentLog>()))((name, score) => pipe(\n      writer.tell([[name, score]] as const),\n      writer.map(constant(score)))),\n    writer.map(flow(\n      readonlyRecord.foldMap(ord.trivial)(number.MonoidSum)(identity),\n      ScoreC.decode,\n      s => (s as either.Right<Score>).right)),\n    writer.map((s): [Score, (w: W) => W] => [s, cs => [[\"TOTAL\", s], ...cs]]),\n    writer.pass)\n\nexport const score = flow(scoreW, writer.evaluate)","import { either, eitherT, option, readonlyArray, readonlyMap, readonlyNonEmptyArray as RNEA, readonlyRecord as RR, readonlyTuple, refinement, semigroup } from 'fp-ts';\nimport { constant, flow, pipe } from 'fp-ts/lib/function';\nimport { ordAscending, ordDescending } from '../lib';\nimport { ContractBid, contractBids, ContractModifier, Direction, getIsVulnerable, ordContractBid, Strain, Vulnerability } from './bridge';\nimport { eqScore, making, ordScore, Score, score, zeroScore } from './score';\n\n\nexport type TrickCountsByStrain = RR.ReadonlyRecord<Strain, number>\nexport type TrickCountsByDirection = RR.ReadonlyRecord<Direction, number>\nexport type TrickCountsByStrainThenDirection = RR.ReadonlyRecord<Strain, TrickCountsByDirection>\nexport type TrickCountsByDirectionThenStrain = RR.ReadonlyRecord<Direction, TrickCountsByStrain>\n\nexport const flattenNestedCounts = <K1 extends string, K2 extends string, T>(table: RR.ReadonlyRecord<K1, RR.ReadonlyRecord<K2, T>>) =>\n  pipe(readonlyArray.Do,\n    readonlyArray.apS('inner', pipe(table, RR.toReadonlyArray)),\n    readonlyArray.bind('outer', ({ inner }) => pipe(inner[1], RR.toReadonlyArray)),\n    readonlyArray.map(({ outer, inner }) => ({ outerKey: outer[0], innerKey: inner[0], value: outer[1] })))\n\nexport const transpose = <K1 extends string, K2 extends string, T>(table: RR.ReadonlyRecord<K1, RR.ReadonlyRecord<K2, T>>) : RR.ReadonlyRecord<K2, RR.ReadonlyRecord<K1, T>> =>\n  pipe(table,\n    flattenNestedCounts,\n    RNEA.fromReadonlyArray,\n    option.fold(() => ({}),\n    RNEA.groupBy(x => x.outerKey)),\n    RR.map(flow(\n      RNEA.fromReadonlyArray,\n      option.fold(() => ({}),\n      RNEA.groupBy(x => x.innerKey)),\n      RR.map(x => x[0].value))))\n\n\ntype OptimalBid = ContractBid | \"Pass\"\nconst initialContractBid: refinement.Refinement<OptimalBid, ContractBid> = (b): b is ContractBid => b !== \"Pass\"\nconst initialBids = pipe(\n  contractBids,\n  readonlyArray.sort(ordContractBid),\n  readonlyArray.prepend<OptimalBid>(\"Pass\"))\nconst ordInitialBidsAscending = ordAscending(initialBids)\nconst ordInitialBidsDescending = ordDescending(initialBids)\n\ntype ContractScorePair = readonly [OptimalBid, Score]\nconst getDirectionScores = (counts: TrickCountsByStrain) => (isVulnerable: boolean) =>\n  pipe(initialBids,\n    readonlyArray.map(either.fromPredicate(initialContractBid, () => \"Pass\" as const)),\n    eitherT.match(readonlyArray.Functor)(\n      (pass): ContractScorePair => [pass, zeroScore],\n      (bid): ContractScorePair => {\n        const tricks = counts[bid.strain]\n        const modifier: ContractModifier = pipe(\n          making({ ...bid, modifier: \"Undoubled\" }, tricks),\n          either.fold(constant(\"Doubled\"), constant(\"Undoubled\")))\n        return [bid, score({ contract: { ...bid, modifier}, tricks, isVulnerable })]\n      }))\n\nconst getAllScores = (table: TrickCountsByDirectionThenStrain) => (vulnerability: Vulnerability) =>\n  pipe(table,\n    RR.mapWithIndex((direction, counts) =>\n      getDirectionScores(counts)(getIsVulnerable(direction, vulnerability))))\n\n// const byContractDescending : ord.Ord<ContractScorePair> =\n//   ord.contramap(readonlyTuple.fst)(ordInitialBidsDescending)\n\nconst shakeContracts = (contractScorePairs: RNEA.ReadonlyNonEmptyArray<ContractScorePair>) =>\n  pipe(contractScorePairs,\n    RNEA.map(readonlyTuple.swap),\n    readonlyMap.fromFoldable(eqScore, semigroup.max(ordInitialBidsDescending), RNEA.Foldable),\n    readonlyMap.toReadonlyArray(ordScore))\n\nconst pvs = (direction: Direction, availableMoves: RNEA.ReadonlyNonEmptyArray<ContractScorePair>): OptimalBid => \"Pass\"\n\nexport interface IndependentVariables {\n  dealer: Direction\n  vulnerability: Vulnerability\n}\nexport const parScore = (table: TrickCountsByStrainThenDirection) => (vars: IndependentVariables): Score => zeroScore\n","import { either, option, readonlyArray, readonlyRecord, semigroup, task, taskEither } from 'fp-ts';\nimport { flow, pipe } from 'fp-ts/lib/function';\n\nimport { TrickCountsByDirectionThenStrain, TrickCountsByStrain } from '../model/analyze';\nimport { Deal, Direction } from '../model/bridge';\nimport { getHandSpecificShape, getHcp, SpecificShape } from '../model/evaluation';\nimport { serializedDealL } from '../model/serialization';\n\nconst baseUrl = process.env.REACT_APP_API_URL\n\nconst safeFetch = (t: task.Task<Response>) =>\n  taskEither.tryCatchK(t, either.toError)()\n\nexport const ping =\n  pipe(() => fetch(`${baseUrl}/ping`),\n    safeFetch,\n    taskEither.chainTaskK(response => () => response.text()),\n    taskEither.filterOrElse(response => response === \"pong\", () => new Error(\"'pong' was not received\")))\n\ninterface DirectionMetadata {\n  hcp: number\n  shape: SpecificShape\n  tricks?: TrickCountsByStrain\n}\n\ntype DealWithSolution = readonly [Deal, option.Option<TrickCountsByDirectionThenStrain>]\n\nconst getRequestBody =\n  readonlyArray.foldMap(readonlyRecord.getUnionMonoid(semigroup.first<Detail>()))(([deal, table]: DealWithSolution) => ({\n    [serializedDealL.get(deal).toString()]: pipe(deal,\n      readonlyRecord.mapWithIndex((d, h): DirectionMetadata => ({\n        hcp: getHcp(h),\n        shape: getHandSpecificShape(h),\n        tricks: pipe(table, option.map(t => t[d]), option.toUndefined)\n      })))\n    }))\n\nconst getRequestBodyWithoutSolution =\n  flow(\n    readonlyArray.map((deal: Deal) => ([deal, option.none] as const)),\n    getRequestBody)\n\ntype Detail = readonlyRecord.ReadonlyRecord<Direction, DirectionMetadata>\nexport const postDeals = (deals: ReadonlyArray<Deal>) =>\n  pipe(deals,\n    getRequestBodyWithoutSolution,\n    JSON.stringify,\n    task.of,\n    task.chain(body => () =>\n      fetch(`${baseUrl}/deals`, {\n        method: \"POST\",\n        body\n      })),\n    safeFetch)\n\nexport const putDeals = (deals: ReadonlyArray<DealWithSolution>) =>\n  pipe(deals,\n    getRequestBody,\n    JSON.stringify,\n    task.of,\n    task.chain(body => () =>\n      fetch(`${baseUrl}/deals`, {\n        method: \"PUT\",\n        body\n      })),\n    safeFetch)\n\nexport const postDeal = (deal: Deal) => postDeals([deal])","import { readonlyArray } from 'fp-ts';\nimport { apply, pipe } from 'fp-ts/lib/function';\nimport { from, Observable, ObservableInput, Subject, zip } from 'rxjs';\nimport { finalize, mergeMap, tap } from 'rxjs/operators';\n\n// adapted from https://github.com/cloudnc/observable-webworker/blob/master/projects/observable-webworker/src/lib/from-worker-pool.ts\n\ninterface LazyWorker<W extends Worker> {\n  factory: () => W\n  terminate: () => void\n  processing: boolean\n  index: number\n}\n\nconst pool = <W extends Worker, I, O>(ctor: (index: number) => W, doWork: (worker: W) => (input: I) => Promise<O>) => (input$: ObservableInput<I>) => {\n  const maxParallel = navigator.hardwareConcurrency ? navigator.hardwareConcurrency - 1 : 1\n\n  return new Observable<O>(resultObserver => {\n    const idleWorker$$ = new Subject<LazyWorker<W>>()\n\n    let completed = 0\n    let sent = 0\n    let finished = false\n\n    const workers = readonlyArray.makeBy(maxParallel, (index): LazyWorker<W> => {\n      let cachedWorker: W | null = null\n      return {\n        factory: () => cachedWorker ?? (cachedWorker = ctor(index)),\n        terminate() {\n          if (!this.processing && cachedWorker) {\n            // try {\n            //   cachedWorker.terminate()\n            // } catch { }\n          }\n        },\n        processing: false,\n        index,\n      }\n    })\n\n    const processor$ = zip(idleWorker$$, input$).pipe(\n      tap(([worker]) => {\n        sent++\n        worker.processing = true\n      }),\n      finalize(() => {\n        idleWorker$$.complete()\n        finished = true\n        workers.forEach(worker => worker.terminate())\n      }),\n      mergeMap(([worker, item]) =>\n        pipe(worker.factory(),\n          doWork,\n          apply(item),\n          from,\n          finalize(() => {\n            completed++\n            worker.processing = false\n            if (!finished) {\n              idleWorker$$.next(worker)\n            } else {\n              worker.terminate()\n            }\n            // console.log(\"finished: \" + finished + \", sent: \" + sent + \", completed: \" + completed)\n            if (finished && completed === sent) {\n              resultObserver.complete()\n            }\n          }),\n        )))\n\n    const sub = processor$.subscribe(resultObserver)\n    workers.forEach(w => idleWorker$$.next(w))\n    return () => sub.unsubscribe()\n  })\n}\n\nexport default pool","import { either, option as O, readonlyArray as RA, readonlyRecord as RR, semigroup, string, task, taskEither as TE } from 'fp-ts';\nimport { flow, pipe } from 'fp-ts/lib/function';\nimport { DBSchema, deleteDB, IDBPDatabase, IndexNames, openDB } from 'idb';\nimport { UuidTool } from 'uuid-tool';\n\nimport { ConstrainedBidPathHash, GenerationId } from '../model/job';\nimport { SerializedDeal } from '../model/serialization';\nimport { DoubleDummyResult, DoubleDummyTable } from '../workers/dds.worker';\n\ninterface DealDB extends DBSchema {\n  deal: {\n    key: SerializedDeal[\"id\"]\n    value: {\n      deal: SerializedDeal\n      batchId: string\n      generationId: GenerationId\n      solution?: DoubleDummyTable\n    },\n    indexes: {\n      'batch': string,\n      'generation': string\n    }\n  },\n  satisfies: {\n    key: [GenerationId, ConstrainedBidPathHash]\n    value: {\n      generationId: GenerationId\n      deals: ReadonlyArray<SerializedDeal>\n    },\n    indexes: {\n      'generation': string\n    }\n  }\n}\n\ntype DbError =\n  | \"OpenDatabaseFailed\"\n  | \"CommitRejected\"\n  | \"InsertError\"\n  | \"SelectError\"\n  | \"DeleteError\"\n  | \"RecordNotFound\"\n\nexport const deleteDb = \n  TE.tryCatch(() => deleteDB('bridge'), (): DbError => \"DeleteError\")\n\nconst getDb =\n  TE.tryCatch(() =>\n    openDB<DealDB>('bridge', 1, {\n      upgrade: (db) => {\n        const deal = db.createObjectStore(\"deal\")\n        deal.createIndex('batch', 'batchId')\n        deal.createIndex('generation', 'generationId')\n        const satisfies = db.createObjectStore(\"satisfies\")\n        satisfies.createIndex('generation', 'generationId')\n      }\n    }),\n    (): DbError => \"OpenDatabaseFailed\")\n\nexport const insertDeals = (generationId: GenerationId) => (deals: ReadonlyArray<SerializedDeal>) =>\n  pipe(getDb,\n    TE.map(db => db.transaction('deal', 'readwrite')),\n    TE.chainFirst(tran => {\n      const batchId = UuidTool.newUuid()\n      return pipe(deals, TE.traverseArray(deal =>\n        TE.tryCatch(\n          () => tran.store.put({\n            deal,\n            generationId,\n            batchId\n          }, deal.id),\n          (): DbError => \"InsertError\")))\n    }),\n    TE.chain(tran => TE.tryCatch(() => tran.done, (): DbError => \"CommitRejected\")))\n\nexport const insertSolutions = (solutions: ReadonlyArray<DoubleDummyResult>) =>\n  pipe(getDb,\n    TE.map(db => db.transaction('deal', 'readwrite')),\n    TE.bindTo('tran'),\n    TE.chainFirst(({ tran }) => pipe(solutions,\n      TE.traverseArray(s => pipe(s,\n        TE.tryCatchK(s => tran.store.get(s.board.deal.id), (): DbError => \"SelectError\"),\n        TE.chain(flow(either.fromNullable(\"RecordNotFound\" as DbError), task.of)),\n        TE.map(row => { row.solution = s.results; return row }),\n        TE.chain(TE.tryCatchK(row => tran.store.put(row, row.deal.id), (): DbError => \"InsertError\")))))),\n    TE.chain(({ tran }) => TE.tryCatch(() => tran.done, (): DbError => \"CommitRejected\")))\n\nexport const insertSatisfies = (generationId: GenerationId, hash: ConstrainedBidPathHash) => (deals: ReadonlyArray<SerializedDeal>) =>\n  pipe(getDb,\n    TE.map(db => db.transaction('satisfies', 'readwrite')),\n    TE.bindTo('tran'),\n    TE.bind('existingDeals', ({ tran }) => pipe(\n      TE.tryCatch(() => tran.store.get([generationId, hash]), (): DbError => \"SelectError\"),\n      TE.map(flow(O.fromNullable, O.fold(() => [], r => r.deals))))),\n    TE.chainFirst(({ tran, existingDeals }) =>\n      TE.tryCatch(() => tran.store.put({\n        generationId,\n        deals: pipe(existingDeals, RA.concat(deals))\n      }, [generationId, hash]), (): DbError => \"InsertError\")),\n    TE.chain(({ tran }) => TE.tryCatch(() => tran.done, (): DbError => \"CommitRejected\")))\n\nconst getByIndex = <I extends IndexNames<DealDB, 'deal'>>(idx: I) => (id: string) =>\n  TE.tryCatchK((db: IDBPDatabase<DealDB>) => db.getAllFromIndex('deal', idx, id), (): DbError => \"SelectError\")\n\nexport const getDealsByGenerationId = (generationId: GenerationId) =>\n  pipe(getDb,\n    TE.chain(getByIndex('generation')(generationId)),\n    TE.map(RA.map(row => row.deal)))\n\nexport const getBatchIdsByGenerationId = (generationId: GenerationId) =>\n  pipe(getDb,\n    TE.chain(getByIndex('generation')(generationId)),\n    TE.map(flow(\n      RA.map(row => row.batchId),\n      RA.uniq(string.Eq))))\n\nexport const getDealsByBatchId = (batchId: string) =>\n  pipe(getDb,\n    TE.chain(getByIndex('batch')(batchId)),\n    TE.map(RA.map(row => row.deal)))\n\ninterface DealWithSolution {\n  deal: SerializedDeal\n  solution: O.Option<DoubleDummyTable>\n}\nexport const getDealsWithSolutionsByPath = (generationId: GenerationId, hash: ConstrainedBidPathHash) =>\n  pipe(getDb,\n    TE.chain(db => TE.of(db.transaction(['deal', 'satisfies'], 'readonly'))),\n    TE.bindTo('tran'),\n    TE.bind('satisfiedDeals', ({ tran }) => pipe(\n      TE.tryCatch(() => tran.objectStore('satisfies').get([generationId, hash]), (): DbError => \"SelectError\"),\n      TE.map(flow(\n        O.fromNullable,\n        O.fold(() => [], x => x.deals))))),\n    TE.bind('deals', ({ tran, satisfiedDeals }) => pipe(satisfiedDeals,\n      TE.traverseArray(TE.tryCatchK(key => tran.objectStore('deal').get(key.id), (): DbError => \"SelectError\")),\n      TE.map(flow(\n        RA.map(O.fromNullable),\n        RA.compact,\n        RA.foldMap(RR.getUnionMonoid(semigroup.first<DealWithSolution>()))(row => ({\n          [row.deal.id]: {\n            deal: row.deal,\n            solution: O.fromNullable(row.solution)\n          }\n        })))))),\n    TE.chainFirst(({ tran }) => TE.tryCatch(() => tran.done, (): DbError => \"CommitRejected\")),\n    TE.map(({ deals }): RR.ReadonlyRecord<SerializedDeal[\"id\"], DealWithSolution> => deals))\n\nexport const deleteByGenerationId = (generationId: GenerationId) =>\n  pipe(getDb,\n    TE.chain(db => TE.of(db.transaction(['deal', 'satisfies'], 'readwrite'))),\n    TE.chainFirst(tran => pipe(\n      TE.tryCatch(() => tran.objectStore('deal').index('generation').getAllKeys(generationId), (): DbError => \"SelectError\"),\n      TE.chain(TE.traverseArray(TE.tryCatchK(key => tran.objectStore('deal').delete(key), (): DbError => \"DeleteError\"))))),\n    TE.chainFirst(tran => pipe(\n      TE.tryCatch(() => tran.objectStore('satisfies').index('generation').getAllKeys(generationId), (): DbError => \"SelectError\"),\n      TE.chain(TE.traverseArray(TE.tryCatchK(key => { return tran.objectStore('satisfies').delete(key) }, (): DbError => \"DeleteError\"))))),\n    TE.chain(tran => TE.tryCatch(() => tran.done, (): DbError => \"CommitRejected\")))","/* eslint-disable import/no-webpack-loader-syntax */\n\nimport DDSWorker from 'comlink-loader!./dds.worker'; // inline loader\nimport DealWorker from 'comlink-loader!./deal.worker'; // inline loader\nimport SatisfiesWorker from 'comlink-loader!./satisfies.worker';\nimport { either, readonlyArray as RA, readonlyNonEmptyArray, taskEither } from 'fp-ts';\nimport { observable as Ob, observableEither as ObE } from 'fp-ts-rxjs';\nimport { pipe } from 'fp-ts/lib/function';\nimport { from, groupBy } from 'rxjs';\n\nimport pool from '../lib/pool';\nimport { makeBoard } from '../model/bridge';\nimport { GenerationId, Solution } from '../model/job';\nimport { SerializedBidPath, serializedBidPathL, serializedBoardL, SerializedDeal, serializedDealL } from '../model/serialization';\nimport { Paths } from '../model/system';\nimport { ConstrainedBid } from '../model/system/core';\nimport { getBatchIdsByGenerationId } from '../services/idb';\n\nconst BATCH_SIZE = 500\nexport const observeDeals = (generationId: GenerationId) => (count: number) =>\n  pipe(\n    RA.replicate(count / BATCH_SIZE, BATCH_SIZE),\n    RA.append(count % BATCH_SIZE),\n    pool(() => new DealWorker(), w => b => w.genDeals(b, generationId)))\n\nexport interface SatisfiesBatchResult {\n  satisfiesCount: number\n  testedCount: number\n}\nexport interface SatisfiesResult extends SatisfiesBatchResult {\n  path: SerializedBidPath\n}\nexport const observeSatisfies = (generationId: GenerationId) => (paths: Paths<ConstrainedBid>) =>\n  pipe(generationId,\n    getBatchIdsByGenerationId,\n    ObE.fromTaskEither,\n    ObE.chain(x => ObE.fromObservable(from(x))),\n    ObE.bindTo('batchId'),\n    ObE.bind('path', () => ObE.fromObservable(from(paths))),\n    groupBy(either.isRight),\n    Ob.chain(group =>\n      group.key\n      ? pipe(group, Ob.map(r => r.right),\n          pool(() => new SatisfiesWorker(), w => ({ batchId, path }) =>\n            pipe(\n              () => w.satisfiesBatch(path, batchId, generationId),\n              taskEither.map((result): SatisfiesResult => ({ ...result,\n                path: pipe(path, readonlyNonEmptyArray.map(cb => cb.bid), serializedBidPathL.get),\n              })))\n            ()))\n      : group))\n\nexport const observeSolutions = (deals: ReadonlyArray<SerializedDeal>) =>\n  pipe(deals,\n    RA.mapWithIndex((i, d) => pipe(d,\n      serializedDealL.reverseGet,\n      makeBoard(i),\n      serializedBoardL.get)),\n    pool(() => new DDSWorker(), w => b => w.getResult(b)),\n    ObE.bimap(() => \"\", (x): Solution => ({\n      [x.board.deal.id]: x\n    })))","import { option as O, readonlyArray as RA, readonlyRecord, readonlyTuple } from 'fp-ts';\nimport { observable as Ob, observableEither as ObE, observableOption as ObO } from 'fp-ts-rxjs';\nimport { constVoid, flow, pipe } from 'fp-ts/lib/function';\nimport { castDraft } from 'immer';\nimport { WritableDraft } from 'immer/dist/internal';\nimport memoize from 'proxy-memoize';\nimport { Epic, StateObservable } from 'redux-observable';\nimport { concatWith, EMPTY, Observable, of } from 'rxjs';\n\nimport { AnyAction, createSlice, PayloadAction } from '@reduxjs/toolkit';\n\nimport { RootState } from '../app/store';\nimport { transpose } from '../model/analyze';\nimport { AnalysisId, GenerationId, initJobProgress, Job, JobId, JobType, JobTypeGenerateDeals, JobTypeSatisfies, JobTypeSolve, now, Solution, updateGenerateDealsProgress, updateSatisfiesProgress, updateSolveProgress, zeroJob } from '../model/job';\nimport { SerializedDeal, serializedDealL } from '../model/serialization';\nimport { Paths } from '../model/system';\nimport { ConstrainedBid } from '../model/system/core';\nimport { ping, postDeals, putDeals } from '../services/server';\nimport { observeDeals, observeSatisfies, observeSolutions, SatisfiesResult } from '../workers';\n\nconst name = 'generator'\ninterface State {\n  jobs: ReadonlyArray<Job>\n  completed: ReadonlyArray<Job>\n}\nconst initialState: State = {\n  jobs: [],\n  completed: []\n}\n\ntype InferJobType<T extends JobType[\"type\"]> = Job & { type: JobType & { type: T } }\ninterface ScheduleJobPayload<T extends JobType[\"type\"]> {\n  analysisId: AnalysisId\n  type: T\n  parameter: InferJobType<T>[\"type\"][\"parameter\"]\n  context: InferJobType<T>[\"type\"][\"context\"]\n  estimatedUnitsInitial: number\n}\n\nconst slice = createSlice({\n  name,\n  initialState,\n  reducers: {\n    scheduleJob: <T extends JobType[\"type\"]>(state: WritableDraft<State>, action: PayloadAction<ScheduleJobPayload<T>>) => {\n      state.jobs.push(castDraft(zeroJob(action.payload.analysisId, action.payload.estimatedUnitsInitial, {\n        type: action.payload.type,\n        parameter: action.payload.parameter,\n        context: action.payload.context,\n        progress: O.none\n      } as JobType)))\n    },\n    startJob: (state, action: PayloadAction<{ jobId: JobId, type: JobType[\"type\"] }>) => {\n      const job = state.jobs.find(j => j.id === action.payload.jobId)\n      if (job) {\n        job.type.progress = pipe(action.payload.type, initJobProgress, castDraft)\n        job.startDate = O.some(now())\n        job.running = true\n      }\n    },\n    completeJob: {\n      reducer: (state, action: PayloadAction<void, string, JobId, O.Option<string>>) => {\n        pipe(state.jobs,\n          RA.findIndex(j => j.id === action.meta),\n          O.map(idx => {\n            const job = state.jobs[idx]\n            job.completedDate = O.some(now())\n            job.running = false\n            job.error = action.error\n            state.completed.push(job)\n            state.jobs.splice(idx, 1)\n            return job\n          }))\n      },\n      prepare: (jobId: JobId, error: O.Option<string>) => ({ payload: constVoid(), meta: jobId, error })\n    },\n    removeJob: (state, action: PayloadAction<JobId>) => {\n      pipe(state.jobs,\n        RA.findIndex(j => j.id === action.payload),\n        O.map(idx => state.jobs.splice(idx, 1)))\n      pipe(state.completed,\n        RA.findIndex(j => j.id === action.payload),\n        O.map(idx => state.completed.splice(idx, 1)))\n    },\n    reportDeals: (state, action: PayloadAction<{ jobId: JobId, value: ReadonlyArray<SerializedDeal> }>) => {\n      const jobType = state.jobs.find(j => j.id === action.payload.jobId)?.type as JobTypeGenerateDeals\n      if (jobType) {\n        jobType.progress = pipe(jobType.progress, updateGenerateDealsProgress(action.payload.value))\n      }\n    },\n    reportSatisfies: (state, action: PayloadAction<{ jobId: JobId, value: SatisfiesResult }>) => {\n      const jobType = state.jobs.find(j => j.id === action.payload.jobId)?.type as JobTypeSatisfies\n      if (jobType) {\n        jobType.progress = pipe(jobType.progress, updateSatisfiesProgress(action.payload.value))\n      }\n    },\n    reportSolutions: (state, action: PayloadAction<{ jobId: JobId, value: Solution }>) => {\n      const jobType = state.jobs.find(j => j.id === action.payload.jobId)?.type as JobTypeSolve\n      if (jobType) {\n        jobType.progress = pipe(jobType.progress, updateSolveProgress(action.payload.value))\n      }\n    }\n  }\n})\n\nexport const { scheduleJob, startJob, completeJob, removeJob, reportDeals, reportSatisfies, reportSolutions } = slice.actions\nexport default slice.reducer\n\ninterface JobIndex {\n  state: State\n  jobId: JobId\n}\nexport const selectJobById = memoize((idx: JobIndex) =>\n  pipe(idx.state.jobs,\n    RA.findFirst(j => j.id === idx.jobId)))\n\nconst generateDeals = (jobId: JobId, generationId: GenerationId, count: number) =>\n  pipe(observeDeals(generationId)(count),\n    ObE.map(deals => reportDeals({ jobId, value: deals })),\n    ObE.getOrElse((err): Observable<AnyAction> =>\n      of(completeJob(jobId, O.some(err)))),\n    concatWith([completeJob(jobId, O.none)]))\n\nconst generateSatisfies = (jobId: JobId, generationId: GenerationId, paths: Paths<ConstrainedBid>) =>\n  pipe(observeSatisfies(generationId)(paths),\n    ObE.map(result => reportSatisfies({ jobId, value: result })),\n    ObE.getOrElse((err): Observable<AnyAction> =>\n      of(completeJob(jobId, O.some(err)))),\n    concatWith([completeJob(jobId, O.none)]))\n\nconst generateSolutions = (jobId: JobId, generationId: GenerationId, deals: ReadonlyArray<SerializedDeal>) =>\n  pipe(observeSolutions(deals),\n    ObE.map(result => reportSolutions({ jobId, value: result })),\n    ObE.getOrElse((err): Observable<AnyAction> =>\n      of(completeJob(jobId, O.some(err)))),\n    concatWith([completeJob(jobId, O.none)]))\n\nconst withJobType = <T extends JobType[\"type\"]>(jobType: T) => (action$: Observable<AnyAction>, state$: StateObservable<RootState>) =>\n  action$.pipe(\n    Ob.filter(startJob.match),\n    Ob.map(a => a.payload),\n    Ob.filter((p): p is { jobId: JobId, type: T } => p.type === jobType),\n    Ob.map(p =>\n      pipe(state$.value.generator.jobs,\n        RA.findFirst(j => j.id === p.jobId),\n        O.map(j => j as InferJobType<T>))))\n\nexport const epics : ReadonlyArray<Epic<AnyAction, AnyAction, RootState>> = [\n  flow(withJobType(\"GenerateDeals\"),\n    ObO.fold(() => EMPTY, job => generateDeals(job.id, job.type.context.generationId, job.type.parameter))),\n  flow(withJobType(\"Satisfies\"),\n    ObO.fold(() => EMPTY, job => generateSatisfies(job.id, job.type.context.generationId, job.type.parameter))),\n  flow(withJobType(\"Solve\"),\n    ObO.fold(() => EMPTY, job => generateSolutions(job.id, job.type.context.generationId, job.type.parameter))),\n  flow(Ob.filter(reportDeals.match),\n    Ob.map(a => a.payload.value),\n    ObE.fromObservable,\n    ObE.chainFirst(() => pipe(ping, ObE.fromTaskEither)),\n    ObE.chainFirst(flow(\n      RA.map(serializedDealL.reverseGet),\n      postDeals,\n      ObE.fromTaskEither)),\n    Ob.chain(() => EMPTY)),\n  flow(Ob.filter(reportSolutions.match),\n    Ob.map(a => a.payload.value),\n    ObE.fromObservable,\n    ObE.chainFirst(() => pipe(ping, ObE.fromTaskEither)),\n    ObE.chainFirst(flow(\n      readonlyRecord.toReadonlyArray,\n      RA.map(readonlyTuple.snd),\n      RA.map(result => [serializedDealL.reverseGet(result.board.deal), pipe(result.results, transpose, O.some)] as const),\n      putDeals,\n      ObE.fromTaskEither)),\n    Ob.chain(() => EMPTY))\n]","import * as aq from 'arquero';\nimport { option as O, readonlyArray as RA, readonlyNonEmptyArray as RNEA, readonlyRecord as RR, readonlyTuple, semigroup } from 'fp-ts';\nimport { sequenceT } from 'fp-ts/lib/Apply';\nimport { flow, pipe } from 'fp-ts/lib/function';\nimport * as iso from 'monocle-ts/Iso';\n\nimport { DoubleDummyTable } from '../workers/dds.worker';\nimport { flattenNestedCounts } from './analyze';\nimport { Direction, directions, Strain, strains } from './bridge';\n\nconst SerializedKeyL : iso.Iso<readonly [Direction, Strain], string> = iso.iso(\n  ([d, s]) => d + s,\n  s => [s.charAt(0) as Direction, s.charAt(1) as Strain] as const\n)\n\nconst columns =\n  pipe(\n    sequenceT(RNEA.Apply)(\n      directions,\n      strains),\n    RNEA.map(SerializedKeyL.get))\n    \nconst aggregate = (f: (field: any) => number) => (table: aq.internal.ColumnTable): DoubleDummyTable =>\n  pipe(columns,\n    RNEA.groupBy(c => c),\n    RR.map(c => f(c)),\n    x => table.rollup(x),\n    table => table.object() as RR.ReadonlyRecord<string, number>,\n    RR.toReadonlyArray,\n    RA.map(readonlyTuple.mapFst(SerializedKeyL.reverseGet)),\n    RNEA.fromReadonlyArray,\n    O.fold(() => ({}), flow(\n      RNEA.groupBy(([[_, strain], __]) => strain),\n      RR.map(flow(\n        RNEA.groupBy(([[direction, _], __]) => direction),\n        RR.map(flow(\n          RNEA.head,\n          ([_, agg]) => agg)))))))\n        \nconst toRow = (ddt: DoubleDummyTable) =>\n  pipe(ddt,\n    flattenNestedCounts,\n    RA.map(({ outerKey: direction, innerKey: strain, value: count }) => [`${direction}${strain}`, count] as const),\n    RR.fromFoldable(semigroup.first<number>(), RA.Foldable))\n\nexport interface Stats {\n  count: number\n  average: DoubleDummyTable\n  stdev: DoubleDummyTable\n}\nexport const getStats = flow(\n  RNEA.map(toRow),\n  aq.from,\n  (ct): Stats => ({\n    count: ct.totalRows(),\n    average: pipe(ct, aggregate(aq.op.mean)),\n    stdev: pipe(ct, aggregate(aq.op.stdev))\n  }))","import { option as O, readonlyArray as RA, readonlyNonEmptyArray as RNEA, readonlyRecord as RR, readonlyTuple as RT, taskEither as TE } from 'fp-ts';\nimport { observable as Ob, observableEither } from 'fp-ts-rxjs';\nimport { flow, pipe } from 'fp-ts/lib/function';\nimport { castDraft } from 'immer';\nimport memoize from 'proxy-memoize';\nimport { Epic } from 'redux-observable';\nimport { concatWith, EMPTY, from, of } from 'rxjs';\n\nimport { AnyAction, createSlice, PayloadAction } from '@reduxjs/toolkit';\n\nimport { RootState } from '../app/store';\nimport { assertUnreachable } from '../lib';\nimport { get } from '../lib/object';\nimport { Analysis, AnalysisId, GenerationId, Job, zeroAnalysis, zeroGeneration } from '../model/job';\nimport { getStats } from '../model/stats';\nimport { Paths } from '../model/system';\nimport { ConstrainedBid } from '../model/system/core';\nimport { deleteByGenerationId } from '../services/idb';\nimport { completeJob, removeJob } from './generator';\n\ninterface State {\n  analyses: RR.ReadonlyRecord<AnalysisId, Analysis>\n  selectedAnalysis: O.Option<AnalysisId>\n}\nconst initialState: State = {\n  analyses: {},\n  selectedAnalysis: O.none\n}\n\nconst name = 'profile'\n\nconst slice = createSlice({\n  name,\n  initialState,\n  reducers: {\n    addAnalysis: (state, action: PayloadAction<Paths<ConstrainedBid>>) => {\n      const analysis = pipe(action.payload, zeroAnalysis, castDraft)\n      state.analyses[analysis.id] = analysis\n    },\n    deleteAnalysis: (state, action: PayloadAction<AnalysisId>) => { },\n    removeAnalysis: (state, action: PayloadAction<AnalysisId>) => {\n      delete state.analyses[action.payload]\n    },\n    selectAnalysis: (state, action: PayloadAction<AnalysisId>) => {\n      state.selectedAnalysis = pipe(RR.has(action.payload, state.analyses) ? O.some(action.payload) : O.none)\n    },\n    setAnalysisName: {\n      reducer: (state, action: PayloadAction<string, string, AnalysisId>) => {\n        state.analyses[action.meta].name = action.payload\n      },\n      prepare: (id: AnalysisId, name: string) => ({ payload: name, meta: id })\n    },\n    addJobToAnalysis: (state, action: PayloadAction<Job>) => {\n      const jobType = action.payload.type\n      pipe(state.analyses,\n        RR.lookup(action.payload.analysisId),\n        O.map(analysis => {\n          switch (jobType.type) {\n            case \"GenerateDeals\":\n              return pipe(jobType.progress,\n                O.map(p => analysis.generations.push(pipe(zeroGeneration(jobType.context.generationId, p.value), castDraft))))\n            case \"Satisfies\":\n              return pipe(O.Do,\n                O.apS('progress', jobType.progress),\n                O.apS('generation', pipe(analysis.generations, RA.findFirst(g => g.id === jobType.context.generationId))),\n                O.map(o => o.generation.satisfies = O.some(o.progress.value)))\n            case \"Solve\":\n              return pipe(O.Do,\n                O.apS('progress', jobType.progress),\n                O.apS('generation', pipe(analysis.generations, RA.findFirst(g => g.id === jobType.context.generationId))),\n                O.map(o => pipe(\n                  o.progress.value,\n                  RR.toReadonlyArray,\n                  RNEA.fromReadonlyArray,\n                  O.map(flow(\n                    RNEA.map(flow(RT.snd, get('results'))),\n                    getStats,\n                    stats => {\n                      if (RR.has(jobType.context.bidPath, o.generation.solutionStats)) {\n                        throw new Error(\"Combining stat result sets is not implemented\")\n                      }\n                      o.generation.solutionStats[jobType.context.bidPath] = stats\n                    })))))\n            default:\n              return assertUnreachable(jobType)\n          }\n        }))\n    }\n  }\n})\n\nexport const { addAnalysis, deleteAnalysis, selectAnalysis, setAnalysisName, addJobToAnalysis } = slice.actions\nexport default slice.reducer\n\nexport const epics : ReadonlyArray<Epic<AnyAction, AnyAction, RootState>> = [\n  (action$, state$) =>\n    action$.pipe(\n      Ob.filter(completeJob.match),\n      Ob.filter(a => O.isNone(a.error)),\n      Ob.chain(flow(a => a.meta, jobId =>\n        pipe(state$.value.generator.completed,\n          RA.findFirst(j => j.id === jobId),\n          O.fold(\n            () => EMPTY,\n            j => from([addJobToAnalysis(j), removeJob(jobId)])))))),\n  (action$, state$) =>\n    action$.pipe(\n      Ob.filter(deleteAnalysis.match),\n      Ob.map(a => a.payload),\n      Ob.chain(analysisId =>\n        pipe(state$.value.profile.analyses, RR.lookup(analysisId),\n          O.fold(() => EMPTY, a =>\n            pipe(a.generations, RA.map(g => g.id), TE.traverseArray(deleteByGenerationId), Ob.fromTask)),\n          observableEither.fold(() => EMPTY, x => EMPTY),\n          concatWith(of(slice.actions.removeAnalysis(analysisId))))))\n]\n\nexport const selectAllAnalyses = memoize((state: State) => \n  pipe(state.analyses,\n    RR.toReadonlyArray,\n    RA.map(RT.snd)))\n\nexport const selectSelectedAnalysis = memoize((state: State) => \n  pipe(state.selectedAnalysis,\n    O.chain(id => RR.lookup(id, state.analyses))))\n\ninterface AnalysisIndex {\n  state: State\n  analysisId: AnalysisId\n}\nexport const selectAnalysisById = memoize((idx: AnalysisIndex) => \n  pipe(idx.state.analyses,\n    RR.lookup(idx.analysisId)))\n\ninterface GenerationIndex extends AnalysisIndex {\n  generationId: GenerationId\n}\nexport const selectGenerationByAnalysis = memoize((idx: GenerationIndex) => \n  pipe(selectAnalysisById(idx),\n    O.chain(flow(\n      get(\"generations\"),\n      RA.findFirst(g => g.id === idx.generationId)))))","import { either as E, eq, option as O, readonlyArray as RA, readonlyNonEmptyArray as RNEA, readonlyRecord, readonlyTuple, show, these as TH, tree as T } from 'fp-ts';\nimport { flow, pipe } from 'fp-ts/lib/function';\n\nimport { SyntacticBid } from './system/expander';\n\nexport type Path<A> = RNEA.ReadonlyNonEmptyArray<A>\nexport type Paths<A> = RNEA.ReadonlyNonEmptyArray<Path<A>>\nexport type Forest<A> = ReadonlyArray<T.Tree<A>>\n\nexport const getPathUpTo = <A>(eqA: eq.Eq<A>) => (item: A) =>\n  RA.findFirstMap(\n    T.fold((a: A, paths: ReadonlyArray<O.Option<RNEA.ReadonlyNonEmptyArray<A>>>) : O.Option<RNEA.ReadonlyNonEmptyArray<A>> =>\n      eqA.equals(a, item)\n      ? O.some([item])\n      : pipe(paths,\n          RA.findFirstMap(O.map(RA.prepend(a))))))\n\nexport const flatten = <A>(forest: Forest<A>) =>\n  pipe(forest,\n    RA.chain(\n      T.reduce<A, ReadonlyArray<A>>([], (items, a) =>\n        pipe(items, RA.append(a)))))\n\nexport const getPathForest = <A>(forest: Forest<A>) : Forest<Path<A>> =>\n  pipe(forest,\n    RA.map(flow(\n      T.map(RNEA.of),\n      T.fold((a, forest: ReadonlyArray<T.Tree<Path<A>>>) =>\n        T.make(a, pipe(forest,\n          RA.map(T.map(path => RNEA.concat(path)(a))), RA.toArray))))))\n\nexport const getAllLeafPaths = <A>(forest: Forest<A>): ReadonlyArray<Path<A>> =>\n  pipe(forest,\n    RA.chain(\n      T.fold((node: A, paths: ReadonlyArray<Paths<A>>): Paths<A> =>\n        pipe(paths,\n          RNEA.fromReadonlyArray,\n          O.fold(() => [[node]],\n            RNEA.foldMap(RNEA.getSemigroup<Path<A>>())(RNEA.map(RA.prepend(node))))))),\n    RA.filterMap(RNEA.fromReadonlyArray))\n\nexport const getForestFromLeafPaths = <A, F extends show.Show<A>>(show: F) => (paths: ReadonlyArray<Path<A>>): Forest<A> =>\n  pipe(paths,\n    RNEA.fromReadonlyArray,\n    O.fold(\n      () => RA.empty,\n      flow(\n        RNEA.groupBy(flow(RNEA.head, show.show)),\n        readonlyRecord.toReadonlyArray,\n        RA.map(flow(\n          readonlyTuple.snd,\n          paths => T.make(\n            RNEA.head(RNEA.head(paths)),\n            pipe(paths,\n              RNEA.map(flow(\n                RNEA.tail,\n                RNEA.fromReadonlyArray)),\n              RA.compact,\n              getForestFromLeafPaths(show),\n              RA.toArray)))))))\n\nconst extendTreeWithSiblings = <A>(eqA: eq.Eq<A>) => (siblings: ReadonlyArray<A>) => (t: T.Tree<A>) : T.Tree<A & { siblings: ReadonlyArray<A> }> =>\n  T.make(\n    ({ ...t.value, siblings }),\n    pipe(t.forest, RA.map(u =>\n      pipe(t.forest,\n        RA.map(t => t.value),\n        RA.difference(eqA)([u.value]), // end null hack\n        extendTreeWithSiblings(eqA))(u)),\n      RA.toArray))\n\nexport const extendForestWithSiblings = <A>(eqA: eq.Eq<A>) => (forest: Forest<A>) =>\n  pipe(forest, RA.map(t =>\n    pipe(forest,\n      RA.map(t => t.value),\n      RA.difference(eqA)([t.value]),\n      extendTreeWithSiblings(eqA))(t)))\n\nexport const withImplicitPasses =\n  RA.map(\n    T.fold((a: SyntacticBid, bs: T.Forest<SyntacticBid>) =>\n      bs.length === 0 || pipe(bs, RA.exists(t => t.value.bid === \"Pass\"))\n      ? T.make(a, bs)\n      : T.make(a, pipe(bs,\n        RA.append(T.make<SyntacticBid>({ bid: \"Pass\", syntax: { type: \"Otherwise\" }})),\n        RA.toArray))))\n\nexport type ForestWithErrors<L, R> = TH.These<ReadonlyArray<L>, Forest<R>>\nexport const collectErrors = <L, R>(forest: Forest<E.Either<L, R>>): ForestWithErrors<L, R> =>\n  pipe(forest,\n    RA.map(T.traverse(TH.getApplicative(RA.getMonoid<L>()))(E.mapLeft(RA.of))),\n    RA.sequence(TH.getApplicative(RA.getSemigroup<L>())))\n      \nexport const chainCollectedErrors = <A, B, E>(f: (a: A) => TH.These<ReadonlyArray<E>, B>) => (fa: TH.These<ReadonlyArray<E>, A>) =>\n  TH.getChain(RA.getSemigroup<E>()).chain(fa, f)","import { either as E, eq, monoid, number, option as O, optionT, ord, predicate as P, readonlyArray as RA, readonlyNonEmptyArray as RNEA, readonlyRecord, readonlySet, readonlyTuple, record, state as S, string } from 'fp-ts';\nimport { eqStrict } from 'fp-ts/lib/Eq';\nimport { apply, constant, constFalse, constTrue, flow, pipe } from 'fp-ts/lib/function';\nimport { Lens, Optional } from 'monocle-ts';\n\nimport { assertUnreachable } from '../../lib';\nimport { Bid, ContractBid, isContractBid, ordContractBid } from '../bridge';\nimport { eqRank, eqSuit, groupHandBySuits, Hand, honors, ordRankAscending, Rank, Suit, suits } from '../deck';\nimport { AnyShape, eqShape, getHandShape, getHandSpecificShape, getHcp, SpecificShape } from '../evaluation';\n\nexport interface ConstraintPointRange {\n  type: \"PointRange\"\n  min: number\n  max: number\n}\n\nexport interface ConstraintSuitRange {\n  type: \"SuitRange\"\n  suit: Suit\n  min: number\n  max: number\n}\n\nexport type SuitComparisonOperator = \"<\" | \"<=\" | \"=\" | \">=\" | \">\"\nexport interface ConstraintSuitComparison {\n  type: \"SuitComparison\",\n  left: Suit,\n  right: Suit,\n  op: SuitComparisonOperator\n}\n\nexport interface ConstraintSuitHonors {\n  type: \"SuitHonors\",\n  suit: Suit,\n  honors: ReadonlyArray<Rank>\n}\n\nexport interface ConstraintSuitTop {\n  type: \"SuitTop\",\n  suit: Suit,\n  count: number,\n  minRank: Rank\n}\n\nexport interface ConstraintSuitPrimary {\n  type: \"SuitPrimary\",\n  suit: Suit\n}\nexport interface ConstraintSuitSecondary {\n  type: \"SuitSecondary\",\n  suit: Suit\n}\ntype ConstraintSuitRank = ConstraintSuitPrimary | ConstraintSuitSecondary\n\ninterface ConstraintConstant {\n  type: \"Constant\",\n  value: boolean\n}\nexport const constraintTrue  = constant<Constraint>({ type: \"Constant\", value: true })\nexport const constraintFalse = constant<Constraint>({ type: \"Constant\", value: false })\n\ninterface ConstraintConjunction {\n  type: \"Conjunction\"\n  constraints: RNEA.ReadonlyNonEmptyArray<Constraint>\n}\ninterface ConstraintDisjunction {\n  type: \"Disjunction\"\n  constraints: RNEA.ReadonlyNonEmptyArray<Constraint>\n}\ninterface ConstraintNegation {\n  type: \"Negation\"\n  constraint: Constraint\n}\n\nexport interface ConstraintAnyShape {\n  type: \"AnyShape\"\n  counts: AnyShape\n}\n\nexport interface ConstraintSpecificShape {\n  type: \"SpecificShape\",\n  suits: SpecificShape\n}\n\ninterface ConstraintResponse {\n  type: \"ForceOneRound\" | \"ForceGame\" | \"ForceSlam\"\n}\n\ninterface ConstraintRelayResponse {\n  type: \"Relay\",\n  bid: ContractBid\n}\n\nexport type ConstraintForce =\n    ConstraintResponse\n  | ConstraintRelayResponse\n\nexport type Constraint =\n  | ConstraintConstant\n  | ConstraintConjunction\n  | ConstraintDisjunction\n  | ConstraintNegation\n  | ConstraintPointRange\n  | ConstraintSuitRange\n  | ConstraintSuitComparison\n  | ConstraintSuitRank\n  | ConstraintSuitHonors\n  | ConstraintSuitTop\n  | ConstraintAnyShape\n  | ConstraintSpecificShape\n  | ConstraintForce\n\n  /* eslint-disable @typescript-eslint/no-unused-vars */\nconst predFalse : P.Predicate<Hand> = constFalse\nconst predTrue : P.Predicate<Hand> = constTrue\nconst quantifier = <A>(ps: ReadonlyArray<P.Predicate<A>>) => (m: monoid.Monoid<P.Predicate<A>>) => \n  RA.foldMap(m)((x: P.Predicate<A>) => x)(ps)\nexport const exists = <A>(ps: ReadonlyArray<P.Predicate<A>>) => pipe(ps, quantifier, apply(P.getMonoidAny<A>()))\nexport const forall = <A>(ps: ReadonlyArray<P.Predicate<A>>) => pipe(ps, quantifier, apply(P.getMonoidAll<A>()))\n// const forall = <A>() => pipe(P.getMonoidAll<A>(), RA.foldMap, apply(identity))\n/* eslint-enable @typescript-eslint/no-unused-vars */\n\ninterface Range {\n  min: number\n  max: number\n}\n\nconst rangeCheck = (range: Range) =>\n  ord.between(number.Ord)(range.min, range.max)\n\nconst isPointRange =\n  flow(rangeCheck, P.contramap(getHcp))\n\nconst isSpecificShape = (shape: SpecificShape) =>\n  flow(getHandSpecificShape, suits => record.getEq(eqStrict).equals(suits, shape))\n\nconst isSuitRange = (range: Range) => (suit: Suit) =>\n  flow(getHandSpecificShape, shape =>\n    pipe(range, rangeCheck, apply(shape[suit])))\n\nconst getComparator = (op: SuitComparisonOperator) => {\n  switch (op) {\n    case \"<\" : return ord.lt(number.Ord)\n    case \"<=\": return ord.leq(number.Ord)\n    case \"=\" : return number.Eq.equals\n    case \">=\": return ord.geq(number.Ord)\n    case \">\" : return ord.gt(number.Ord)\n    default  : return assertUnreachable(op)\n  }\n}\n\nconst suitCompare = (op: SuitComparisonOperator) => (left: Suit, right: Suit) =>\n  flow(getHandSpecificShape,\n    shape => getComparator(op)(shape[left], shape[right]))\n\nconst suitPrimary = (suit: Suit) =>\n  pipe(suits,\n    RA.splitAt(suits.indexOf(suit)),\n    readonlyTuple.bimap(\n      flow(RA.tail,\n        O.fold(() => [],\n          RA.map(higher => suitCompare(\"<\")(higher, suit)))),\n      RA.map(lower => suitCompare(\"<=\")(lower, suit))),\n    RA.flatten,\n    RA.prepend(isSuitRange({ min: 5, max: 13 })(suit)),\n    forall)\n\nconst suitSecondary = (secondarySuit: Suit) => (primarySuit: Suit) =>\n  pipe(RA.Do,\n    RA.apS('suit', [secondarySuit, primarySuit]),\n    RA.apS('otherSuit', pipe(suits, RA.difference(eqSuit)([secondarySuit, primarySuit]))),\n    RA.filter(({ suit, otherSuit }) => !eqSuit.equals(suit, otherSuit)),\n    RA.map(({ suit, otherSuit }) => suitCompare(\">\")(suit, otherSuit)),\n    RA.concat([\n      isSuitRange({ min: 5, max: 13 })(secondarySuit),\n      suitCompare(\">=\")(primarySuit, secondarySuit)\n    ]),\n    forall)\n\nconst toRankSet = readonlySet.fromReadonlyArray(eqRank)\n\nconst suitHonors = (suitHonors: ConstraintSuitHonors) =>\n  flow(\n    groupHandBySuits,\n    readonlyRecord.lookup(suitHonors.suit),\n    O.fold(constFalse, cards => {\n      const cardSet = pipe(cards,\n        toRankSet,\n        readonlySet.intersection(eqRank)(toRankSet(honors)))\n      const honorSet = pipe(suitHonors.honors, toRankSet)\n      return pipe(honorSet, readonlySet.isSubset(eqRank)(cardSet))\n    }))\n\nconst suitTop = (suitTop: ConstraintSuitTop) =>\n  flow(groupHandBySuits,\n    readonlyRecord.lookup(suitTop.suit),\n    O.fold(constFalse, flow(\n      RA.filter(r => ordRankAscending.compare(r, suitTop.minRank) >= 0),\n      cards => cards.length >= suitTop.count)))\n\nconst isShape = (shape: AnyShape) =>\n  flow(getHandShape, handShape =>\n    eqShape.equals(shape, handShape))\n\nconst contextualConstraintTypes = [\n  \"Conjunction\",\n  \"Disjunction\",\n  \"Negation\",\n  \"ForceOneRound\",\n  \"ForceGame\",\n  \"ForceSlam\",\n  \"Relay\",\n  \"SuitPrimary\",\n  \"SuitSecondary\",\n] as const\n\ntype ContextualConstraintType = typeof contextualConstraintTypes[number]\ntype BasicConstraint = Exclude<Constraint, { type: ContextualConstraintType }>\ntype ContextualConstraint = Extract<Constraint, { type: ContextualConstraintType }>\n\nconst isContextualConstraint = (c: Constraint) : c is ContextualConstraint =>\n  RA.elem(string.Eq as eq.Eq<Constraint[\"type\"]>)(c.type)(contextualConstraintTypes)\n\nconst separate = (c: Constraint) : E.Either<ContextualConstraint, BasicConstraint> =>\n  isContextualConstraint(c) ? E.left(c) : E.right(c as BasicConstraint)\n    \nconst satisfiesBasic = (c: BasicConstraint): P.Predicate<Hand> => {\n  switch (c.type) {\n    case \"Constant\":\n      return constant(c.value)\n    case \"PointRange\":\n      return isPointRange(c)\n    case \"SuitRange\":\n      return isSuitRange(c)(c.suit)\n    case \"SuitComparison\":\n      return suitCompare(c.op)(c.left, c.right)\n    case \"SuitHonors\":\n      return suitHonors(c)\n    case \"SuitTop\":\n      return suitTop(c)\n    case \"AnyShape\":\n      return isShape(c.counts)\n    case \"SpecificShape\":\n      return isSpecificShape(c.suits)\n    default:\n      return assertUnreachable(c)\n  }\n}\n\nexport interface ConstrainedBid {\n  bid: Bid\n  constraint: Constraint\n}\nconst ordBid: ord.Ord<Bid> =\n  ord.fromCompare((a, b) =>\n    isContractBid(a) && !isContractBid(b) ? -1 :\n    isContractBid(b) && !isContractBid(a) ? 1 :\n    isContractBid(a) && isContractBid(b) ? ordContractBid.compare(a, b) :\n    0)\nexport const ordConstrainedBid = ord.contramap<Bid, ConstrainedBid>(b => b.bid)(ordBid)\nexport interface BidContext {\n  bid: Bid,\n  path: ReadonlyArray<Bid>\n  force: O.Option<ConstraintForce>\n  primarySuit: O.Option<Suit>\n  secondarySuit: O.Option<Suit>,\n}\nexport const zeroContext : BidContext = {\n  bid: {} as Bid,\n  path: [],\n  force: O.none,\n  primarySuit: O.none,\n  secondarySuit: O.none\n}\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\nexport const contextL = Lens.fromProp<BidContext>()\nexport const bidL = contextL('bid')\nexport const pathL = contextL('path')\nexport const forceL = contextL('force')\nexport const primarySuitL = contextL('primarySuit')\nexport const secondarySuitL = contextL('secondarySuit')\nexport const contextO = Optional.fromOptionProp<BidContext>()\nexport const forceO = contextO('force')\nexport const primarySuitO = contextO('primarySuit')\nexport const secondarySuitO = contextO('secondarySuit')\n\nexport type ConstraintS<X, C> = S.State<X, C>\nexport type SatisfiesS<X, C, A> = (c: ConstraintS<X, C>) => S.State<X, P.Predicate<A>>\nconst quantifierS = <A>(quantifier: (c: ReadonlyArray<P.Predicate<A>>) => P.Predicate<A>) => <X, C>(satisfies: SatisfiesS<X, C, A>) =>\n  flow(\n    S.traverseArray(satisfies),\n    S.map(quantifier))\nconst existsS = <X, C, A>(satisfies: SatisfiesS<X, C, A>) => quantifierS<A>(exists)(satisfies)\nconst forallS = <X, C, A>(satisfies: SatisfiesS<X, C, A>) => quantifierS<A>(forall)(satisfies)\n\nexport const ofS = <A>(x: A) => S.of<BidContext, A>(x)\n\nconst satisfiesContextual = (recur: SatisfiesS<BidContext, Constraint, Hand>) : SatisfiesS<BidContext, ContextualConstraint, Hand> =>\n  S.chain(c => {\n    switch (c.type) {\n      case \"Conjunction\":\n        return pipe(c.constraints, RNEA.map(ofS), forallS(recur))\n      case \"Disjunction\":\n        return pipe(c.constraints, RNEA.map(ofS), existsS(recur))\n      case \"Negation\": \n        return pipe(c.constraint, ofS, recur, S.map(P.not))\n        \n      case \"ForceOneRound\":\n      case \"ForceGame\":\n      case \"ForceSlam\":\n      case \"Relay\":\n        return pipe(\n          S.modify<BidContext>(forceL.set(O.some(c))),\n          S.map(() => constTrue))\n\n      case \"SuitPrimary\":\n        return pipe(\n          S.modify<BidContext>(primarySuitL.set(O.some(c.suit))),\n          S.map(() => suitPrimary(c.suit)))\n      case \"SuitSecondary\":\n        return pipe(\n          S.modify<BidContext>(secondarySuitL.set(O.some(c.suit))),\n          S.chain(() => S.gets(context => context.primarySuit)),\n          optionT.map(S.Functor)(suitSecondary(c.suit)),\n          S.map(O.getOrElseW(() => predFalse)))\n        \n      default:\n        return assertUnreachable(c)\n    }\n  })\n\nexport const satisfiesS : SatisfiesS<BidContext, Constraint, Hand> = s =>\n  pipe(s,\n    S.map(separate),\n    S.chain(E.fold(\n      flow(S.of, satisfiesContextual(satisfiesS)),\n      flow(S.flap, f => f(ofS(satisfiesBasic))))))\n\nconst satisfiesWithContext = (x: Constraint) =>\n  pipe(x, S.of, satisfiesS)\n  \nexport const satisfies =\n  flow(satisfiesWithContext, S.evaluate(zeroContext))\n\n","import { either as E, eitherT, eq, option as O, optionT, readonlyArray as RA, readonlyMap as RM, readonlyNonEmptyArray as RNEA, separated, state as S, string, these, tree as T } from 'fp-ts';\nimport { constant, constVoid, flow, pipe } from 'fp-ts/lib/function';\nimport { Lens } from 'monocle-ts';\nimport { Object } from 'ts-toolbelt';\n\nimport { assertUnreachable } from '../../lib';\nimport { Bid, ContractBid, eqBid, isContractBid } from '../bridge';\nimport { Suit, suits } from '../deck';\nimport { AnyShape, makeShape } from '../evaluation';\nimport { serializedBidL } from '../serialization';\nimport { collectErrors, extendForestWithSiblings, Forest } from '../system';\nimport { ConstrainedBid, Constraint, ConstraintSuitComparison, ConstraintSuitHonors, ConstraintSuitPrimary, ConstraintSuitRange, ConstraintSuitSecondary, ConstraintSuitTop, constraintTrue } from './core';\n\nexport const ofS = <A>(x: A) => S.of<ExpandContext, A>(x)\n\nexport type SuitContextSpecifier = \"Wildcard\" | \"Major\" | \"Minor\" | \"OtherMajor\" | \"OtherMinor\"\nexport type SuitSpecifier = SuitContextSpecifier | Suit\nconst isSuit = (s: string): s is Suit =>\n  pipe(suits, RA.elem(string.Eq)(s))\ntype ContextualSuitSyntax<T extends Constraint> = Object.Replace<T, Suit, SuitSpecifier>\ntype SyntaxSuitRange = ContextualSuitSyntax<ConstraintSuitRange>\ntype SyntaxSuitComparison = ContextualSuitSyntax<ConstraintSuitComparison>\ntype SyntaxSuitHonors = ContextualSuitSyntax<ConstraintSuitHonors>\ntype SyntaxSuitTop = ContextualSuitSyntax<ConstraintSuitTop>\ntype SyntaxSuitPrimary = ContextualSuitSyntax<ConstraintSuitPrimary>\ntype SyntaxSuitSecondary = ContextualSuitSyntax<ConstraintSuitSecondary>\ntype SyntaxSuit = \n  | SyntaxSuitRange\n  | SyntaxSuitComparison\n  | SyntaxSuitHonors\n  | SyntaxSuitTop\n  | SyntaxSuitPrimary\n  | SyntaxSuitSecondary\n\ninterface SyntaxDistribution {\n  type: \"Balanced\" | \"SemiBalanced\" | \"Unbalanced\"\n}\n\ninterface SyntaxLabelDef {\n  type: \"LabelDef\"\n  name: string\n  definition: Syntax\n}\nconst labelDef = (s: SyntaxLabelDef) =>\n  pipe(\n    S.gets(flow(\n      labelsL.get,\n      RM.lookup(string.Eq)(s.name))),\n    S.chain(O.fold(\n      () => ofS(s.definition),\n      c0 => ofS({ type: \"Conjunction\", syntax: [c0, s.definition] } as const))),\n    S.chainFirst(syntax => S.modify(labelsL.modify(RM.upsertAt(string.Eq)(s.name, syntax)))),\n    S.map(flow(E.right, E.right)))\n\ninterface SyntaxLabelRef {\n  type: \"LabelRef\"\n  name: string\n}\nconst labelRef = (s: SyntaxLabelRef) =>\n  pipe(\n    S.gets(flow(\n      labelsL.get,\n      RM.lookup(string.Eq)(s.name))),\n    S.map(flow(\n      E.fromOption((): ExpandErrorReason => \"LabelNotFound\"),\n      E.map(E.right))))\n\ninterface SyntaxWrapper {\n  type: \"Wrapper\"\n  constraint: Constraint\n}\nexport const wrap = (constraint: Constraint): SyntaxWrapper => ({\n  type: \"Wrapper\",\n  constraint\n})\n\ninterface SyntaxConstant {\n  type: \"Constant\",\n  value: boolean\n}\nexport const syntaxTrue  = constant<Syntax>({ type: \"Constant\", value: true })\nexport const syntaxFalse = constant<Syntax>({ type: \"Constant\", value: false })\n\ninterface SyntaxConjunction {\n  type: \"Conjunction\"\n  syntax: RNEA.ReadonlyNonEmptyArray<Syntax>\n}\ninterface SyntaxDisjunction {\n  type: \"Disjunction\"\n  syntax: RNEA.ReadonlyNonEmptyArray<Syntax>\n}\ninterface SyntaxNegation {\n  type: \"Negation\"\n  syntax: Syntax\n}\ntype SyntaxConnective =\n  | SyntaxConjunction\n  | SyntaxDisjunction\n\nconst connective = ({ type, syntax }: SyntaxConnective): S.State<ExpandContext, E.Either<ExpandErrorReason, E.Either<Constraint, Syntax>>> =>\n  pipe(syntax,\n    RNEA.traverse(S.Applicative)(expandOnce),\n    S.map(flow(\n      RA.wilt(E.Applicative)(x => x),\n      E.map(flow(\n        separated.bimap(RNEA.fromReadonlyArray, RNEA.fromReadonlyArray),\n        x => these.fromOptions(x.left, x.right),\n        O.fold(\n          () => E.left(type === \"Conjunction\" ? constraintTrue() : constraintTrue()),\n          these.match(\n            constraints => E.left(constraints.length === 1 ? constraints[0] : { type, constraints }),\n            syntax => E.right(syntax.length === 1 ? syntax[0] : { type, syntax }),\n            (constraints, syntax): E.Either<never, Syntax> => E.right(\n              { type: type,\n                syntax: [wrap({ type, constraints }), { type, syntax }]\n              }))))))))\n\ntype ExpandResult = E.Either<ExpandError, ConstrainedBid>\ninterface ExpandContext {\n  bid: Bid\n  pathReversed: ReadonlyArray<Bid>\n  siblings: ReadonlyArray<SyntacticBid>\n  traversed: ReadonlyArray<ExpandResult>\n  labels: ReadonlyMap<string, Syntax>\n}\nconst zeroContext: ExpandContext = {\n  bid: \"Pass\",\n  pathReversed: [],\n  siblings: RA.empty,\n  traversed: RA.empty,\n  labels: RM.empty\n}\n\nconst contextL = Lens.fromProp<ExpandContext>()\nconst bidL = contextL('bid')\nconst pathReversedL = contextL('pathReversed')\nconst siblingsL = contextL('siblings')\nconst traversedL = contextL('traversed')\nconst labelsL = contextL('labels')\n\ninterface SyntaxOtherBid {\n  type: \"OtherBid\",\n  bid: ContractBid\n}\nconst eqSyntacticBid = pipe(eqBid, eq.contramap((sb: SyntacticBid) => sb.bid));\n\nconst otherBid = (bid: Bid) =>\n  pipe(\n    S.gets(flow(\n      siblingsL.get,\n      RA.findFirst(sb => eqBid.equals(sb.bid, bid)),\n      O.map(sb => sb.syntax))),\n    optionT.alt(S.Monad)(() => S.gets(flow(\n      labelsL.get,\n      RM.lookup(string.Eq)(serializedBidL.get(bid))))),\n    S.map(flow(\n      E.fromOption((): ExpandErrorReason => \"OtherBidNotFound\"),\n      E.map(E.right))))\n\ninterface SyntaxOtherwise {\n  type: \"Otherwise\"\n}\nconst otherwise = pipe(\n  S.gets(bidL.get),\n  S.chain(bid => S.gets(flow(\n    traversedL.get,\n    RA.rights,\n    RA.takeLeftWhile(cb => !eqBid.equals(cb.bid, bid)),\n    RA.map(cb => cb.constraint)))),\n  S.map(flow(\n    RNEA.fromReadonlyArray,\n    O.fold(\n      constraintTrue,\n      (constraints): Constraint => ({\n        type: \"Negation\", constraint: {\n          type: \"Conjunction\", constraints\n        }\n      })),\n    E.left,\n    E.right)))\n\nexport type Syntax =\n  | SyntaxWrapper\n  | SyntaxConstant\n  | SyntaxConjunction\n  | SyntaxDisjunction\n  | SyntaxDistribution\n  | SyntaxNegation\n  | SyntaxSuit\n  | SyntaxLabelDef\n  | SyntaxLabelRef\n  | SyntaxOtherBid\n  | SyntaxOtherwise\n\nconst wrapShapes =\n  RNEA.map((counts: AnyShape): Syntax =>\n    wrap({ type: \"AnyShape\", counts }))\n\nconst syntaxBalanced : Syntax = {\n  type: \"Disjunction\",\n  syntax: wrapShapes([\n    makeShape(4, 3, 3, 3),\n    makeShape(5, 3, 3, 2),\n    makeShape(4, 4, 3, 2)\n  ])\n}\n\nconst syntaxSemiBalanced : Syntax = {\n  type: \"Disjunction\",\n  syntax: wrapShapes([\n    makeShape(5, 4, 2, 2),\n    makeShape(6, 3, 2, 2)\n  ])\n}\n\nconst expandSpecifier = (specifier: SuitSpecifier): S.State<ExpandContext, E.Either<ExpandErrorReason, Suit>> => {\n  switch (specifier) {\n    case \"C\":\n    case \"D\":\n    case \"H\":\n    case \"S\":\n      return ofS(E.right(specifier))\n    case \"Wildcard\":\n      return pipe(\n        S.gets(flow(bidL.get)),\n        S.map(flow(\n          E.fromPredicate(isContractBid, (b): ExpandErrorReason => \"WildcardWithoutBid\"),\n          E.chain(b => pipe(b.strain, E.fromPredicate(isSuit, (b): ExpandErrorReason => \"WildcardInNTContext\"))))))\n    default:\n      return ofS(E.left(\"NotImplemented\"));\n  }\n}\n\nexport type ExpandErrorReason =\n  | \"NotImplemented\"\n  | \"OtherBidNotFound\"\n  | \"LabelNotFound\"\n  | \"WildcardWithoutBid\"\n  | \"WildcardInNTContext\"\n\nexport interface ExpandError {\n  reason: ExpandErrorReason\n  syntax: Syntax\n  path: ReadonlyArray<Bid>\n}\n\nexport const pure = <A>(x: A) => pipe(x, E.right, E.right, ofS)\n\nconst expandOnce = (s: Syntax): S.State<ExpandContext, E.Either<ExpandErrorReason, E.Either<Constraint, Syntax>>> => {\n  switch (s.type) {\n    case \"Wrapper\":\n      return ofS<E.Either<ExpandErrorReason, E.Either<Constraint, Syntax>>>(E.right(E.left(s.constraint)))\n    case \"Constant\":\n      return pure(wrap({ type: \"Constant\", value: s.value }))\n    case \"Conjunction\":\n    case \"Disjunction\":\n      return connective(s)\n    case \"Negation\": \n      return pipe(s.syntax, expandOnce, S.map(E.map(flow(\n        E.bimap(\n          (constraint) => ({ type: \"Negation\", constraint }),\n          (syntax) => ({ type: \"Negation\", syntax }))))))\n    case \"OtherBid\":\n      return otherBid(s.bid)\n    case \"Otherwise\":\n      return otherwise\n    case \"LabelDef\":\n      return labelDef(s)\n    case \"LabelRef\":\n      return labelRef(s)\n    case \"Balanced\":\n      return pure(syntaxBalanced)\n    case \"SemiBalanced\":\n      return pure({ type: \"Disjunction\", syntax: [syntaxBalanced, syntaxSemiBalanced] })\n    case \"Unbalanced\":\n      return pure({ type: \"Negation\", syntax: {\n        type: \"Disjunction\", syntax: [syntaxBalanced, syntaxSemiBalanced]\n      }})\n    case \"SuitRange\":\n    case \"SuitHonors\":\n    case \"SuitPrimary\":\n    case \"SuitSecondary\":\n    case \"SuitTop\":\n      return pipe(s.suit,\n        expandSpecifier,\n        eitherT.map(S.Functor)(suit => E.left({ ...s, suit })))\n    case \"SuitComparison\":\n      return pipe([s.left, s.right],\n        S.traverseArray(expandSpecifier),\n        S.map(E.sequenceArray),\n        eitherT.map(S.Functor)(suits => E.left({ ...s, left: suits[0], right: suits[1] })))\n          \n    default:\n      // return ofS(E.right(E.right(syntaxFalse())))\n      return assertUnreachable(s)\n  }\n}\n\nconst expand = (syntax: Syntax) : S.State<ExpandContext, E.Either<ExpandErrorReason, Constraint>> =>\n  pipe(\n    syntax,\n    expandOnce,\n    S.chain(flow(\n      E.mapLeft(E.left),\n      E.chain(flow(E.mapLeft(c => E.right(c)))),\n      E.fold(ofS, expand))))\n\nexport type SyntacticBid = {\n  bid: Bid\n  syntax: Syntax\n}\n\nconst modifyContext = <T>(...modifiers: ReadonlyArray<(c: T) => T>) =>\n  pipe(modifiers, S.traverseArray(S.modify), S.map(constVoid))\n\nconst expandBid = \n  T.map(({ bid, syntax, siblings }: SyntacticBid & { siblings : ReadonlyArray<SyntacticBid> }) =>\n    pipe(\n      modifyContext(\n        bidL.set(bid),\n        pathReversedL.modify(RA.prepend(bid)),\n        siblingsL.set(siblings),\n        labelsL.modify(RM.upsertAt(string.Eq)(serializedBidL.get(bid), syntax)),\n      ),\n      S.apSecond(expand(syntax)),\n      S.chain(e => pipe(\n        S.gets(pathReversedL.get),\n        S.map(path => pipe(e, E.mapLeft((reason): ExpandError => ({ reason, path: RA.reverse(path), syntax })))))),\n      S.map(E.map((constraint): ConstrainedBid => ({ bid, constraint })))))\n\nconst traversePeers =\n  S.chainFirst((t: T.Tree<ExpandResult>) =>\n    modifyContext(\n      traversedL.modify(RA.append(t.value)),\n      pathReversedL.modify(flow(RA.tail, O.getOrElseW(() => RA.empty)))))\n\ntype ExpandedBid = S.State<ExpandContext, ExpandResult>\nconst expandPeers =\n  T.fold((expandedBid: ExpandedBid, expandedChildForest: ReadonlyArray<S.State<ExpandContext, T.Tree<ExpandResult>>>) => \n    pipe(expandedBid,\n      S.bindTo('result'),\n      S.apS('context', S.get()),\n      S.map(({ result, context }) =>\n        T.make(result,\n          pipe(expandedChildForest,\n            S.traverseArray(traversePeers),\n            S.evaluate(context),\n            RA.toArray)))))\n\nexport const expandForest = (forest: Forest<SyntacticBid>) =>\n  pipe(forest,\n    extendForestWithSiblings(eqSyntacticBid),\n    RA.map(flow(expandBid, expandPeers)),\n    S.traverseArray(traversePeers),\n    S.evaluate(zeroContext),\n    collectErrors)","import { boolean, either as E, eitherT, number, option as O, optionT, ord, readonlyArray as RA, readonlyNonEmptyArray as RNEA, readonlyRecord, state as S } from 'fp-ts';\nimport { apply, constVoid, flow, identity, pipe } from 'fp-ts/lib/function';\n\nimport { assertUnreachable } from '../../lib';\nimport { Bid, isGameLevel, isSlamLevel } from '../bridge';\nimport { Forest, getAllLeafPaths, Path } from '../system';\nimport {\n    BidContext, bidL, ConstrainedBid, Constraint, ConstraintAnyShape, ConstraintForce, ConstraintPointRange, ConstraintS, ConstraintSpecificShape, ConstraintSuitPrimary, ConstraintSuitRange, ConstraintSuitSecondary, forceL, forceO, ofS, ordConstrainedBid, pathL, primarySuitL, secondarySuitL,\n    zeroContext\n} from './core';\n\ninterface SystemValidationErrorBidsOutOfOrder {\n  type: \"BidsOutOfOrder\"\n  left: ConstrainedBid\n  right: ConstrainedBid\n}\ninterface SystemValidationErrorNoPrimarySuitDefined {\n  type: \"NoPrimarySuitDefined\"\n  constraint: ConstraintSuitSecondary\n}\ninterface SystemValidationErrorPrimarySuitAlreadyDefined {\n  type: \"PrimarySuitAlreadyDefined\"\n  constraint: ConstraintSuitPrimary\n}\ninterface SystemValidationErrorSamePrimaryAndSecondarySuit {\n  type: \"SamePrimaryAndSecondarySuit\"\n  constraint: ConstraintSuitSecondary\n}\ninterface SystemValidationErrorSuitRangeInvalid {\n  type: \"SuitRangeInvalid\",\n  constraint: ConstraintSuitRange\n}\ninterface SystemValidationErrorPointRangeInvalid {\n  type: \"PointRangeInvalid\",\n  constraint: ConstraintPointRange\n}\ninterface SystemValidationErrorSpecificShapeInvalid {\n  type: \"SpecificShapeInvalid\",\n  constraint: ConstraintSpecificShape\n}\n\ninterface SystemValidationErrorAnyShapeInvalid {\n  type: \"AnyShapeInvalid\",\n  constraint: ConstraintAnyShape\n}\ninterface SystemValidationErrorPassWhileForcing {\n  type: \"PassWhileForcing\",\n  bid: Bid\n}\ninterface SystemValidationErrorNoBidDefinedButStillForcing {\n  type: \"NoBidDefinedButStillForcing\",\n  path: ReadonlyArray<Bid>\n}\n\ntype SystemValidationBidReason =\n  | SystemValidationErrorNoPrimarySuitDefined\n  | SystemValidationErrorPrimarySuitAlreadyDefined\n  | SystemValidationErrorSamePrimaryAndSecondarySuit\n  | SystemValidationErrorSuitRangeInvalid\n  | SystemValidationErrorPointRangeInvalid\n  | SystemValidationErrorSpecificShapeInvalid\n  | SystemValidationErrorAnyShapeInvalid\ntype SystemValidationBidError = SystemValidationBidReason & {\n  bid: Bid\n}\n\nexport type SystemValidationError =\n  ( SystemValidationBidError\n  | SystemValidationErrorBidsOutOfOrder\n  | SystemValidationErrorPassWhileForcing\n  | SystemValidationErrorNoBidDefinedButStillForcing)\n  & { path: ReadonlyArray<Bid> }\n\ntype SystemValidation = E.Either<SystemValidationError, void>\ntype ValidateResult = S.State<BidContext, SystemValidation>\n\nconst bidPathSorted = (path: Path<ConstrainedBid>): SystemValidation =>\n  pipe(path,\n    RA.zip(RNEA.tail(path)),\n    RA.traverse(E.Applicative)(([left, right]) =>\n      !ord.lt(ordConstrainedBid)(left, right)\n      ? E.left({ type: \"BidsOutOfOrder\" as const, left, right, path: pipe(path, RA.map(cb => cb.bid)) })\n      : E.right(constVoid())),\n    E.map(constVoid))\n\nconst forestSorted = (tree: Forest<ConstrainedBid>) =>\n  // The sibling nodes do NOT need to be sorted\n  pipe(tree,\n    getAllLeafPaths,\n    RA.traverse(E.Applicative)(bidPathSorted),\n    E.map(constVoid))\n\nexport type ValidateS<X, C, E, A> = (c: ConstraintS<X, C>) => S.State<X, E.Either<E, A>>\n\nexport const validateS = (c: Constraint): S.State<BidContext, E.Either<SystemValidationBidReason, void>> => {\n  switch (c.type) {\n    case \"Conjunction\":\n    case \"Disjunction\":\n      return pipe(c.constraints,\n        S.traverseArray(validateS),\n        S.map(flow(\n          RA.sequence(E.Applicative),\n          E.map(constVoid))))\n    case \"Negation\": \n      return pipe(c.constraint, validateS)\n    \n    case \"ForceOneRound\":\n    case \"ForceGame\":\n    case \"ForceSlam\":\n    case \"Relay\":\n      return pipe(\n        S.modify(forceL.set(O.some(c))),\n        S.map(() => E.right(constVoid())))\n\n    case \"SuitPrimary\":\n      return pipe(\n        S.gets(primarySuitL.get),\n        S.chain(O.fold(\n          () => pipe(\n            S.modify(primarySuitL.set(O.some(c.suit))),\n            S.map(() => E.right(constVoid()))),\n          () => ofS(E.left({ type: \"PrimarySuitAlreadyDefined\", constraint: c })))))\n    case \"SuitSecondary\":\n      return pipe(\n        S.modify(secondarySuitL.set(O.some(c.suit))),\n        S.chain(() => S.gets(context => context.primarySuit)),\n        S.map(flow(\n          E.fromOption((): SystemValidationBidReason => ({ type: \"NoPrimarySuitDefined\", constraint: c })),\n          E.chainFirst(E.fromPredicate(suit => c.suit !== suit, (): SystemValidationBidReason => ({ type: \"SamePrimaryAndSecondarySuit\", constraint: c }))),\n          E.map(constVoid))))\n\n    case \"PointRange\":\n      return pipe(c,\n        E.fromPredicate(c => c.min <= c.max,\n          (): SystemValidationBidReason => ({ type: \"PointRangeInvalid\", constraint: c })),\n        E.map(constVoid),\n        ofS)\n    case \"SuitRange\":\n      return pipe(c,\n        E.fromPredicate(c => c.min <= c.max,\n          (): SystemValidationBidReason => ({ type: \"SuitRangeInvalid\", constraint: c })),\n        E.map(constVoid),\n        ofS)\n        \n    case \"SpecificShape\":\n      return pipe(c.suits,\n        readonlyRecord.foldMap(ord.trivial)(number.MonoidSum)(identity),\n        E.fromPredicate(n => n === 13,\n          (): SystemValidationBidReason => ({ type: \"SpecificShapeInvalid\", constraint: c })),\n        E.map(constVoid),\n        ofS)\n        case \"AnyShape\":\n      return pipe(c.counts,\n        RA.foldMap(number.MonoidSum)(identity),\n        E.fromPredicate(n => n === 13,\n          (): SystemValidationBidReason => ({ type: \"AnyShapeInvalid\", constraint: c })),\n        E.map(constVoid),\n        ofS)\n\n    case \"Constant\":\n    case \"SuitComparison\":\n    case \"SuitHonors\":\n    case \"SuitTop\":\n      return ofS(E.right(constVoid()))\n        \n    default:\n      return assertUnreachable(c)\n  }\n}  \n\nconst resetForce = S.modify(forceL.set(O.none))\nconst continueForce: typeof resetForce = S.of(constVoid())\nconst updateForce = (bid: Bid) => (force: ConstraintForce) => {\n  switch (force.type) {\n    case \"ForceOneRound\":\n    case \"Relay\":\n      return resetForce\n    case \"ForceGame\":\n      return isGameLevel(bid) ? resetForce : continueForce\n    case \"ForceSlam\":\n      return isSlamLevel(bid) ? resetForce : continueForce\n    default:\n      return assertUnreachable(force)\n  }\n}\n\nconst updateForceS : S.State<BidContext, void> =\n  pipe(\n    updateForce, ofS,\n    S.ap(S.gets(bidL.get)),\n    S.map(O.of),\n    optionT.ap(S.Apply)(S.gets(forceL.get)),\n    S.chain(O.sequence(S.Applicative)),\n    S.map(constVoid))\n\nconst checkPass = (bid: Bid) => (force: O.Option<ConstraintForce>) =>\n  !(bid === \"Pass\" && O.isSome(force))\n\nconst checkPassS : ValidateResult =\n  pipe(\n    ofS(checkPass),\n    S.ap(S.gets(bidL.get)),\n    S.ap(S.gets(forceO.getOption)),\n    S.chain(boolean.fold(\n      flow(() => ofS({}),\n        S.apS('bid', S.gets(bidL.get)),\n        S.apS('path', S.gets(pathL.get)),\n        S.map(({ bid, path }) =>\n        E.left({ type: \"PassWhileForcing\" as const, bid, path }))),\n      flow(constVoid, E.right, ofS))))\n      \n\nconst checkFinal : ValidateResult =\n  pipe(\n    S.gets(forceO.getOption),\n    S.bindTo('force'),  \n    S.apS('path', S.gets(pathL.get)),\n    S.map(({ force, path }) => pipe(force,\n      E.fromPredicate(O.isNone, () => ({ type: \"NoBidDefinedButStillForcing\", path } as const)),\n      E.map(constVoid))))\n\nconst pathIsSound = (path: Path<ConstrainedBid>) =>\n  pipe(path,\n    S.traverseArray(info =>\n      pipe(\n        S.modify(bidL.set(info.bid)),\n        S.chain(() => checkPassS),\n        S.chain(E.traverse(S.Applicative)(() =>\n          pipe(ofS(info.constraint),\n            S.apFirst(updateForceS),\n            S.chain(validateS),\n            S.map(E.mapLeft((r): SystemValidationBidError => ({ bid: info.bid, ...r })))))),\n        S.apFirst(S.modify(pathL.modify(RA.prepend(info.bid)))),\n        S.map(flow(\n          E.map(E.mapLeft((err): SystemValidationError => ({ ...err, path: pipe(path, RA.map(b => b.bid)) }))),\n          E.flatten)))),\n    S.map(RA.sequence(E.Applicative)),\n    eitherT.chain(S.Monad)(() => checkFinal),\n    S.evaluate(zeroContext))\n\nconst forestIsSound = (tree: Forest<ConstrainedBid>) : SystemValidation =>\n  pipe(tree,\n    getAllLeafPaths,\n    RA.traverse(E.Applicative)(pathIsSound),\n    E.map(constVoid))\n\nexport const validateTree = (forest: Forest<ConstrainedBid>) =>\n  pipe([forestSorted, forestIsSound],\n    RA.traverse(E.Applicative)(apply(forest)),\n    E.map(constVoid))","/* AutoGenerated Code, changes may be overwritten\n* INPUT GRAMMAR:\n* Start := hand=Hand $\n* Hand := S=Suit '\\.' H=Suit '\\.' D=Suit '\\.' C=Suit\n* Suit := cards=Card*\n* Card := c='[AKQJT2-9]'\n*   .rank = number {\n*     const rankStrings = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A']\n*     return rankStrings.indexOf(c) + 2\n*   }\n* // ValidChar := '[AKQJT2-9.]{16}' // 13 + 3 dots\n*/\ntype Nullable<T> = T | null;\ntype $$RuleType<T> = () => Nullable<T>;\ninterface ASTNodeIntf {\n    kind: ASTKinds;\n}\nexport enum ASTKinds {\n    Start = \"Start\",\n    Hand = \"Hand\",\n    Suit = \"Suit\",\n    Card = \"Card\",\n    $EOF = \"$EOF\",\n}\nexport interface Start {\n    kind: ASTKinds.Start;\n    hand: Hand;\n}\nexport interface Hand {\n    kind: ASTKinds.Hand;\n    S: Suit;\n    H: Suit;\n    D: Suit;\n    C: Suit;\n}\nexport interface Suit {\n    kind: ASTKinds.Suit;\n    cards: Card[];\n}\nexport class Card {\n    public kind: ASTKinds.Card = ASTKinds.Card;\n    public c: string;\n    public rank: number;\n    constructor(c: string){\n        this.c = c;\n        this.rank = ((): number => {\n        const rankStrings = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A']\n    return rankStrings.indexOf(c) + 2\n        })();\n    }\n}\nexport class Parser {\n    private readonly input: string;\n    private pos: PosInfo;\n    private negating: boolean = false;\n    private memoSafe: boolean = true;\n    constructor(input: string) {\n        this.pos = {overallPos: 0, line: 1, offset: 0};\n        this.input = input;\n    }\n    public reset(pos: PosInfo) {\n        this.pos = pos;\n    }\n    public finished(): boolean {\n        return this.pos.overallPos === this.input.length;\n    }\n    public clearMemos(): void {\n    }\n    public matchStart($$dpth: number, $$cr?: ErrorTracker): Nullable<Start> {\n        return this.run<Start>($$dpth,\n            () => {\n                let $scope$hand: Nullable<Hand>;\n                let $$res: Nullable<Start> = null;\n                if (true\n                    && ($scope$hand = this.matchHand($$dpth + 1, $$cr)) !== null\n                    && this.match$EOF($$cr) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Start, hand: $scope$hand};\n                }\n                return $$res;\n            });\n    }\n    public matchHand($$dpth: number, $$cr?: ErrorTracker): Nullable<Hand> {\n        return this.run<Hand>($$dpth,\n            () => {\n                let $scope$S: Nullable<Suit>;\n                let $scope$H: Nullable<Suit>;\n                let $scope$D: Nullable<Suit>;\n                let $scope$C: Nullable<Suit>;\n                let $$res: Nullable<Hand> = null;\n                if (true\n                    && ($scope$S = this.matchSuit($$dpth + 1, $$cr)) !== null\n                    && this.regexAccept(String.raw`(?:\\.)`, $$dpth + 1, $$cr) !== null\n                    && ($scope$H = this.matchSuit($$dpth + 1, $$cr)) !== null\n                    && this.regexAccept(String.raw`(?:\\.)`, $$dpth + 1, $$cr) !== null\n                    && ($scope$D = this.matchSuit($$dpth + 1, $$cr)) !== null\n                    && this.regexAccept(String.raw`(?:\\.)`, $$dpth + 1, $$cr) !== null\n                    && ($scope$C = this.matchSuit($$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Hand, S: $scope$S, H: $scope$H, D: $scope$D, C: $scope$C};\n                }\n                return $$res;\n            });\n    }\n    public matchSuit($$dpth: number, $$cr?: ErrorTracker): Nullable<Suit> {\n        return this.run<Suit>($$dpth,\n            () => {\n                let $scope$cards: Nullable<Card[]>;\n                let $$res: Nullable<Suit> = null;\n                if (true\n                    && ($scope$cards = this.loop<Card>(() => this.matchCard($$dpth + 1, $$cr), true)) !== null\n                ) {\n                    $$res = {kind: ASTKinds.Suit, cards: $scope$cards};\n                }\n                return $$res;\n            });\n    }\n    public matchCard($$dpth: number, $$cr?: ErrorTracker): Nullable<Card> {\n        return this.run<Card>($$dpth,\n            () => {\n                let $scope$c: Nullable<string>;\n                let $$res: Nullable<Card> = null;\n                if (true\n                    && ($scope$c = this.regexAccept(String.raw`(?:[AKQJT2-9])`, $$dpth + 1, $$cr)) !== null\n                ) {\n                    $$res = new Card($scope$c);\n                }\n                return $$res;\n            });\n    }\n    public test(): boolean {\n        const mrk = this.mark();\n        const res = this.matchStart(0);\n        const ans = res !== null;\n        this.reset(mrk);\n        return ans;\n    }\n    public parse(): ParseResult {\n        const mrk = this.mark();\n        const res = this.matchStart(0);\n        if (res)\n            return {ast: res, errs: []};\n        this.reset(mrk);\n        const rec = new ErrorTracker();\n        this.clearMemos();\n        this.matchStart(0, rec);\n        const err = rec.getErr()\n        return {ast: res, errs: err !== null ? [err] : []}\n    }\n    public mark(): PosInfo {\n        return this.pos;\n    }\n    private loop<T>(func: $$RuleType<T>, star: boolean = false): Nullable<T[]> {\n        const mrk = this.mark();\n        const res: T[] = [];\n        for (;;) {\n            const t = func();\n            if (t === null) {\n                break;\n            }\n            res.push(t);\n        }\n        if (star || res.length > 0) {\n            return res;\n        }\n        this.reset(mrk);\n        return null;\n    }\n    private run<T>($$dpth: number, fn: $$RuleType<T>): Nullable<T> {\n        const mrk = this.mark();\n        const res = fn()\n        if (res !== null)\n            return res;\n        this.reset(mrk);\n        return null;\n    }\n    private choice<T>(fns: Array<$$RuleType<T>>): Nullable<T> {\n        for (const f of fns) {\n            const res = f();\n            if (res !== null) {\n                return res;\n            }\n        }\n        return null;\n    }\n    private regexAccept(match: string, dpth: number, cr?: ErrorTracker): Nullable<string> {\n        return this.run<string>(dpth,\n            () => {\n                const reg = new RegExp(match, \"y\");\n                const mrk = this.mark();\n                reg.lastIndex = mrk.overallPos;\n                const res = this.tryConsume(reg);\n                if(cr) {\n                    cr.record(mrk, res, {\n                        kind: \"RegexMatch\",\n                        // We substring from 3 to len - 1 to strip off the\n                        // non-capture group syntax added as a WebKit workaround\n                        literal: match.substring(3, match.length - 1),\n                        negated: this.negating,\n                    });\n                }\n                return res;\n            });\n    }\n    private tryConsume(reg: RegExp): Nullable<string> {\n        const res = reg.exec(this.input);\n        if (res) {\n            let lineJmp = 0;\n            let lind = -1;\n            for (let i = 0; i < res[0].length; ++i) {\n                if (res[0][i] === \"\\n\") {\n                    ++lineJmp;\n                    lind = i;\n                }\n            }\n            this.pos = {\n                overallPos: reg.lastIndex,\n                line: this.pos.line + lineJmp,\n                offset: lind === -1 ? this.pos.offset + res[0].length : (res[0].length - lind - 1)\n            };\n            return res[0];\n        }\n        return null;\n    }\n    private noConsume<T>(fn: $$RuleType<T>): Nullable<T> {\n        const mrk = this.mark();\n        const res = fn();\n        this.reset(mrk);\n        return res;\n    }\n    private negate<T>(fn: $$RuleType<T>): Nullable<boolean> {\n        const mrk = this.mark();\n        const oneg = this.negating;\n        this.negating = !oneg;\n        const res = fn();\n        this.negating = oneg;\n        this.reset(mrk);\n        return res === null ? true : null;\n    }\n    private memoise<K>(rule: $$RuleType<K>, memo: Map<number, [Nullable<K>, PosInfo]>): Nullable<K> {\n        const $scope$pos = this.mark();\n        const $scope$memoRes = memo.get($scope$pos.overallPos);\n        if(this.memoSafe && $scope$memoRes !== undefined) {\n        this.reset($scope$memoRes[1]);\n        return $scope$memoRes[0];\n        }\n        const $scope$result = rule();\n        if(this.memoSafe)\n        memo.set($scope$pos.overallPos, [$scope$result, this.mark()]);\n        return $scope$result;\n    }\n    private match$EOF(et?: ErrorTracker): Nullable<{kind: ASTKinds.$EOF}> {\n        const res: {kind: ASTKinds.$EOF} | null = this.finished() ? { kind: ASTKinds.$EOF } : null;\n        if(et)\n            et.record(this.mark(), res, { kind: \"EOF\", negated: this.negating });\n        return res;\n    }\n}\nexport function parse(s: string): ParseResult {\n    const p = new Parser(s);\n    return p.parse();\n}\nexport interface ParseResult {\n    ast: Nullable<Start>;\n    errs: SyntaxErr[];\n}\nexport interface PosInfo {\n    readonly overallPos: number;\n    readonly line: number;\n    readonly offset: number;\n}\nexport interface RegexMatch {\n    readonly kind: \"RegexMatch\";\n    readonly negated: boolean;\n    readonly literal: string;\n}\nexport type EOFMatch = { kind: \"EOF\"; negated: boolean };\nexport type MatchAttempt = RegexMatch | EOFMatch;\nexport class SyntaxErr {\n    public pos: PosInfo;\n    public expmatches: MatchAttempt[];\n    constructor(pos: PosInfo, expmatches: MatchAttempt[]) {\n        this.pos = pos;\n        this.expmatches = [...expmatches];\n    }\n    public toString(): string {\n        return `Syntax Error at line ${this.pos.line}:${this.pos.offset}. Expected one of ${this.expmatches.map(x => x.kind === \"EOF\" ? \" EOF\" : ` ${x.negated ? 'not ': ''}'${x.literal}'`)}`;\n    }\n}\nclass ErrorTracker {\n    private mxpos: PosInfo = {overallPos: -1, line: -1, offset: -1};\n    private regexset: Set<string> = new Set();\n    private pmatches: MatchAttempt[] = [];\n    public record(pos: PosInfo, result: any, att: MatchAttempt) {\n        if ((result === null) === att.negated)\n            return;\n        if (pos.overallPos > this.mxpos.overallPos) {\n            this.mxpos = pos;\n            this.pmatches = [];\n            this.regexset.clear()\n        }\n        if (this.mxpos.overallPos === pos.overallPos) {\n            if(att.kind === \"RegexMatch\") {\n                if(!this.regexset.has(att.literal))\n                    this.pmatches.push(att);\n                this.regexset.add(att.literal);\n            } else {\n                this.pmatches.push(att);\n            }\n        }\n    }\n    public getErr(): SyntaxErr | null {\n        if (this.mxpos.overallPos !== -1)\n            return new SyntaxErr(this.mxpos, this.pmatches);\n        return null;\n    }\n}","import { either, eitherT, option, readonlyArray, readonlyNonEmptyArray, readonlyRecord, string } from 'fp-ts';\nimport { constant, flow, identity, pipe } from 'fp-ts/lib/function';\n\nimport { assertUnreachable } from '../lib';\nimport { Bid, Strain } from '../model/bridge';\nimport { rankFromString, ranks, Suit } from '../model/deck';\nimport { zeroSpecificShape } from '../model/evaluation';\nimport { SuitComparisonOperator } from '../model/system/core';\nimport { SuitSpecifier, SyntacticBid, Syntax, syntaxFalse, syntaxTrue, wrap } from '../model/system/expander';\nimport * as AST from '../parse/bid.peg.g';\n\nconst getConnectiveItems = (items: ReadonlyArray<AST.Constraint>) =>\n  pipe(items,\n    readonlyNonEmptyArray.fromReadonlyArray,\n    option.map(flow(\n      readonlyNonEmptyArray.map(constraint),\n      either.fromPredicate(i => i.length > 1, i => i[0]))))\n\nconst connective = (type: \"Conjunction\" | \"Disjunction\") =>\n  flow(getConnectiveItems,\n    eitherT.match(option.Functor)(identity, syntax => ({\n      type,\n      syntax\n    }) as const),\n    option.getOrElse(type === \"Conjunction\" ? syntaxTrue : syntaxFalse))\n\nconst suit = (s: AST.Suit) : Suit =>\n  s.kind === AST.ASTKinds.Club    ? 'C' :\n  s.kind === AST.ASTKinds.Diamond ? 'D' :\n  s.kind === AST.ASTKinds.Heart   ? 'H' :\n                                    'S'\n\nconst strain = (s: AST.Strain) : Strain =>\n  s.kind === AST.ASTKinds.Notrump ? 'N' :\n  suit(s)\n\nconst suitSpecifier = (s: AST.SuitSpecifier) : SuitSpecifier =>\n  s.kind === AST.ASTKinds.Major ? \"Major\" :\n  s.kind === AST.ASTKinds.Minor ? \"Minor\" :\n  s.kind === AST.ASTKinds.OtherMajor ? \"OtherMajor\" :\n  s.kind === AST.ASTKinds.OtherMinor ? \"OtherMinor\" :\n  s.kind === AST.ASTKinds.Wildcard ? \"Wildcard\" :\n  suit(s)\n\nconst bindValueQualifier = (s: AST.BoundQualifier, value: number) => (type: 'min' | 'max') =>\n  pipe(value,\n    option.of,\n    option.filter(_ =>\n      s.kind === AST.ASTKinds.Equals\n      || (type === 'min' && s.kind === AST.ASTKinds.Plus)\n      || (type === 'max' && s.kind === AST.ASTKinds.Minus)))\n\nconst constraintList = (c: AST.ConstraintList) : Syntax =>\n  pipe(c,\n    readonlyArray.map(c => c.constraint),\n    connective(\"Conjunction\"))\n\nexport const constraint = (c: AST.Constraint) : Syntax => {\n  switch (c.kind) {\n\n    case AST.ASTKinds.True:\n      return syntaxTrue()\n\n    case AST.ASTKinds.False:\n      return syntaxFalse()\n\n    case AST.ASTKinds.And:\n      return pipe(\n        c.constraints,\n        readonlyArray.map(c => c.constraint),\n        connective(\"Conjunction\"))\n\n    case AST.ASTKinds.Otherwise:\n      return { type: \"Otherwise\" }\n\n    case AST.ASTKinds.Or:\n      const flatten = (head: AST.Constraint, ...items: ReadonlyArray<AST.Constraint>) : readonlyNonEmptyArray.ReadonlyNonEmptyArray<AST.Constraint> =>\n        head.kind === AST.ASTKinds.Or\n        ? flatten(head.left, head.right, ...items)\n        : pipe(items,\n            readonlyNonEmptyArray.fromReadonlyArray,\n            option.fold(\n              () => [head],\n              items => [head, ...flatten(items[0], ...items.slice(1))]))\n      return pipe(\n        flatten(c.left, c.right),\n        connective(\"Disjunction\"))\n\n    case AST.ASTKinds.Not:\n      return {\n        type: \"Negation\",\n        syntax: constraint(c.constraint)\n      }\n\n    case AST.ASTKinds.OtherBid:\n      return {\n        type: \"OtherBid\",\n        bid: {\n          level: c.level.value,\n          strain: strain(c.strain)\n        }\n      }\n\n    case AST.ASTKinds.PointRange:\n      return wrap({\n        type: \"PointRange\",\n        min: c.lower.value,\n        max: c.upper.value\n      })\n\n    case AST.ASTKinds.PointBound:\n      return wrap({\n        type: \"PointRange\",\n        min: pipe(bindValueQualifier(c.qualifier, c.value.value)('min'), option.getOrElse(constant(0))),\n        max: pipe(bindValueQualifier(c.qualifier, c.value.value)('max'), option.getOrElse(constant(37))),\n      })\n\n    case AST.ASTKinds.SuitRange:\n      return {\n        type: \"SuitRange\",\n        min: c.lower.value,\n        max: c.upper.value,\n        suit: suitSpecifier(c.suit)\n      }\n\n    case AST.ASTKinds.SuitComparison:\n      return {\n        type: \"SuitComparison\",\n        op: c.op.v as SuitComparisonOperator,\n        left: suitSpecifier(c.left),\n        right: suitSpecifier(c.right)\n      }\n\n    case AST.ASTKinds.Primary:\n    case AST.ASTKinds.Secondary:\n      return {\n        type: `Suit${c.kind}`,\n        suit: suitSpecifier(c.suit)\n      }\n\n    case AST.ASTKinds.SuitBound:\n      return {\n        type: \"SuitRange\",\n        min: pipe(bindValueQualifier(c.qualifier, c.value.value)('min'), option.getOrElse(constant(0))),\n        max: pipe(bindValueQualifier(c.qualifier, c.value.value)('max'), option.getOrElse(constant(13))),\n        suit: suitSpecifier(c.suit)\n      }\n\n    case AST.ASTKinds.SuitHonors:\n      return {\n        type: \"SuitHonors\",\n        suit: suitSpecifier(c.suit),\n        honors: pipe(c.honors,\n          readonlyArray.fromArray,\n          readonlyArray.traverse(option.Applicative)(flow(h => h.v, rankFromString)),\n          option.getOrElseW(() => []))\n      }\n\n    case AST.ASTKinds.SuitTop:\n      return {\n        type: \"SuitTop\",\n        suit: suitSpecifier(c.suit),\n        count: parseInt(c.x),\n        minRank: ranks[ranks.length - parseInt(c.y)]\n      }\n\n    case AST.ASTKinds.AnyShape:\n      return wrap({\n        type: \"AnyShape\",\n        counts: pipe(c.v, string.split(''), readonlyArray.map(parseInt)) as [number, number, number, number]\n      })\n\n    case AST.ASTKinds.SpecificShape:\n      return wrap({\n        type: \"SpecificShape\",\n        suits: pipe(zeroSpecificShape, readonlyRecord.mapWithIndex((s, _) => c[s].value))\n      })\n\n    case AST.ASTKinds.Relay:\n      return wrap({\n        type: \"Relay\",\n        bid: {\n          level: c.bid.level.value,\n          strain: strain(c.bid.strain)\n        }\n      })\n\n    case AST.ASTKinds.LabelDef:\n      return {\n        type: \"LabelDef\",\n        name: c.label.v,\n        definition: constraintList(c.constraints)\n      }\n\n    case AST.ASTKinds.LabelRef:\n      return {\n        type: \"LabelRef\",\n        name: c.label.v\n      }\n\n    case AST.ASTKinds.Balanced:\n    case AST.ASTKinds.SemiBalanced:\n    case AST.ASTKinds.Unbalanced:\n      return { type: c.kind }\n    \n    default:\n      return wrap({ type: c.kind })\n  }\n}\n\nexport const bid = (bid: AST.Bid): Bid => {\n  switch (bid.kind) {\n    case AST.ASTKinds.ContractBid:\n      return {\n        level: bid.level.value,\n        strain: strain(bid.specifier as AST.Strain),\n      }\n    case AST.ASTKinds.Pass:\n      return \"Pass\"\n    default:\n      return assertUnreachable(bid)\n  }\n}\n\nexport const constrainedBid = (bidSpec: AST.BidSpec) : SyntacticBid => ({\n  bid: bid(bidSpec.bid),\n  syntax: pipe(\n    bidSpec.constraints?.constraints,\n    option.fromNullable,\n    option.fold(syntaxFalse, constraintList))\n})\n\nexport const parseBid = AST.parse\n","import { ord, readonlyArray, readonlyNonEmptyArray, readonlyRecord, readonlySet, readonlyTuple, string } from 'fp-ts';\nimport { Right } from 'fp-ts/lib/Either';\nimport { flow, identity, pipe } from 'fp-ts/lib/function';\nimport * as e from 'io-ts/Encoder';\n\nimport { Board, directions, ordDirection } from '../model/bridge';\nimport { Card, eqCard, getOrdGroupedHand, groupHandBySuits, Hand, ordRankDescending, Rank, RankC, Suit, suits } from '../model/deck';\nimport * as AST from '../parse/hand.peg.g';\n\nconst suit = (hand: AST.Hand) => (suit: Suit) : ReadonlyArray<Card> =>\n  pipe(hand[suit].cards,\n    readonlyArray.map(card => ({ suit, rank: (RankC.decode(card.rank) as Right<Rank>).right })))\n\nexport const hand = (hand: AST.Hand) : Hand =>\n  pipe(suits,\n    readonlyArray.map(suit(hand)),\n    readonlyArray.flatten,\n    readonlySet.fromReadonlyArray(eqCard))\n\nexport const parseHand = AST.parse\n\n// PBN hand notation\nexport const handE : e.Encoder<string, Hand> = {\n  encode: flow(\n    groupHandBySuits,\n    readonlyRecord.toReadonlyArray,\n    readonlyArray.sort(getOrdGroupedHand<ReadonlyArray<Rank>>()),\n    readonlyArray.map(flow(\n      readonlyTuple.snd,\n      readonlyArray.sort(ordRankDescending),\n      readonlyArray.reduce(\"\", (cur, rank) => cur + RankC.encode(rank)))),\n    readonlyArray.intersperse(\".\"),\n    readonlyArray.foldMap(string.Monoid)(identity))\n}\n\n// PBN board notation\nexport const boardE : e.Encoder<string, Board> = {\n  encode: ({ dealer, deal }) => pipe(deal,\n    readonlyRecord.map(handE.encode),\n    readonlyRecord.toReadonlyArray,\n    readonlyArray.sort(ord.contramap(readonlyTuple.fst)(ordDirection)),\n    readonlyArray.rotate(directions.indexOf(dealer)),\n    readonlyArray.map(readonlyTuple.snd),\n    readonlyArray.intersperse(\" \"),\n    readonlyArray.prepend(dealer + \":\"),\n    readonlyNonEmptyArray.concatAll(string.Semigroup))\n}","import { either, option, readonlyArray, readonlyNonEmptyArray as RNEA } from 'fp-ts';\nimport { constant, flow, pipe } from 'fp-ts/lib/function';\nimport * as d from 'io-ts/Decoder';\nimport * as DE from 'io-ts/lib/DecodeError';\nimport * as FS from 'io-ts/lib/FreeSemigroup';\n\nimport { constrainedBid, parseBid } from './bid';\nimport { hand, parseHand } from './hand';\n\nexport interface PosInfo {\n  readonly overallPos: number;\n  readonly line: number;\n  readonly offset: number;\n}\nexport interface RegexMatch {\n  readonly kind: \"RegexMatch\";\n  readonly negated: boolean;\n  readonly literal: string;\n}\nexport type EOFMatch = { kind: \"EOF\"; negated: boolean };\nexport type MatchAttempt = RegexMatch | EOFMatch;\ninterface SyntaxErr {\n  pos: PosInfo;\n  expmatches: MatchAttempt[];\n  toString(): string\n}\ninterface ParseResult<T> {\n  ast: T | null;\n  errs: SyntaxErr[];\n}\n// above is generalized from generated tsPEG code\n\nconst convertErrors = (errs: ReadonlyArray<readonly [string, SyntaxErr]>): d.DecodeError =>\n  pipe(errs,\n    RNEA.fromReadonlyArray,\n    option.fold(constant(d.error(null, \"No syntax errors reported\")),\n      RNEA.foldMap(FS.getSemigroup<DE.DecodeError<string>>())(([actual, err]) =>\n        FS.of(DE.key(actual, \"required\",\n          FS.of(DE.index(err.pos.offset, \"required\",\n            pipe(err.expmatches,\n              RNEA.fromReadonlyArray,\n              option.fold(constant(FS.of(DE.leaf(actual, \"\"))),\n                RNEA.foldMapWithIndex(FS.getSemigroup<DE.DecodeError<string>>())((i, x)=>\n                  FS.of(DE.leaf(actual.substring(err.pos.offset), x.kind === \"EOF\" ? \"EOF\" : `${x.negated ? 'not ': ''}'${x.literal}'`))))))))))))\n\nconst parseResultToEither = <T>(result: ParseResult<T>) =>\n  either.fromNullable(result.errs)(result.ast)\n\nconst getDecoder = <T>(parser: (input: string) => ParseResult<T>) : d.Decoder<string, T> =>\n  pipe(\n    d.string,\n    d.parse(input => pipe(input,\n      parser,\n      parseResultToEither,\n      either.mapLeft(flow(\n        readonlyArray.map(x => [input, x] as const),\n        convertErrors)))))\n\nexport const decodeBid = flow(\n  getDecoder(parseBid).decode,\n  either.map(x => constrainedBid(x.spec)))\n\nexport const decodeHand = flow(\n  getDecoder(parseHand).decode,\n  either.map(x => hand(x.hand)))","import { either as E, eq, option as O, readonlyArray as RA, readonlyNonEmptyArray as RNEA, string, these as TH, tree as T } from 'fp-ts';\nimport { flow, identity, pipe } from 'fp-ts/lib/function';\nimport { castDraft } from 'immer';\nimport { DecodeError } from 'io-ts/lib/Decoder';\nimport memoize from 'proxy-memoize';\n\nimport { createEntityAdapter, createSlice, PayloadAction } from '@reduxjs/toolkit';\n\nimport { Bid, eqBid } from '../model/bridge';\nimport { chainCollectedErrors, collectErrors, flatten, ForestWithErrors, getAllLeafPaths, getPathForest, getPathUpTo, Path, withImplicitPasses } from '../model/system';\nimport { ExpandError, expandForest, SyntacticBid } from '../model/system/expander';\nimport { SystemValidationError, validateTree } from '../model/system/validation';\nimport { decodeBid } from '../parse';\n\ntype BlockKey = string\nconst eqBlockKey : eq.Eq<BlockKey> = string.Eq\n\nexport type DecodedBid = ReturnType<typeof decodeBid>\ninterface DecodedBidItem {\n  id: BlockKey\n  value: DecodedBid\n}\nconst decodedBidAdapter = createEntityAdapter<DecodedBidItem>()\n\ntype BlockTree = T.Forest<BlockKey>\ninterface State {\n  system: BlockTree\n  decodedBids: ReturnType<typeof decodedBidAdapter.getInitialState>\n}\n\nconst initialState: State = {\n  system: [],\n  decodedBids: decodedBidAdapter.getInitialState()\n}\n\nexport interface BlockKeyDescriptor {\n  key: BlockKey\n  depth: number\n}\nconst buildForest = (items: ReadonlyArray<BlockKeyDescriptor>): BlockTree => {\n  const root = T.make<BlockKey>(\"ROOT\")\n  var parents = [root]\n  items.forEach(item => {\n    const curr = parents[item.depth + 1] = {\n      forest: [],\n      value: item.key\n    }\n    parents[item.depth].forest.push(curr)\n  })\n  return root.forest\n}\n\nexport interface BlockItem {\n  key: string\n  text: string\n}\n\nconst name = 'system'\nconst slice = createSlice({\n  name,\n  initialState,\n  reducers: {\n    setSystem: (state, action: PayloadAction<ReadonlyArray<BlockKeyDescriptor>>) => {\n      state.system = pipe(buildForest(action.payload), castDraft)\n    },\n    removeConstraintsByBlockKey: (state, action: PayloadAction<RNEA.ReadonlyNonEmptyArray<BlockKey>>) => {\n      decodedBidAdapter.removeMany(state.decodedBids, action.payload)\n    },\n    cacheSystemConstraints: (state, action: PayloadAction<RNEA.ReadonlyNonEmptyArray<BlockItem>>) => {\n      decodedBidAdapter.setMany(state.decodedBids, pipe(\n        action.payload,\n        RNEA.map(i => ({ id: i.key, value: decodeBid(i.text) }))))\n    }\n  }\n})\n\nexport const { setSystem, removeConstraintsByBlockKey, cacheSystemConstraints } = slice.actions\n\nconst constrainedBidSelectors = decodedBidAdapter.getSelectors()\n\ninterface KeyedState {\n  state: State\n  key: BlockKey\n}\n\nconst getCachedBidByKey = (constrainedBids: State['decodedBids']) => (key: BlockKey) =>\n  pipe(\n    O.fromNullableK(constrainedBidSelectors.selectById)(constrainedBids, key),\n    O.map(i => i.value))\n\nexport const selectBidByKey = memoize(({ state, key }: KeyedState) =>\n  pipe(key,\n    getCachedBidByKey(state.decodedBids),\n    O.chain(O.fromEither)))\n\nexport const selectBidPathUpToKey = memoize(({ state, key }: KeyedState) =>\n  pipe(\n    state.system,\n    getPathUpTo(eqBlockKey)(key),\n    O.getOrElse(() => RA.zero()),\n    RA.filterMap(getCachedBidByKey(state.decodedBids)),\n    RA.sequence(E.Applicative)))\n\nexport const selectRules = memoize((state: State) =>\n  pipe(state.system,\n    flatten,\n    RA.filterMap(getCachedBidByKey(state.decodedBids))))\n\nexport const selectErrors = memoize(\n  flow(\n    selectRules,\n    RA.lefts))\n\nconst getCompleteForest = (bids: State['decodedBids']) =>\n  flow(\n    RA.filterMap(T.traverse(O.Applicative)(getCachedBidByKey(bids))),\n    collectErrors)\n\ninterface OptionsState {\n  state: State\n  options?: { implicitPass: boolean }\n}\nexport const selectCompleteSyntaxForest = memoize(({ state, options }: OptionsState): ForestWithErrors<DecodeError, SyntacticBid> =>\n  pipe(state.system,\n    getCompleteForest(state.decodedBids),\n    TH.map(options?.implicitPass ? withImplicitPasses : identity)))\n\ninterface SystemErrorParse { type: \"Parse\", error: DecodeError }\ninterface SystemErrorSyntax { type: \"Syntax\", error: ExpandError }\ninterface SystemErrorValidation { type: \"Validation\", error: SystemValidationError }\nexport type SystemErrorWithPath = SystemErrorSyntax | SystemErrorValidation\nexport type SystemError =\n  | SystemErrorParse\n  | SystemErrorSyntax\n  | SystemErrorValidation\n\nexport const selectCompleteConstraintForest = memoize(\n  flow(selectCompleteSyntaxForest,\n    TH.mapLeft(RA.map((error): SystemError => ({ type: \"Parse\", error }))), \n    chainCollectedErrors(flow(\n      expandForest,\n      TH.mapLeft(RA.map((error): SystemError => ({ type: \"Syntax\", error }))))),\n    chainCollectedErrors(bidForest => pipe(\n      bidForest,\n      validateTree,\n      TH.bimap(\n        (error): ReadonlyArray<SystemError> => RA.of({ type: \"Validation\", error }),\n        () => bidForest)))))\n\nexport const selectSystemWithErrors = memoize(\n  flow(selectCompleteConstraintForest,\n    TH.map(getAllLeafPaths)))\n\nexport const selectPristineSystem = memoize(\n  flow(selectSystemWithErrors,\n    TH.getRightOnly,\n    O.chain(RNEA.fromReadonlyArray)))\n\nexport const selectValidConstrainedBidPaths = memoize(\n  flow(selectSystemWithErrors,\n    TH.getRight,\n    O.chain(RNEA.fromReadonlyArray)))\n\nexport const selectCompleteBidPathUpToKey = memoize((state: KeyedState & OptionsState) =>\n  pipe(O.Do,\n    O.apS('path', O.fromEitherK(selectBidPathUpToKey)(state)),\n    O.apS('paths', pipe(state, selectCompleteConstraintForest, TH.getRight, O.map(getAllLeafPaths))),\n    O.chain(({ path, paths }) =>\n      pipe(paths,\n        RA.findFirst(cbPath =>\n          RA.getEq(pipe(eqBid, eq.contramap((b: { bid: Bid }) => b.bid)))\n            .equals(path, cbPath))))))\n\nexport const selectCompleteBidByKey = flow(\n  selectCompleteBidPathUpToKey,\n  O.map(RNEA.last))\n\nconst eqBidPath = pipe(eqBid, RA.getEq)\nexport interface ErrorNode {\n  bid: Bid\n  path: Path<Bid>\n  errors: ReadonlyArray<SystemErrorWithPath>\n}\nexport const selectErrorTree = memoize((options: OptionsState) =>\n  pipe(options,\n    selectCompleteSyntaxForest,\n    TH.map(flow(\n      RA.map(T.map(sb => sb.bid)),\n      getPathForest,\n      RA.toArray,\n      pathForest => pipe(options,\n        selectCompleteConstraintForest,\n        TH.getLeft,\n        O.getOrElse(() => RA.zero()),\n        RA.filterMap(e => e.type !== \"Parse\" ? O.some(e) : O.none),\n        errors =>\n          pipe(pathForest,\n            RA.map(T.map((path): ErrorNode => ({\n              bid: pipe(path, RNEA.last),\n              path,\n              errors: pipe(errors, RA.filter(e => eqBidPath.equals(e.error.path, path)))\n            })))))))))\n\nexport const selectErrorsByKey = memoize((state: KeyedState & OptionsState) =>\n  pipe(O.Do,\n    O.apS('errors', pipe(state,\n      selectErrorTree,\n      TH.getRight)),\n    O.apS('sb', selectBidByKey(state)),\n    O.fold(() => RA.empty,\n      ({ sb, errors }) => pipe(errors,\n        flatten,\n        RA.filter(e => eqBid.equals(sb.bid, e.bid))))))\n    \nexport default slice.reducer","import { readonlyArray, readonlyRecord, readonlyTuple } from 'fp-ts';\nimport { pipe } from 'fp-ts/lib/function';\nimport styled from 'styled-components';\nimport { getOrdGroupedHand, groupHandBySuits, Hand, Rank, rankStrings, Suit } from '../../model/deck';\n\n\nconst RankList = styled.ol `\n  padding-left: 0;\n`\n\nconst RankListItem = styled.li `\n  list-style-type: none;\n  display: inline;\n  float: left;\n`\n\ninterface RankProps {\n  rank: Rank\n}\nconst RankView = ({ rank }: RankProps) =>\n  <RankListItem>{rankStrings[rank - 2]}</RankListItem>\n\nconst SuitList = styled.ol `\n  white-space: nowrap;\n  width: 15em;\n  margin: 0;\n  padding-left: 0;\n  list-style: decimal url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) inside;\n`\n\nconst suitBase = `\n  &.S::before { content: \"♠\"; color: #0000FF }\n  &.H::before { content: \"♥\"; color: #FF0000 }\n  &.D::before { content: \"♦\"; color: #FFA500 }\n  &.C::before { content: \"♣\"; color: #32CD32 }\n`\n\nconst SuitListItem = styled.li `\n  display: inline;\n  &::before {\n    display: inline;\n    float: left;\n    margin-left: 5px;\n  }\n  ${suitBase}\n`\n\ninterface SuitProps {\n  suit: Suit\n  ranks: ReadonlyArray<Rank>\n}\nconst SuitView = ({ suit, ranks }: SuitProps) => {\n  return <SuitListItem className={suit}>\n    <RankList>\n      {ranks.map((r, i) => <RankView key={i} rank={r} />)}\n      {ranks.length === 0 && <RankListItem>-</RankListItem> }\n    </RankList>\n </SuitListItem>\n}\n\ninterface HandProps {\n  hand: Hand\n}\nconst HandView = ({ hand }: HandProps) => {\n  const groupedHand = groupHandBySuits(hand)\n  return (\n    <SuitList>\n      {pipe(groupedHand,\n        readonlyRecord.mapWithIndex((suit, ranks) =>\n          <SuitView key={suit} suit={suit} ranks={ranks} />),\n        readonlyRecord.toReadonlyArray,\n        readonlyArray.sort(getOrdGroupedHand<JSX.Element>()),\n        readonlyArray.map(readonlyTuple.snd))}\n    </SuitList>\n  )\n}\n\nexport default HandView","import styled from 'styled-components';\nimport { directions, strains } from '../../model/bridge';\nimport { serializedDealL } from '../../model/serialization';\nimport { DoubleDummyResult, DoubleDummyTable } from '../../workers/dds.worker';\nimport HandView from './HandView';\n\n\nconst suitBase = `\n  &.S::before { content: \"♠\"; color: #0000FF }\n  &.H::before { content: \"♥\"; color: #FF0000 }\n  &.D::before { content: \"♦\"; color: #FFA500 }\n  &.C::before { content: \"♣\"; color: #32CD32 }\n`\n\nconst StrainSpan = styled.span `\n  ${suitBase}\n  &.N::before { content: \"NT\"; color: #000000; font-size: 12px; }\n`\n\ninterface DoubleDummyTableProps {\n  table: DoubleDummyTable\n}\nexport const DoubleDummyTableView = ({ table }: DoubleDummyTableProps) => {\n  return (\n    <table>\n      <thead>\n        <tr>\n          <th></th>\n          {strains.map((s, i) => <th style={{fontWeight: \"normal\", verticalAlign: \"middle\"}} key={i}><StrainSpan className={s} /></th>)}\n        </tr>\n      </thead>\n      <tbody>\n        {directions.map((d, i) => <tr key={i}>\n          <td>{d}</td>\n          {strains.map((s, i) => <td key={i}>{Math.round(table[s][d] * 100) / 100}</td>)}\n        </tr>)}\n      </tbody>\n    </table>\n  )\n}\n\ninterface Props {\n  result: DoubleDummyResult\n}\nconst DoubleDummyResultView = ({ result }: Props) => {\n  return (\n    <table>\n      <thead>\n        <tr>\n          <th></th>\n          {strains.map((s, i) => <th style={{fontWeight: \"normal\", verticalAlign: \"middle\"}} key={i}><StrainSpan className={s} /></th>)}\n        </tr>\n      </thead>\n      <tbody>\n        {directions.map((d, i) => <tr key={i}>\n          <td>{d}</td>\n          {strains.map((s, i) => <td key={i}>{result.results[s][d]}</td>)}\n          <td><HandView hand={serializedDealL.reverseGet(result.board.deal)[d]} /></td>\n        </tr>)}\n      </tbody>\n    </table>\n  )\n}\n\nexport default DoubleDummyResultView","import { Stats } from '../../model/stats';\nimport { DoubleDummyTableView } from '../core/DoubleDummyResultView';\n\ninterface SolutionStatsProps {\n  stats: Stats\n}\nconst SolutionStats = ({ stats }: SolutionStatsProps) => {\n  return (\n    <div>\n      <span>{stats.count !== null && <>{stats.count.toString()}</>}</span>\n      {stats.average !== null && <section>\n        <h4>Average</h4>\n        {stats.average !== null && <DoubleDummyTableView table={stats.average} />}\n      </section>}\n      {stats.stdev !== null && <section>\n        <h4>Std. Dev.</h4>\n        <DoubleDummyTableView table={stats.stdev} />\n      </section>}\n    </div>)\n}\n\nexport default SolutionStats","import { Fragment } from 'react';\nimport styled from 'styled-components';\n\nimport { Bid, ContractBid, NonContractBid } from '../../model/bridge';\n\nconst SuitSpan = styled.span `\n  &.S::after { content: \"♠\"; color: #0000FF; }\n  &.H::after { content: \"♥\"; color: #FF0000; }\n  &.D::after { content: \"♦\"; color: #FFA500; }\n  &.C::after { content: \"♣\"; color: #32CD32; }\n  &.N::after { content: \"NT\" }\n`\n\nconst ContractBidView = ({ bid }: { bid: ContractBid }) =>\n  <>\n    <span>{bid.level}</span>\n    <SuitSpan className={bid.strain}></SuitSpan>\n  </>\n\nconst NonContractBidView = ({ bid }: { bid: NonContractBid }) =>\n  <span>{bid}</span>\n\nexport const BidView = ({ bid }: { bid: Bid }) =>\n  typeof bid === \"string\"\n    ? <NonContractBidView bid={bid} />\n    : <ContractBidView bid={bid} />\ninterface Props {\n  path: ReadonlyArray<Bid>\n}\nconst BidPath = ({ path }: Props) => \n  <span>{path.map((bid, i) => \n    <Fragment key={i}>\n      &nbsp;\n      <BidView bid={bid} />\n    </Fragment>)\n  }</span>\n\nexport default BidPath","interface FractionalProps {\n  numerator: number\n  denominator: number\n  decimalPlaces?: number\n}\nconst Fractional = ({ numerator, denominator, decimalPlaces }: FractionalProps) => {\n  const m = Math.pow(10, decimalPlaces ?? 0)\n  return <span>1 in {Math.floor(denominator / numerator * m) / m}</span>\n}\n\nexport default Fractional","interface PercentageProps {\n  numerator: number\n  denominator: number\n  decimalPlaces?: number\n}\nconst Percentage = ({ numerator, denominator, decimalPlaces }: PercentageProps) => {\n  const m = Math.pow(10, decimalPlaces ?? 0)\n  return <span>{Math.floor(numerator * (100 * m) / denominator) / m}%</span>\n}\n\nexport default Percentage","\n\nimport { SerializedBidPath, serializedBidPathL } from '../../model/serialization';\nimport BidPath from '../core/BidPath';\nimport Fractional from '../core/Fractional';\nimport Percentage from '../core/Percentage';\n\ninterface StatsPathProps {\n  path: SerializedBidPath\n  satisfiesCount: number\n  dealCount?: number\n}\nconst StatsPath = ({ path, satisfiesCount, dealCount }: StatsPathProps) => {\n  // const sPath = pipe(path,\n  //   readonlyNonEmptyArray.map(p => p.bid),\n  //   serializedBidPathL.get)\n  // const dds = useAppSelector(state => pipe(\n  //   path,\n  //   readonlyNonEmptyArray.map(p => p.bid),\n  //   serializedBidPathL.get,\n  //   path => selectResultsByPath({ state: state.generator, path })))\n  // const stats = dds && getStats(pipe(dds, readonlyNonEmptyArray.map(d => d.results)))\n  // const averages = stats && average(stats)\n  // const stdevs = stats && stdev(stats)\n  return (\n    <>\n      <BidPath path={serializedBidPathL.reverseGet(path)} />\n      <span>\n        {satisfiesCount}\n        {dealCount && <small>\n          &nbsp;(\n          <Percentage numerator={satisfiesCount} denominator={dealCount} decimalPlaces={2} />\n          &nbsp;,&nbsp;or&nbsp;\n          <Fractional numerator={satisfiesCount} denominator={dealCount} />\n          )\n        </small>}\n      </span>\n      {/* {averages !== null && <section>\n        <h4>Average</h4>\n        {averages !== null && <DoubleDummyTableView table={averages} />}\n      </section>}\n      {stdevs !== null && <section>\n        <h4>Std. Dev.</h4>\n        <DoubleDummyTableView table={stdevs} />\n      </section>} */}\n      {/* {dds === null && <button onClick={e => dispatch(getResults({ path: path, deals: result.deals }))}>DDS</button>} */}\n      {/* {dds === null\n        ? <button onClick={e => dispatch(getResults({ path: result.path, deals: result.deals }))}>DDS</button>\n        : <ul>{dds.map((ddr, i) => <li  key={i}><DoubleDummyResultView result={ddr} /></li>)}</ul>} */}\n    </>)\n}\n\nexport default StatsPath","import { number, option as O, readonlyArray as RA, readonlyRecord as RR, readonlyTuple, taskEither as TE } from 'fp-ts';\nimport { flow, pipe } from 'fp-ts/lib/function';\nimport { Fragment, useCallback, useMemo, useState } from 'react';\nimport styled from 'styled-components';\n\nimport { useAppDispatch, useAppSelector } from '../app/hooks';\nimport { get } from '../lib/object';\nimport { eqBid } from '../model/bridge';\nimport { AnalysisId, ConstrainedBidPathHash, GenerationId, getBidPathHash, newGenerationId } from '../model/job';\nimport { SerializedBidPath, serializedBidPathL } from '../model/serialization';\nimport { Paths } from '../model/system';\nimport { ConstrainedBid } from '../model/system/core';\nimport { scheduleJob } from '../reducers/generator';\nimport { addAnalysis, deleteAnalysis, selectAllAnalyses, selectAnalysis, selectAnalysisById, selectGenerationByAnalysis, selectSelectedAnalysis, setAnalysisName } from '../reducers/profile';\nimport { selectValidConstrainedBidPaths } from '../reducers/system';\nimport { getDealsWithSolutionsByPath } from '../services/idb';\nimport SolutionStats from './stats/SolutionStats';\nimport StatsPath from './stats/StatsPath';\n\nconst FlexList = styled.ul `\n  display: flex;\n  flex-flow: row wrap;\n  list-style-type: none;\n  padding: 0px;\n  margin: 0px;\n`\nconst FlexListItem = styled.li `\n  padding: 0px;\n  margin: 5px;\n`\n\ninterface AnalysisProps {\n  analysisId: AnalysisId\n}\nconst AnalysisView = ({ analysisId }: AnalysisProps) => {\n  const analysis = useAppSelector(state => pipe(\n    selectAnalysisById({ state: state.profile, analysisId }),\n    O.toNullable))\n  const dispatch = useAppDispatch()\n  const dealCount = !analysis ? 0 : pipe(analysis.generations, RA.foldMap(number.MonoidSum)(g => g.dealCount))\n  const onRemoveClick = useCallback(() => dispatch(deleteAnalysis(analysisId)), [analysisId, dispatch])\n  const onSelectClick = useCallback(() => dispatch(selectAnalysis(analysisId)), [analysisId, dispatch])\n  const onNameChange = useCallback(name => dispatch(setAnalysisName(analysisId, name)), [analysisId, dispatch])\n  return (<>{analysis &&\n    <FlexListItem>\n      <input type=\"text\" value={analysis.name} onChange={e => onNameChange(e.target.value)} />\n      <p>\n        Paths: {analysis.paths.length} <br />\n        Deals: {dealCount} <small>({analysis.generations.length} generations)</small><br />\n      </p>\n      <button onClick={onSelectClick}>Select</button>\n      <button onClick={onRemoveClick}>Remove</button>\n    </FlexListItem>\n  }</>)\n}\n\n\ninterface StatsPathItemProps {\n  generationId: GenerationId\n  analysisId: AnalysisId\n  path: SerializedBidPath\n  pathHash: ConstrainedBidPathHash\n  count: number\n}\nconst StatsPathItem = ({ path, count, generationId, analysisId, pathHash }: StatsPathItemProps) => {\n  const generation = useAppSelector(state => pipe(\n    selectGenerationByAnalysis({ state: state.profile, analysisId, generationId }),\n    O.toNullable))\n  const stats = pipe(\n    generation,\n    O.fromNullable,\n    O.chain(flow(\n      get('solutionStats'),\n      RR.lookup(path))),\n    O.toNullable)\n  const solveCount = pipe(\n    stats,\n    O.fromNullable,\n    O.map(get('count')),\n    O.chain(O.fromPredicate(len => len > 0)),\n    O.toNullable)\n\n  const [showTables, setShowTables] = useState(false)\n\n  const dispatch = useAppDispatch()\n  const onSolveClick = useCallback(() => pipe(\n    getDealsWithSolutionsByPath(generationId, pathHash),\n    TE.map(flow(\n      RR.filter(d => O.isNone(d.solution)),\n      RR.map(d => d.deal),\n      RR.toReadonlyArray,\n      RA.map(readonlyTuple.snd),\n      deals => dispatch(scheduleJob({\n        analysisId: analysisId,\n        type: \"Solve\",\n        parameter: deals,\n        context: { generationId: generationId, bidPath: path },\n        estimatedUnitsInitial: deals.length\n      })))))()\n    , [analysisId, dispatch, generationId, path, pathHash])\n  return (<>{generation && <>\n    {/* Contained in CSS grid, so make sure the node count is consistent with StatsPathContainer CSS */}\n    <StatsPath path={path} satisfiesCount={count} dealCount={generation.dealCount} />\n    <span>\n      <button onClick={onSolveClick}>Solve</button>\n      {stats && solveCount && <span>\n        ({solveCount} so far)\n        <button onClick={() => setShowTables(!showTables)}>{!showTables ? \"Show\" : \"Hide\"} Stats</button>\n        {showTables && <SolutionStats stats={stats} />}\n      </span>}\n    </span>\n  </>}</>)\n}\n\nconst StatsPathContainer = styled.div `\n  clear: both;\n  display: inline-grid;\n  grid-column-gap: 5px;\n  grid-template-columns: auto auto auto;\n  width: auto;\n`\n\ninterface GenerationViewProps {\n  analysisId: AnalysisId\n  generationId: GenerationId\n}\nconst GenerationView = ({ analysisId, generationId }: GenerationViewProps) => {\n  const generation = useAppSelector(state => pipe(\n    selectGenerationByAnalysis({ state: state.profile, analysisId, generationId }),\n    O.toNullable))\n  const satisfies = useMemo(() => pipe(\n    generation,\n    O.fromNullable,\n    O.chain(get(\"satisfies\")),\n    O.map(RR.toReadonlyArray),\n    O.toNullable)\n    , [generation])\n  const paths = useAppSelector(state => pipe(\n    selectAnalysisById({ state: state.profile, analysisId }),\n    O.map(get(\"paths\")),\n    O.toNullable))\n    \n  const dispatch = useAppDispatch()\n  const onSatisfiesClick = useCallback(() => generation && paths && dispatch(scheduleJob({\n    analysisId: analysisId,\n    type: \"Satisfies\",\n    parameter: paths,\n    context: { generationId: generation.id },\n    estimatedUnitsInitial: paths.length * generation.dealCount\n  })), [analysisId, dispatch, generation, paths])\n\n  const getHash = useCallback((path: SerializedBidPath) => pipe(\n    paths,\n    O.fromNullable,\n    O.chain(RA.findFirst(flow(\n      RA.map(get('bid')),\n      bids => RA.getEq(eqBid).equals(bids, serializedBidPathL.reverseGet(path))))),\n    O.map(getBidPathHash),\n    O.toNullable\n  ), [paths])\n\n  return (<>{generation &&\n    <FlexListItem>\n      Deal Count: {generation.dealCount} <br/>\n      {satisfies === null && <button onClick={onSatisfiesClick}>Satisfies</button>}\n      {satisfies !== null && <StatsPathContainer>\n        {satisfies.map(([path, count]) => {\n          const pathHash = getHash(path)\n          return (<Fragment key={path}>\n            {pathHash && <StatsPathItem key={path} path={path} pathHash={pathHash} count={count} generationId={generationId} analysisId={analysisId} />}\n          </Fragment>)\n        })}\n      </StatsPathContainer>}\n    </FlexListItem>\n  }</>)\n}\n\nconst SelectedAnalysis = () => {\n  const analysis = useAppSelector(state => pipe(selectSelectedAnalysis(state.profile), O.toNullable))\n  const generateCount = useAppSelector(state => state.settings.generateCount)\n\n  const dispatch = useAppDispatch()\n  const onGenerateDealsClick = useCallback((count: number) => {\n    if (analysis) {\n      dispatch(scheduleJob({\n        analysisId: analysis.id,\n        type: \"GenerateDeals\",\n        context: { generationId: newGenerationId() },\n        parameter: count,\n        estimatedUnitsInitial: count\n      }))\n    }\n  }, [analysis, dispatch])\n\n  return (<>{analysis &&\n    <div>\n      <h4>{analysis.name}</h4>\n      <FlexList>\n        {analysis.generations.map(g => <GenerationView key={g.id} analysisId={analysis.id} generationId={g.id} />)}\n      </FlexList>\n      <button onClick={() => onGenerateDealsClick(generateCount)}>Generate Deals</button>\n    </div>\n  }</>)\n}\n\nconst Analyses = () => {\n  const analyses = useAppSelector(state => selectAllAnalyses(state.profile))\n  const dispatch = useAppDispatch()\n  const onCreateClick = useCallback((paths: Paths<ConstrainedBid>) => dispatch(addAnalysis(paths)), [dispatch])\n  const paths = useAppSelector(state => pipe(\n    selectValidConstrainedBidPaths({ state: state.system, options: state.settings }),\n    O.toNullable))\n  return (\n    <section>\n      <h3>Analyses</h3>\n      <FlexList>\n        {analyses.map(a => <AnalysisView key={a.id} analysisId={a.id} />)}\n      </FlexList>\n      {paths && <button onClick={() => onCreateClick(paths)}>Create</button>}\n      <SelectedAnalysis />\n    </section>\n  )\n}\n\nexport default Analyses\n\n","import { boolean, option as O, readonlyArray as RA, readonlyNonEmptyArray as RNEA, state as S } from 'fp-ts';\nimport { identity, pipe } from 'fp-ts/lib/function';\n\nimport { eqBid } from '../bridge';\nimport { Hand } from '../deck';\nimport { BidContext, bidL, ConstrainedBid, Constraint, constraintTrue, forceO, ofS, pathL, satisfiesS, zeroContext } from './core';\n\nmodule Gen {\n  export function* alternate<A>(opener: A, responder: A) {\n    while (true) { yield opener; yield responder }\n  }\n\n  export const unfold = (length: number) => <A>(g: Generator<A>) : readonly A[] => {\n    const val = g.next()\n    return val.done || length === 0 ? [] : [val.value, ...unfold(length - 1)(g)]\n  }\n}\n\nconst specialRelayCase = (s: S.State<BidContext, Constraint>) =>\n  pipe(s,\n    S.bindTo('constraint'),\n    S.apS('force', S.gets(forceO.getOption)),\n    S.apS('bid', S.gets(bidL.get)),\n    S.map(info =>\n      pipe(info.force,\n        O.chain(O.fromPredicate(force =>\n          info.constraint.type === \"Constant\" && !info.constraint.value && force.type === \"Relay\" && eqBid.equals(force.bid, info.bid))),\n        O.fold(() => info.constraint, constraintTrue))))\n  \nexport const satisfiesPath = (opener: Hand, responder: Hand) => (path: RNEA.ReadonlyNonEmptyArray<ConstrainedBid>) =>\n  pipe(\n    Gen.alternate(opener, responder),\n    Gen.unfold(path.length),\n    RA.zip(path),\n    S.traverseArray(([hand, info]) =>\n      pipe(\n        ofS(info.constraint),\n        S.chainFirst(() => S.modify(bidL.set(info.bid))),\n        specialRelayCase,\n        satisfiesS,\n        S.flap(hand),\n        S.chainFirst(() => S.modify(pathL.modify(RA.prepend(info.bid)))))),\n    S.map(RA.foldMap(boolean.MonoidAll)(identity)),\n    S.evaluate(zeroContext))","import { either, option, predicate, readonlyArray, readonlyNonEmptyArray, readonlyRecord, readonlySet, readonlyTuple, separated } from 'fp-ts';\nimport { observable, observableEither } from 'fp-ts-rxjs';\nimport { tailRec } from 'fp-ts/lib/ChainRec';\nimport { constFalse, constTrue, flow, pipe } from 'fp-ts/lib/function';\nimport { castDraft } from 'immer';\nimport { WritableDraft } from 'immer/dist/internal';\nimport memoize from 'proxy-memoize';\nimport { O } from 'ts-toolbelt';\n\nimport { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';\n\nimport { Board, deal } from '../model/bridge';\nimport { eqCard, Hand, newDeck, ordCardDescending } from '../model/deck';\nimport { getHcp } from '../model/evaluation';\nimport { DecodedHand, DecodedSerializedHand, decodedSerializedHandL, serializedDealL, SerializedHand, serializedHandL } from '../model/serialization';\nimport { Path, Paths } from '../model/system';\nimport { ConstrainedBid } from '../model/system/core';\nimport { satisfiesPath } from '../model/system/satisfaction';\nimport { decodeHand } from '../parse';\nimport { observeSolutions } from '../workers';\nimport { DoubleDummyResult } from '../workers/dds.worker';\n\nconst name = 'selection'\n\ninterface State {\n  selectedBlockKey: option.Option<string>\n  opener?: DecodedSerializedHand\n  responder?: DecodedSerializedHand\n  result?: DoubleDummyResult\n}\nexport type AuctionPositionType = O.SelectKeys<State, DecodedHand>\n\nconst initialState : State = {\n  selectedBlockKey: option.none\n}\n\ninterface Hands {\n  opener: SerializedHand\n  responder: SerializedHand\n}\n\nconst setHands = (state: WritableDraft<State>) => (hands: readonly [Hand, Hand]) => {\n  const [opener, responder] = hands\n  state.opener = pipe(opener, either.right, decodedSerializedHandL.get, castDraft)\n  state.responder = pipe(responder, either.right, decodedSerializedHandL.get, castDraft)\n}\n\nconst genBoardFromHands = (opener: Hand, responder: Hand) =>\n  pipe(newDeck(),\n    readonlyArray.difference(eqCard)(pipe(opener, readonlySet.toReadonlyArray(ordCardDescending))),\n    readonlyArray.difference(eqCard)(pipe(responder, readonlySet.toReadonlyArray(ordCardDescending))),\n    readonlyArray.chunksOf(13),\n    readonlyArray.map(readonlySet.fromReadonlyArray(eqCard)),\n    ([l, r]) : Board => ({\n      dealer: 'N',\n      deal: {\n        N: opener,\n        S: responder,\n        E: l,\n        W: r\n      }\n    }))\n\nconst getResult = createAsyncThunk<DoubleDummyResult, Hands, { rejectValue: string }>('abc', ({ opener, responder }, { rejectWithValue }) =>\n  pipe(\n    genBoardFromHands(serializedHandL.reverseGet(opener), serializedHandL.reverseGet(responder)).deal,\n    serializedDealL.get,\n    readonlyArray.of,\n    observeSolutions,\n    observableEither.map(flow(\n      readonlyRecord.toReadonlyArray,\n      readonlyArray.map(readonlyTuple.snd),\n      a => a[0])),\n    observable.map(either.getOrElseW(rejectWithValue)),\n    observable.toTask)\n  ())\n\nconst genUntilCondition = (limit: option.Option<number>) => (condition: predicate.Predicate<readonly [Hand, Hand]>) =>\n  tailRec(limit, l => {\n    if (pipe(l, option.fold(constFalse, i => i === 0))) {\n      return either.right(option.none)\n    } else {\n      const d = deal(newDeck())\n      const hands = [d.N, d.S] as const\n      const result = condition(hands)\n      return result\n        ? either.right(option.some(hands))\n        : either.left(pipe(l, option.map(i => i - 1)))\n    }\n  })\n\nconst genMatchingOf = (length: predicate.Predicate<number>) => (paths: Paths<ConstrainedBid>) =>\n  genUntilCondition(option.some(10000))(hands =>\n    pipe(paths,\n      readonlyArray.partition(satisfiesPath(...hands)),\n      separated.right,\n      x => length(x.length)))\n\nconst slice = createSlice({\n  name,\n  initialState,\n  reducers: {\n    setSelectedBlockKey: (state, action: PayloadAction<option.Option<string>>) => {\n      state.selectedBlockKey = action.payload\n    },\n    setHand: {\n      reducer: (state, action: PayloadAction<string, string, AuctionPositionType>) => {\n        state[action.meta] = pipe(action.payload, decodeHand, decodedSerializedHandL.get, castDraft)\n      },\n      prepare: (payload, meta) => ({ payload, meta })\n    },\n    genOnce: (state) => {\n      pipe(\n        genUntilCondition(option.none)(constTrue),\n        option.map(setHands(state)))\n    },\n    getHandsMatchingPath: (state, action: PayloadAction<Path<ConstrainedBid>>) => {\n      pipe(\n        genUntilCondition(option.some(10000))(hands =>\n          satisfiesPath(...hands)(action.payload)),\n        option.map(setHands(state)))\n    },\n    genHandsNotMatchingAnyOf: {\n      reducer: (state, action: PayloadAction<readonlyNonEmptyArray.ReadonlyNonEmptyArray<Path<ConstrainedBid>>, string, number>) => {\n        pipe(\n          genUntilCondition(option.some(10000))(hands =>\n            getHcp(hands[0]) >= action.meta\n            && pipe(action.payload, readonlyArray.every(predicate.not(satisfiesPath(...hands))))),\n          option.map(setHands(state)))\n      },\n      prepare: (payload: readonlyNonEmptyArray.ReadonlyNonEmptyArray<Path<ConstrainedBid>>, openerMinHcp: number) =>\n        ({ payload, meta: openerMinHcp })\n    },\n    genHandsMatchingExactlyOneOf: (state, action: PayloadAction<readonlyNonEmptyArray.ReadonlyNonEmptyArray<Path<ConstrainedBid>>>) => {\n      pipe(\n        genMatchingOf(l => l === 1)(action.payload),\n        option.map(setHands(state)))\n    },\n    genHandsMatchingMoreThanOneOf: (state, action: PayloadAction<readonlyNonEmptyArray.ReadonlyNonEmptyArray<Path<ConstrainedBid>>>) => {\n      pipe(\n        genMatchingOf(l => l > 1)(action.payload),\n        option.map(setHands(state)))\n    }\n  },\n  extraReducers: builder => builder\n    .addCase(getResult.fulfilled, (state, action) => {\n      state.result = pipe(action.payload, castDraft)\n    })\n  })\n\n\nexport const { setSelectedBlockKey, setHand, genOnce, getHandsMatchingPath, genHandsNotMatchingAnyOf, genHandsMatchingExactlyOneOf, genHandsMatchingMoreThanOneOf } = slice.actions\nexport { getResult };\n\nexport default slice.reducer\n\nexport const selectBlockKey = memoize((state: State) =>\n  pipe(state.selectedBlockKey,\n    option.toNullable))\n\nexport const selectHand = memoize(({ state, type } : {state: State, type: AuctionPositionType}) : option.Option<Hand> =>\n  pipe(state[type],\n    option.fromNullable,\n    option.chain(flow(decodedSerializedHandL.reverseGet, option.fromEither))))","import 'draft-js/dist/Draft.css';\n\nimport { ContentBlock, convertFromRaw, convertToRaw, Editor as DraftJsEditor, EditorState, getDefaultKeyBinding, RichUtils } from 'draft-js';\nimport { eq, monoid, option, ord, readonlyArray, readonlyNonEmptyArray, readonlySet, string } from 'fp-ts';\nimport { flow, pipe } from 'fp-ts/lib/function';\nimport { useCallback, useEffect, useState } from 'react';\nimport styled from 'styled-components';\n\nimport { useAppDispatch, useAppSelector } from '../app/hooks';\nimport { selectBlockKey, setSelectedBlockKey } from '../reducers/selection';\nimport { BlockItem, BlockKeyDescriptor, cacheSystemConstraints, removeConstraintsByBlockKey, setSystem } from '../reducers/system';\n\nconst EditorDiv = styled.div `\n  font-family: Cascadia Code, Consolas, monospace;\n  font-size: 0.8em;\n`\n\nconst getDescriptorFromContentBlock = (x: ContentBlock): BlockKeyDescriptor & BlockItem => ({\n  key: x.getKey(),\n  text: x.getText(),\n  depth: x.getDepth()\n})\n\nconst eqContentBlock = monoid.concatAll(eq.getMonoid<ContentBlock>())([\n  eq.contramap((b: ContentBlock) => b.getKey())(string.Eq),\n  eq.contramap((b: ContentBlock) => b.getText())(string.Eq)\n])\nconst getBlocks = (editorState: EditorState) => pipe(\n  editorState.getCurrentContent().getBlocksAsArray(),\n  readonlySet.fromReadonlyArray(eqContentBlock))\n\nconst Editor = () => {\n  const [editorState, setEditorState] = useState(() => EditorState.createEmpty())\n  const [blocks, setBlocks] = useState(() => getBlocks(editorState))\n  const dispatch = useAppDispatch()\n  const selectedBlockKey = useAppSelector(state => selectBlockKey(state.selection))\n\n  const onChange = useCallback((editorState: EditorState) => {\n    setEditorState(editorState)\n    setTimeout(() => localStorage.setItem(\"editor\", JSON.stringify(convertToRaw(editorState.getCurrentContent()))), 0)\n    const newBlocks = getBlocks(editorState)\n    const same = readonlySet.intersection(eqContentBlock)(blocks, newBlocks)\n    const removed = readonlySet.difference(eqContentBlock)(blocks, same)\n    const added = readonlySet.difference(eqContentBlock)(newBlocks, same)\n    setBlocks(newBlocks)\n\n    if (!readonlySet.isEmpty(monoid.concatAll(readonlySet.getUnionMonoid<ContentBlock>(eqContentBlock))([removed, added]))) {\n      dispatch(pipe(\n        newBlocks,\n        readonlySet.toReadonlyArray<ContentBlock>(ord.trivial),\n        readonlyArray.map(getDescriptorFromContentBlock),\n        setSystem))\n      pipe(\n        removed,\n        readonlySet.toReadonlyArray<ContentBlock>(ord.trivial),\n        readonlyNonEmptyArray.fromReadonlyArray,\n        option.map(flow(\n          readonlyNonEmptyArray.map(b => b.getKey()),\n          x => dispatch(removeConstraintsByBlockKey(x)))))\n      pipe(\n        added,\n        readonlySet.toReadonlyArray<ContentBlock>(ord.trivial),\n        readonlyNonEmptyArray.fromReadonlyArray,\n        option.map(flow(\n          readonlyNonEmptyArray.map(getDescriptorFromContentBlock),\n          x => dispatch(cacheSystemConstraints(x)))))\n    }\n    \n    const newSelectedBlockKey = editorState.getSelection().getFocusKey()\n    if (newSelectedBlockKey !== selectedBlockKey) {\n      dispatch(setSelectedBlockKey(option.some(newSelectedBlockKey)))\n    }\n  }, [blocks, dispatch, selectedBlockKey])\n\n  useEffect(() => {\n    const savedEditorState = localStorage.getItem(\"editor\")\n    if (savedEditorState) {\n      setEditorState(() => EditorState.createWithContent(convertFromRaw(JSON.parse(savedEditorState))))\n    } else {\n      setEditorState(() => RichUtils.toggleBlockType(editorState, 'unordered-list-item'))\n    }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [])\n  \n  return (\n    <EditorDiv>\n      <DraftJsEditor\n        editorState={editorState}\n        onChange={onChange}\n        // https://github.com/facebook/draft-js/blob/master/examples/draft-0-10-0/rich/rich.html#L61\n        keyBindingFn={e => {\n          if (e.keyCode === 9 /* TAB */) {\n            const newEditorState = RichUtils.onTab(e, editorState, 10, /* maxDepth */);\n            if (newEditorState !== editorState) {\n              onChange(newEditorState)\n            }\n            return null;\n          }\n          return getDefaultKeyBinding(e);\n        }}\n      />\n    </EditorDiv>\n  )\n}\n\nexport default Editor","import { option, readonlyArray as RA, these, tree as T } from 'fp-ts';\nimport { pipe } from 'fp-ts/lib/function';\nimport { draw } from 'io-ts/lib/Decoder';\nimport { Fragment, useMemo } from 'react';\nimport styled from 'styled-components';\n\nimport { useAppSelector } from '../app/hooks';\nimport { assertUnreachable } from '../lib';\nimport { Bid } from '../model/bridge';\nimport { serializedBidPathL } from '../model/serialization';\nimport { Forest } from '../model/system';\nimport { ExpandError } from '../model/system/expander';\nimport { SystemValidationError } from '../model/system/validation';\nimport { ErrorNode, selectErrorTree, selectPristineSystem, SystemErrorWithPath } from '../reducers/system';\nimport BidPath, { BidView } from './core/BidPath';\n\nconst GridContainer = styled.div `\n  clear: both;\n  display: inline-grid;\n  grid-template-columns: auto auto;\n  width: auto;\n`\n\ninterface ExpandErrorProps {\n  error: ExpandError\n}\nconst ExpandErrorView = ({ error }: ExpandErrorProps) =>\n  <span>{error.syntax.type}: {error.reason}</span>\n\ninterface ValidationErrorProps {\n  error: SystemValidationError\n}\nconst ValidationErrorView = ({ error }: ValidationErrorProps) => {\n  switch (error.type) {\n    case \"BidsOutOfOrder\": return <span>Bids <BidView bid={error.left.bid} /> and <BidView bid={error.right.bid} /> out of order</span>\n    case \"NoPrimarySuitDefined\": return <span>No primary suit defined for secondary suit {error.constraint.suit}</span>\n    case \"PrimarySuitAlreadyDefined\": return <span>Primary suit has already been defined</span>\n    case \"SamePrimaryAndSecondarySuit\": return <span>Primary and secondary suits cannot be the same</span>\n    case \"NoBidDefinedButStillForcing\": return <span>Bid is forcing, but no response is defined</span>\n    case \"PassWhileForcing\": return <span>Previous bid is forcing, but a pass was bid</span>\n    case \"SuitRangeInvalid\": return <span>Suit {error.constraint.suit} range {error.constraint.min}, {error.constraint.max} is invalid</span>\n    case \"PointRangeInvalid\": return <span>Point range {error.constraint.min}, {error.constraint.max} is invalid </span>\n    case \"SpecificShapeInvalid\": return <span>Specific shape {error.constraint.suits.S}{error.constraint.suits.H}{error.constraint.suits.D}{error.constraint.suits.C} is invalid</span>\n    case \"AnyShapeInvalid\": return <span>Shape {pipe(error.constraint.counts, RA.reduce(\"\", (cur, c) => cur + c))} is invalid</span>\n    default: return assertUnreachable(error)\n  }\n}\n\ninterface ErrorProps {\n  bid: Bid\n  errors: ReadonlyArray<SystemErrorWithPath>\n}\nconst BidErrorsView = ({ bid, errors }: ErrorProps) =>\n  <div>\n    {errors.map((e, i) => {\n      switch (e.type) {\n        case \"Syntax\": return <ExpandErrorView key={i} error={e.error} />\n        case \"Validation\": return <ValidationErrorView key={i} error={e.error} />\n        default: return assertUnreachable(e)\n      }\n    })}\n    {errors.length === 0 && \"none\"}\n  </div>\n\ninterface ErrorGridProps {\n  errors: ReadonlyArray<ErrorNode>\n}\nexport const ErrorGrid = ({ errors }: ErrorGridProps) =>\n  <GridContainer>\n    {errors.map(({ bid, path, errors }) => \n      <Fragment key={serializedBidPathL.get(path)}>\n        <BidPath path={path} />\n        <BidErrorsView bid={bid} errors={errors} />\n      </Fragment>\n    )}\n  </GridContainer>\n\ninterface ErrorForestProps {\n  forest: Forest<ErrorNode>\n}\nconst ErrorForest = ({ forest }: ErrorForestProps) => {\n  const flattenedForest = useMemo(() => pipe(forest, RA.chain(T.foldMap(RA.getMonoid<ErrorNode>())(RA.of))), [forest])\n  return <ErrorGrid errors={flattenedForest} />\n}\n\nconst Errors = () => {\n  const isPristine = useAppSelector(state => pipe(\n    selectPristineSystem({ state: state.system, options: state.settings }),\n    option.isSome))\n  const errors = useAppSelector(state => selectErrorTree({ state: state.system, options: state.settings }))\n  return (\n    <section>\n      <h3>Errors</h3>\n      {isPristine ? \"None\" : <>\n        {these.isLeft(errors) && <div>\n          <h4>Parse Errors</h4>\n          <ul>{errors.left.map((e, i) => <li key={i}><pre>{draw(e)}</pre></li>)}</ul>\n        </div>}\n        {these.isRight(errors) && <div>\n          <h4>Semantic Errors</h4>\n          <ErrorForest forest={errors.right} />\n        </div>}\n      </>}\n    </section>\n  )\n}\n\nexport default Errors","import { option as O } from 'fp-ts';\nimport { flow, pipe } from 'fp-ts/lib/function';\nimport { useCallback, useMemo } from 'react';\nimport TimeAgo from 'react-timeago';\nimport styled from 'styled-components';\n\nimport { useAppDispatch, useAppSelector } from '../app/hooks';\nimport { DateNumber, DateNumberB, estimatedTimeRemaining, getGenericProgress, JobId, now } from '../model/job';\nimport { removeJob, selectJobById, startJob } from '../reducers/generator';\n\ninterface DateViewProps {\n  date: O.Option<DateNumber> | DateNumber\n}\nconst DateView = ({ date }: DateViewProps) => {\n  const value =\n    typeof date === \"number\" ? date :\n    date._tag === \"Some\" ? date.value :\n    null\n  return <>{value && <TimeAgo date={(new Date(value))} />}</>\n}\n\nconst JobList = styled.ul `\n  display: flex;\n  flex-flow: row wrap;\n  list-style-type: none;\n  padding: 0px;\n  margin: 0px;\n`\nconst JobListItem = styled.li `\n  padding: 0px;\n  margin: 5px;\n`\n\ninterface JobViewProps {\n  jobId: JobId\n}\nconst JobView = ({ jobId }: JobViewProps) => {\n  const job = useAppSelector(state => pipe(selectJobById({ state: state.generator, jobId }), O.toNullable))\n  const progress = useMemo(() => pipe(\n    job,\n    O.fromNullable,\n    O.chain(getGenericProgress),\n    O.toNullable)\n    , [job])\n\n  const dispatch = useAppDispatch()\n  const onRemoveClick = useCallback(() => job && dispatch(removeJob(job.id)), [dispatch, job])\n  const onStartClick = useCallback(() => job && dispatch(startJob({ jobId: job.id, type: job.type.type })), [dispatch, job])\n  const timeRemaining = useMemo(() => pipe(\n    job,\n    O.fromNullable,\n    O.chain(estimatedTimeRemaining),\n    O.map(r => now() + r),\n    O.chain(flow(DateNumberB.decode, O.fromEither))),\n    [job])\n  return (<>{job &&\n    <JobListItem>\n      <h5>{job.type.type}</h5>\n      {!progress && <p>\n        Estimated Units: {job.unitsInitial} <br />\n        <button onClick={onStartClick}>Start</button>\n        <button onClick={onRemoveClick}>Remove</button>\n      </p>}\n      {progress && <p>\n        Started: <DateView date={job.startDate} /><br />\n        Last Updated: <DateView date={progress.updateDate} /> <br />\n        Progress: {job.unitsInitial - progress.unitsDone} units remaining ({Math.floor(progress.unitsDone * 100 / job.unitsInitial)}%) <br />\n        Est. Completion: <DateView date={timeRemaining} />\n      </p>}\n    </JobListItem>\n  }</>)\n}\n\nconst Jobs = () => {\n  const jobs = useAppSelector(state => state.generator.jobs)\n  return (\n    <section>\n      <h3>Jobs</h3>\n      <JobList>\n        {jobs.map(j => <JobView key={j.id} jobId={j.id} />)}\n      </JobList>\n    </section>\n  )\n}\n\nexport default Jobs","import { option, readonlyArray } from 'fp-ts';\nimport { pipe } from 'fp-ts/lib/function';\nimport JSONPretty from 'react-json-pretty';\n\nimport { useAppSelector } from '../app/hooks';\nimport { selectBidByKey, selectCompleteBidByKey, selectErrorsByKey } from '../reducers/system';\nimport { ErrorGrid } from './Errors';\n\nconst SelectionDetails = () => {\n  const selected = useAppSelector(state => state.selection.selectedBlockKey)\n  const syntacticBid = useAppSelector(state => pipe(selected,\n    option.chain(key => selectBidByKey({ state: state.system, key })),\n    option.toNullable))\n  const constrainedBid = useAppSelector(state => pipe(selected,\n    option.chain(key => selectCompleteBidByKey({ state: state.system, key })),\n    option.toNullable))\n  const errors = useAppSelector(state =>  pipe(selected,\n    option.fold(() => readonlyArray.empty, key => selectErrorsByKey({ state: state.system, key }))))\n\n  return (\n    <section>\n      {selected && <div>\n        <h3>Selection</h3>\n        {errors && <div>\n          <h4>Errors</h4>\n          <ErrorGrid errors={errors} />\n        </div>}\n        {syntacticBid && <div>\n          <h4>Syntax</h4>\n          <JSONPretty data={syntacticBid} />\n        </div>}\n        {constrainedBid && <div>\n          <h4>Constraint</h4>\n          <JSONPretty data={constrainedBid} />\n        </div>}\n      </div>}\n    </section>\n  )\n}\n\nexport default SelectionDetails","import { readonlyArray } from 'fp-ts';\nimport { pipe } from 'fp-ts/lib/function';\n\nimport { createSlice, PayloadAction } from '@reduxjs/toolkit';\n\ninterface State {\n  implicitPass: boolean\n  generateCount: number\n}\n\nconst initialState: State = {\n  implicitPass: false,\n  generateCount: 10000\n}\n\nconst name = 'settings'\nconst slice = createSlice({\n  name,\n  initialState,\n  reducers: {\n    setInitial: (state, action: PayloadAction<SettingsState>) => {\n      pipe(Object.keys(action.payload) as ReadonlyArray<keyof State>,\n        readonlyArray.map(p => (state as any)[p] = action.payload[p] as any))\n    },\n    setProperty: {\n      reducer: (state, action: PayloadAction<any, string, keyof State>) => {\n        (state as any)[action.meta] = action.payload\n      },\n      prepare: <K extends keyof State, V extends State[K]>(key: K, value: V) =>\n        ({ payload: value, meta: key })\n    }\n  }\n})\n\nexport const { setProperty: setSettingsProperty, setInitial: setInitialSettings } = slice.actions\nexport type SettingsState = State\nexport default slice.reducer","import { taskEither } from 'fp-ts';\nimport { constVoid, flow, pipe } from 'fp-ts/lib/function';\nimport { useCallback, useEffect } from 'react';\n\nimport { useAppDispatch, useAppSelector } from '../app/hooks';\nimport { setInitialSettings, setSettingsProperty, SettingsState } from '../reducers/settings';\nimport { deleteDb } from '../services/idb';\n\ninterface SettingsValueProps<K, V> {\n  label?: string\n  prop: K\n  parse: (value: string) => V\n  children?: (props: { value: V, onChange: (v: string) => void }) => JSX.Element\n  onChanged?: (v: V) => void\n}\nconst SettingsItem = <K extends keyof SettingsState>({ label, prop, parse, onChanged, children }: SettingsValueProps<K, SettingsState[K]>) => {\n  const value = useAppSelector(state => state.settings[prop])\n  const dispatch = useAppDispatch()\n  const onChange = useCallback((newValue: typeof value) => {\n    dispatch(setSettingsProperty(prop, newValue))\n    onChanged && onChanged(newValue)\n  }, [dispatch, onChanged, prop])\n  return (\n    <p>\n      <span>{label ?? prop}</span>\n      <span>{children\n        ? children({ value, onChange: flow(parse, onChange, constVoid) })\n        : <input type=\"text\" value={value.toString()} onChange={e => pipe(e.target.value, parse, onChange)} style={{width: \"100px\"}} />\n      }</span>\n    </p>\n  )\n}\n\nconst key = \"settings\"\nconst Settings = () => {\n  const settings = useAppSelector(state => state.settings)\n  const dispatch = useAppDispatch()\n  useEffect(() => {\n    const stored = localStorage.getItem(key)\n    if (stored !== null) {\n      const settings: SettingsState = JSON.parse(stored)\n      dispatch(setInitialSettings(settings))\n    }\n  }, [dispatch])\n  const onChanged = useCallback((prop: keyof SettingsState, value: SettingsState[typeof prop]) => {\n    const newSettings: SettingsState = {...settings, [prop]: value }\n    localStorage.setItem(key, JSON.stringify(newSettings))\n  }, [settings])\n  const onDeleteDatabaseClick = useCallback(() => pipe(\n    deleteDb,\n    taskEither.map(() => window.location.reload()))()\n  , [])\n  return (<>\n    <section>\n      <button onClick={onDeleteDatabaseClick}>Reset Analysis DB</button>\n    </section>\n    <section>\n      <SettingsItem label=\"Implicit Pass\" prop=\"implicitPass\" parse={s => s === \"true\"} onChanged={v => onChanged(\"implicitPass\", v)}>\n        {({ value, onChange}) =>\n          <input type=\"checkbox\" checked={value} onChange={e => onChange(e.target.checked.toString())} />\n      }</SettingsItem>\n      <SettingsItem label=\"Generate Count\" prop=\"generateCount\" parse={parseInt} onChanged={v => onChanged(\"generateCount\", v)} />\n    </section>\n    </>)\n}\n\nexport default Settings","import { option, readonlyArray } from 'fp-ts';\nimport { pipe } from 'fp-ts/lib/function';\nimport { ReadonlyNonEmptyArray } from 'fp-ts/lib/ReadonlyNonEmptyArray';\nimport memoize from 'proxy-memoize';\nimport { combineEpics } from 'redux-observable';\n\nimport { AnyAction } from '@reduxjs/toolkit';\n\nimport { RootState } from '../app/store';\nimport { ConstrainedBid } from '../model/system/core';\nimport { satisfiesPath } from '../model/system/satisfaction';\nimport generator, { epics as generatorEpics } from './generator';\nimport profile, { epics as profileEpics } from './profile';\nimport selection, { selectHand } from './selection';\nimport settings from './settings';\nimport system, { selectValidConstrainedBidPaths } from './system';\n\nconst reducers = {\n  system,\n  selection,\n  generator,\n  settings,\n  profile\n}\nexport default reducers\n\nexport const rootEpic = combineEpics<AnyAction, AnyAction, RootState>(\n  ...generatorEpics,\n  ...profileEpics\n)\n\ninterface BidResult {\n  path: ReadonlyNonEmptyArray<ConstrainedBid>\n  result: boolean\n}\n\nexport const selectPathsSatisfyHands = memoize((state: RootState) : ReadonlyArray<BidResult> | null =>\n  pipe(option.Do,\n    option.apS('opener', selectHand({ state: state.selection, type: 'opener' })),\n    option.apS('responder', selectHand({ state: state.selection, type: 'responder' })),\n    option.apS('paths', pipe(selectValidConstrainedBidPaths({ state: state.system, options: state.settings }))),\n    option.map(o => pipe(o.paths,\n      readonlyArray.map(path => ({\n        path,\n        result: satisfiesPath(o.opener, o.responder)(path)\n      })))),\n    option.toNullable))","import { either, option } from \"fp-ts\"\n\nimport { DecodeError } from \"io-ts/Decoder\"\nimport { draw } from \"io-ts/lib/Decoder\"\nimport { pipe } from \"fp-ts/lib/function\"\n\ninterface OptionProps<T> {\n  value: option.Option<T>\n  children: (value: T) => JSX.Element\n  onNone?: () => JSX.Element\n}\nexport const Option = <T extends {}>({value, children: onSuccess, onNone }: OptionProps<T>) => \n  pipe(value, option.fold(\n    () => onNone ? onNone() : <></>,\n    onSuccess))\n\ninterface DecodeProps<T> {\n  value: either.Either<DecodeError, T>\n  children: (value: T) => JSX.Element\n  onError?: (error: DecodeError) => JSX.Element\n}\nexport const Decode = <T extends {}>({value, children: onSuccess, onError }: DecodeProps<T>) => \n  pipe(value, either.fold(\n    e => onError ? onError(e) : <span>{draw(e)}</span>,\n    onSuccess))","import { option } from 'fp-ts';\nimport { pipe } from 'fp-ts/lib/function';\nimport { useState } from 'react';\n\nimport { useAppDispatch, useAppSelector } from '../app/hooks';\nimport { Paths } from '../model/system';\nimport { ConstrainedBid } from '../model/system/core';\nimport { genHandsMatchingExactlyOneOf, genHandsMatchingMoreThanOneOf, genHandsNotMatchingAnyOf, genOnce, getHandsMatchingPath } from '../reducers/selection';\nimport { selectCompleteBidPathUpToKey, selectValidConstrainedBidPaths } from '../reducers/system';\n\nconst GenerateOnce = () => {\n  const dispatch = useAppDispatch()\n  return (\n    <button type=\"button\" onClick={() => dispatch(genOnce())}>Random</button>\n  )\n}\n\ninterface GenerateSystemProps {\n  bidPaths: Paths<ConstrainedBid> | null\n}\n\nconst GenerateMatchZero = ({ bidPaths }: GenerateSystemProps) => {\n  const dispatch = useAppDispatch()\n  const [minHcp, setMinHcp] = useState<number>(11)\n  return <>\n    {bidPaths && <span>\n      <button type=\"button\" onClick={() => dispatch(genHandsNotMatchingAnyOf(bidPaths, minHcp))}>Zero</button>\n      Min HCP\n      <input type=\"number\" style={{width: 50}} value={minHcp} onChange={e => setMinHcp(parseInt(e.target.value))} />\n    </span>}\n  </>\n}\n\nconst GenerateMatchOne = ({ bidPaths }: GenerateSystemProps) => {\n  const dispatch = useAppDispatch()\n  return <>\n    {bidPaths && <span>\n      <button type=\"button\" onClick={() => dispatch(genHandsMatchingExactlyOneOf(bidPaths))}>One</button>\n    </span>}\n  </>\n}\n\nconst GenerateMatchMany = ({ bidPaths }: GenerateSystemProps) => {\n  const dispatch = useAppDispatch()\n  return <>\n    {bidPaths && <span>\n      <button type=\"button\" onClick={() => dispatch(genHandsMatchingMoreThanOneOf(bidPaths))}>Many</button>\n    </span>}\n  </>\n}\n\nconst GenerateMatchSelected = () => {\n  const selected = useAppSelector(state => state.selection.selectedBlockKey)\n  const bidPath = useAppSelector(state => pipe(selected,\n    option.chain(key => selectCompleteBidPathUpToKey({ state: state.system, key })),\n    option.toNullable))\n  const dispatch = useAppDispatch()\n  return <>\n    {bidPath && <button type=\"button\" onClick={() => dispatch(getHandsMatchingPath(bidPath))}>Selected</button>}\n  </>\n}\n\nconst SelectionGenerators = () => {\n  const bidPaths = useAppSelector(state =>\n    pipe(selectValidConstrainedBidPaths({ state: state.system, options: state.settings }),\n      option.toNullable))\n  return (\n    <section>\n      <h4>Generate Hands</h4>\n      <GenerateOnce />\n      <GenerateMatchSelected />\n      <GenerateMatchZero bidPaths={bidPaths} />\n      <GenerateMatchOne bidPaths={bidPaths} />\n      <GenerateMatchMany bidPaths={bidPaths} />\n    </section>)\n}\n\nexport default SelectionGenerators","import { option, readonlyRecord } from 'fp-ts';\nimport { constVoid, flow, pipe } from 'fp-ts/lib/function';\nimport { useCallback, useEffect, useState } from 'react';\nimport styled from 'styled-components';\n\nimport { useAppDispatch, useAppSelector } from '../app/hooks';\nimport { serializedHandL } from '../model/serialization';\nimport { handE } from '../parse/hand';\nimport { AuctionPositionType, getResult, selectHand, setHand } from '../reducers/selection';\nimport DoubleDummyResultView from './core/DoubleDummyResultView';\nimport HandView from './core/HandView';\nimport { Option } from './core/Monad';\nimport SelectionGenerators from './SelectionGenerators';\n\ninterface HandInputProps {\n  type: AuctionPositionType\n}\nconst HandInput = ({ type }: HandInputProps) => {\n  const dispatch = useAppDispatch()\n  const [value, setValue] = useState<string>(\"\")\n  const storageKey = `hand.${type}`\n\n  const encodedHand = useAppSelector(state => pipe(\n    selectHand({ state: state.selection, type }),\n    option.map(handE.encode),\n    option.toNullable))\n\n  const onSetHand = useCallback((hand: string) => {\n    setValue(hand)\n    dispatch(setHand(hand, type))\n  }, [dispatch, type])\n\n  useEffect(() => {\n    const savedHand = localStorage.getItem(storageKey)\n    if (savedHand) {\n      onSetHand(savedHand)\n    }\n  }, [onSetHand, storageKey, type])\n\n  return <input type=\"text\" placeholder=\"AKQJ.T987.654.32\" value={encodedHand ?? value} onChange={e => onSetHand(e.target.value)} onBlur={() => localStorage.setItem(storageKey, value)} />\n}\n\nconst HandCol = styled.th `\n  width: 15em;\n`\n\nconst HandEditor = () => {\n  const dispatch = useAppDispatch()\n  const [o, r] = [\n    useAppSelector(state => selectHand({ state: state.selection, type: 'opener' })),\n    useAppSelector(state => selectHand({ state: state.selection, type: 'responder' }))\n  ]\n  const getResultCallback = useCallback(() => pipe(\n    option.Do,\n    option.apS('opener', o),\n    option.apS('responder', r),\n    option.map(flow(\n      readonlyRecord.map(serializedHandL.get),\n      getResult,\n      dispatch)),\n    constVoid), [dispatch, o, r])\n\n  const result = useAppSelector(state => state.selection.result)\n  \n  return (\n    <>\n      <table>\n        <thead>\n          <tr>\n            <HandCol>Opener</HandCol>\n            <HandCol>Responder</HandCol>\n          </tr>\n        </thead>\n        <tbody>\n          <tr>\n            <td><HandInput type=\"opener\" /></td>\n            <td><HandInput type=\"responder\" /></td>\n          </tr>\n          <tr>\n            <td><Option value={o}>{hand => <HandView hand={hand} />}</Option></td>\n            <td><Option value={r}>{hand => <HandView hand={hand} />}</Option></td>\n          </tr>\n        </tbody>\n      </table>\n      <SelectionGenerators />\n      <p>\n        <button type=\"button\" onClick={getResultCallback}>Solution</button> \n        {result && <DoubleDummyResultView result={result} /> }\n      </p>\n    </>\n  )\n}\n\nexport default HandEditor","import { useAppSelector } from '../app/hooks';\nimport { selectPathsSatisfyHands } from '../reducers';\nimport BidPath from './core/BidPath';\nimport HandEditor from './HandEditor';\n\nconst TestHands = () => {\n  const results = useAppSelector(selectPathsSatisfyHands)\n  return (\n    <section>\n      <h3>Test Hands</h3>\n      <HandEditor />\n      {results !== null && <div>\n        <h4>Results</h4>\n        <ul>\n          {results.map((r, i) => <li key={i}>\n            <BidPath path={r.path.map(p => p.bid)} />\n            : &nbsp;\n            <span>{r.result.toString()}</span>\n          </li>)}\n        </ul>\n      </div>}\n    </section>\n  )\n}\n\nexport default TestHands","import Analyses from './Analyses';\nimport Editor from './Editor';\nimport Errors from './Errors';\nimport Jobs from './Jobs';\nimport SelectionDetails from './SelectionDetails';\n// import SelectionDetails from './SelectionDetails';\nimport Settings from './Settings';\n// import Stats from './Stats';\n// import SystemDetails from './SystemDetails';\nimport TestHands from './TestHands';\n\nconst App = () => {\n  return (\n    <div className=\"App\">\n      <div style={{display: \"inline-block\", width: '50%'}}>\n        <div style={{float: \"left\"}}>\n          <Editor />\n        </div>\n        <div style={{float: \"right\", width: \"300px\"}}>\n          <Settings />\n        </div>\n        <div style={{clear: \"both\"}}>\n          <Errors />\n          <Jobs />\n          <Analyses />\n          {/* <Stats /> */}\n        </div>\n      </div>\n      <div style={{display: \"inline-block\", width: '50%', float: \"right\"}}>\n        <div style={{display: \"inline-block\", float: 'right'}}>\n          <a target=\"_blank\" rel=\"noreferrer\" href=\"https://github.com/kdblocher/bridge#documentation\">Documentation</a>\n          &nbsp;|&nbsp;\n          <a target=\"_blank\" rel=\"noreferrer\" href=\"https://github.com/kdblocher/bridge/discussions\">Share ideas</a>\n          &nbsp;|&nbsp;\n          <a target=\"_blank\" rel=\"noreferrer\" href=\"https://github.com/kdblocher/bridge/issues/new\">Report issue</a>\n        </div>\n        <TestHands />\n        {/* <SystemDetails /> */}\n        <SelectionDetails />\n      </div>\n    </div>\n  )\n}\n\nexport default App\n","import { Action, AnyAction, ThunkAction, configureStore } from '@reduxjs/toolkit';\nimport reducer, { rootEpic } from '../reducers';\n\nimport { createEpicMiddleware } from 'redux-observable';\n\ntype R = typeof reducer\nexport type RootState = { [K in keyof R]: ReturnType<R[K]> }\n\nconst epicMiddleware = createEpicMiddleware<AnyAction, AnyAction, RootState>()\nexport const store = configureStore({\n  reducer: reducer,\n  middleware: (getDefaultMiddleware => [...getDefaultMiddleware(), epicMiddleware])\n})\nepicMiddleware.run(rootEpic)\n\nexport type AppDispatch = typeof store.dispatch;\nexport type AppThunk<ReturnType = void> = ThunkAction<\n  ReturnType,\n  RootState,\n  unknown,\n  Action<string>\n>;","import './index.css';\n\nimport * as serviceWorker from './serviceWorker';\n\nimport App from './components';\nimport { Provider } from 'react-redux';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { store } from './app/store';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}