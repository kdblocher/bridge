/* AutoGenerated Code, changes may be overwritten
* INPUT GRAMMAR:
* Rule := level=Digit bid=BidSpecifier ': ' restrictions=RestrictionList $
* BidSpecifier := Wildcard | SuitSpecifier
* Wildcard := 'x'
* SuitSpecifier := Major | Minor | Strain
* Major := 'M'
* Minor := 'm'
* Strain := Suit | Notrump
* Suit := Club | Diamond | Heart | Spade
* Club := '[Cc♣♧]'
* Diamond := '[Dd♦♢]'
* Heart := '[Hh♥♡]'
* Spade := '[Ss♠♤]'
* Notrump := '[Nn]' '[Tt]'?
* RestrictionList := RestrictionListItem+
* RestrictionListItem := restriction=Restriction ' '?
* Restriction := RestrictionGroup | RestrictionOr | SuitRange | SuitBound | PointRange | PointBound | Distribution | Response 
* RestrictionOr := left=Restriction {' or ' | ' / '} right=Restriction
* RestrictionGroup := '\(' RestrictionList '\)'
* PointRange := lower=Number '-' upper=Number
* PointBound := value=Number qualifier=BoundQualifier
* SuitRange := lower=Digit '-' upper=Digit suit=SuitRangeSpecifier
* SuitBound := value=Number qualifier=BoundQualifier suit=SuitRangeSpecifier
* SuitRangeSpecifier := Major | Minor | OtherMajor | OtherMinor | Strain
* OtherMajor := 'oM'
* OtherMinor := 'om'
* BoundQualifier := Plus | Minus | Equals
* Plus := '\+'
* Minus := '\-'
* Equals := '=' | ''
* Distribution := Balanced | Unbalanced | Shape
* Balanced := 'BAL'
* Unbalanced := 'unBAL'
* Shape := s=Digit h=Digit d=Digit c=Digit
* Response := ForceOneRound | ForceGame | ForceSlam | Puppet
* ForceOneRound := 'F1'
* ForceGame := 'FG'
* ForceSlam := 'FS'
* Puppet := level=Number strain=Strain
* Digit := literal='[0-9]'
*   .value = number { return parseInt(literal) }
* Number := literal='[0-9]+'
*   .value = number { return parseInt(literal) }
*/
type Nullable<T> = T | null;
type $$RuleType<T> = () => Nullable<T>;
interface ASTNodeIntf {
    kind: ASTKinds;
}
export enum ASTKinds {
    Rule = "Rule",
    BidSpecifier_1 = "BidSpecifier_1",
    BidSpecifier_2 = "BidSpecifier_2",
    Wildcard = "Wildcard",
    SuitSpecifier_1 = "SuitSpecifier_1",
    SuitSpecifier_2 = "SuitSpecifier_2",
    SuitSpecifier_3 = "SuitSpecifier_3",
    Major = "Major",
    Minor = "Minor",
    Strain_1 = "Strain_1",
    Strain_2 = "Strain_2",
    Suit_1 = "Suit_1",
    Suit_2 = "Suit_2",
    Suit_3 = "Suit_3",
    Suit_4 = "Suit_4",
    Club = "Club",
    Diamond = "Diamond",
    Heart = "Heart",
    Spade = "Spade",
    Notrump = "Notrump",
    RestrictionList = "RestrictionList",
    RestrictionListItem = "RestrictionListItem",
    Restriction_1 = "Restriction_1",
    Restriction_2 = "Restriction_2",
    Restriction_3 = "Restriction_3",
    Restriction_4 = "Restriction_4",
    Restriction_5 = "Restriction_5",
    Restriction_6 = "Restriction_6",
    Restriction_7 = "Restriction_7",
    Restriction_8 = "Restriction_8",
    RestrictionOr = "RestrictionOr",
    RestrictionOr_$0_1 = "RestrictionOr_$0_1",
    RestrictionOr_$0_2 = "RestrictionOr_$0_2",
    RestrictionGroup = "RestrictionGroup",
    PointRange = "PointRange",
    PointBound = "PointBound",
    SuitRange = "SuitRange",
    SuitBound = "SuitBound",
    SuitRangeSpecifier_1 = "SuitRangeSpecifier_1",
    SuitRangeSpecifier_2 = "SuitRangeSpecifier_2",
    SuitRangeSpecifier_3 = "SuitRangeSpecifier_3",
    SuitRangeSpecifier_4 = "SuitRangeSpecifier_4",
    SuitRangeSpecifier_5 = "SuitRangeSpecifier_5",
    OtherMajor = "OtherMajor",
    OtherMinor = "OtherMinor",
    BoundQualifier_1 = "BoundQualifier_1",
    BoundQualifier_2 = "BoundQualifier_2",
    BoundQualifier_3 = "BoundQualifier_3",
    Plus = "Plus",
    Minus = "Minus",
    Equals_1 = "Equals_1",
    Equals_2 = "Equals_2",
    Distribution_1 = "Distribution_1",
    Distribution_2 = "Distribution_2",
    Distribution_3 = "Distribution_3",
    Balanced = "Balanced",
    Unbalanced = "Unbalanced",
    Shape = "Shape",
    Response_1 = "Response_1",
    Response_2 = "Response_2",
    Response_3 = "Response_3",
    Response_4 = "Response_4",
    ForceOneRound = "ForceOneRound",
    ForceGame = "ForceGame",
    ForceSlam = "ForceSlam",
    Puppet = "Puppet",
    Digit = "Digit",
    Number = "Number",
    $EOF = "$EOF",
}
export interface Rule {
    kind: ASTKinds.Rule;
    level: Digit;
    bid: BidSpecifier;
    restrictions: RestrictionList;
}
export type BidSpecifier = BidSpecifier_1 | BidSpecifier_2;
export type BidSpecifier_1 = Wildcard;
export type BidSpecifier_2 = SuitSpecifier;
export type Wildcard = string;
export type SuitSpecifier = SuitSpecifier_1 | SuitSpecifier_2 | SuitSpecifier_3;
export type SuitSpecifier_1 = Major;
export type SuitSpecifier_2 = Minor;
export type SuitSpecifier_3 = Strain;
export type Major = string;
export type Minor = string;
export type Strain = Strain_1 | Strain_2;
export type Strain_1 = Suit;
export type Strain_2 = Notrump;
export type Suit = Suit_1 | Suit_2 | Suit_3 | Suit_4;
export type Suit_1 = Club;
export type Suit_2 = Diamond;
export type Suit_3 = Heart;
export type Suit_4 = Spade;
export type Club = string;
export type Diamond = string;
export type Heart = string;
export type Spade = string;
export interface Notrump {
    kind: ASTKinds.Notrump;
}
export type RestrictionList = RestrictionListItem[];
export interface RestrictionListItem {
    kind: ASTKinds.RestrictionListItem;
    restriction: Restriction;
}
export type Restriction = Restriction_1 | Restriction_2 | Restriction_3 | Restriction_4 | Restriction_5 | Restriction_6 | Restriction_7 | Restriction_8;
export type Restriction_1 = RestrictionGroup;
export type Restriction_2 = RestrictionOr;
export type Restriction_3 = SuitRange;
export type Restriction_4 = SuitBound;
export type Restriction_5 = PointRange;
export type Restriction_6 = PointBound;
export type Restriction_7 = Distribution;
export type Restriction_8 = Response;
export interface RestrictionOr {
    kind: ASTKinds.RestrictionOr;
    left: Restriction;
    right: Restriction;
}
export type RestrictionOr_$0 = RestrictionOr_$0_1 | RestrictionOr_$0_2;
export type RestrictionOr_$0_1 = string;
export type RestrictionOr_$0_2 = string;
export interface RestrictionGroup {
    kind: ASTKinds.RestrictionGroup;
}
export interface PointRange {
    kind: ASTKinds.PointRange;
    lower: Number;
    upper: Number;
}
export interface PointBound {
    kind: ASTKinds.PointBound;
    value: Number;
    qualifier: BoundQualifier;
}
export interface SuitRange {
    kind: ASTKinds.SuitRange;
    lower: Digit;
    upper: Digit;
    suit: SuitRangeSpecifier;
}
export interface SuitBound {
    kind: ASTKinds.SuitBound;
    value: Number;
    qualifier: BoundQualifier;
    suit: SuitRangeSpecifier;
}
export type SuitRangeSpecifier = SuitRangeSpecifier_1 | SuitRangeSpecifier_2 | SuitRangeSpecifier_3 | SuitRangeSpecifier_4 | SuitRangeSpecifier_5;
export type SuitRangeSpecifier_1 = Major;
export type SuitRangeSpecifier_2 = Minor;
export type SuitRangeSpecifier_3 = OtherMajor;
export type SuitRangeSpecifier_4 = OtherMinor;
export type SuitRangeSpecifier_5 = Strain;
export type OtherMajor = string;
export type OtherMinor = string;
export type BoundQualifier = BoundQualifier_1 | BoundQualifier_2 | BoundQualifier_3;
export type BoundQualifier_1 = Plus;
export type BoundQualifier_2 = Minus;
export type BoundQualifier_3 = Equals;
export type Plus = string;
export type Minus = string;
export type Equals = Equals_1 | Equals_2;
export type Equals_1 = string;
export type Equals_2 = string;
export type Distribution = Distribution_1 | Distribution_2 | Distribution_3;
export type Distribution_1 = Balanced;
export type Distribution_2 = Unbalanced;
export type Distribution_3 = Shape;
export type Balanced = string;
export type Unbalanced = string;
export interface Shape {
    kind: ASTKinds.Shape;
    s: Digit;
    h: Digit;
    d: Digit;
    c: Digit;
}
export type Response = Response_1 | Response_2 | Response_3 | Response_4;
export type Response_1 = ForceOneRound;
export type Response_2 = ForceGame;
export type Response_3 = ForceSlam;
export type Response_4 = Puppet;
export type ForceOneRound = string;
export type ForceGame = string;
export type ForceSlam = string;
export interface Puppet {
    kind: ASTKinds.Puppet;
    level: Number;
    strain: Strain;
}
export class Digit {
    public kind: ASTKinds.Digit = ASTKinds.Digit;
    public literal: string;
    public value: number;
    constructor(literal: string){
        this.literal = literal;
        this.value = ((): number => {
        return parseInt(literal)
        })();
    }
}
export class Number {
    public kind: ASTKinds.Number = ASTKinds.Number;
    public literal: string;
    public value: number;
    constructor(literal: string){
        this.literal = literal;
        this.value = ((): number => {
        return parseInt(literal)
        })();
    }
}
export class Parser {
    private readonly input: string;
    private pos: PosInfo;
    private negating: boolean = false;
    private memoSafe: boolean = true;
    constructor(input: string) {
        this.pos = {overallPos: 0, line: 1, offset: 0};
        this.input = input;
    }
    public reset(pos: PosInfo) {
        this.pos = pos;
    }
    public finished(): boolean {
        return this.pos.overallPos === this.input.length;
    }
    public clearMemos(): void {
        this.$scope$Restriction$memo.clear();
    }
    protected $scope$Restriction$memo: Map<number, [Nullable<Restriction>, PosInfo]> = new Map();
    public matchRule($$dpth: number, $$cr?: ErrorTracker): Nullable<Rule> {
        return this.run<Rule>($$dpth,
            () => {
                let $scope$level: Nullable<Digit>;
                let $scope$bid: Nullable<BidSpecifier>;
                let $scope$restrictions: Nullable<RestrictionList>;
                let $$res: Nullable<Rule> = null;
                if (true
                    && ($scope$level = this.matchDigit($$dpth + 1, $$cr)) !== null
                    && ($scope$bid = this.matchBidSpecifier($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:: )`, $$dpth + 1, $$cr) !== null
                    && ($scope$restrictions = this.matchRestrictionList($$dpth + 1, $$cr)) !== null
                    && this.match$EOF($$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.Rule, level: $scope$level, bid: $scope$bid, restrictions: $scope$restrictions};
                }
                return $$res;
            });
    }
    public matchBidSpecifier($$dpth: number, $$cr?: ErrorTracker): Nullable<BidSpecifier> {
        return this.choice<BidSpecifier>([
            () => this.matchBidSpecifier_1($$dpth + 1, $$cr),
            () => this.matchBidSpecifier_2($$dpth + 1, $$cr),
        ]);
    }
    public matchBidSpecifier_1($$dpth: number, $$cr?: ErrorTracker): Nullable<BidSpecifier_1> {
        return this.matchWildcard($$dpth + 1, $$cr);
    }
    public matchBidSpecifier_2($$dpth: number, $$cr?: ErrorTracker): Nullable<BidSpecifier_2> {
        return this.matchSuitSpecifier($$dpth + 1, $$cr);
    }
    public matchWildcard($$dpth: number, $$cr?: ErrorTracker): Nullable<Wildcard> {
        return this.regexAccept(String.raw`(?:x)`, $$dpth + 1, $$cr);
    }
    public matchSuitSpecifier($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitSpecifier> {
        return this.choice<SuitSpecifier>([
            () => this.matchSuitSpecifier_1($$dpth + 1, $$cr),
            () => this.matchSuitSpecifier_2($$dpth + 1, $$cr),
            () => this.matchSuitSpecifier_3($$dpth + 1, $$cr),
        ]);
    }
    public matchSuitSpecifier_1($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitSpecifier_1> {
        return this.matchMajor($$dpth + 1, $$cr);
    }
    public matchSuitSpecifier_2($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitSpecifier_2> {
        return this.matchMinor($$dpth + 1, $$cr);
    }
    public matchSuitSpecifier_3($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitSpecifier_3> {
        return this.matchStrain($$dpth + 1, $$cr);
    }
    public matchMajor($$dpth: number, $$cr?: ErrorTracker): Nullable<Major> {
        return this.regexAccept(String.raw`(?:M)`, $$dpth + 1, $$cr);
    }
    public matchMinor($$dpth: number, $$cr?: ErrorTracker): Nullable<Minor> {
        return this.regexAccept(String.raw`(?:m)`, $$dpth + 1, $$cr);
    }
    public matchStrain($$dpth: number, $$cr?: ErrorTracker): Nullable<Strain> {
        return this.choice<Strain>([
            () => this.matchStrain_1($$dpth + 1, $$cr),
            () => this.matchStrain_2($$dpth + 1, $$cr),
        ]);
    }
    public matchStrain_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Strain_1> {
        return this.matchSuit($$dpth + 1, $$cr);
    }
    public matchStrain_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Strain_2> {
        return this.matchNotrump($$dpth + 1, $$cr);
    }
    public matchSuit($$dpth: number, $$cr?: ErrorTracker): Nullable<Suit> {
        return this.choice<Suit>([
            () => this.matchSuit_1($$dpth + 1, $$cr),
            () => this.matchSuit_2($$dpth + 1, $$cr),
            () => this.matchSuit_3($$dpth + 1, $$cr),
            () => this.matchSuit_4($$dpth + 1, $$cr),
        ]);
    }
    public matchSuit_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Suit_1> {
        return this.matchClub($$dpth + 1, $$cr);
    }
    public matchSuit_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Suit_2> {
        return this.matchDiamond($$dpth + 1, $$cr);
    }
    public matchSuit_3($$dpth: number, $$cr?: ErrorTracker): Nullable<Suit_3> {
        return this.matchHeart($$dpth + 1, $$cr);
    }
    public matchSuit_4($$dpth: number, $$cr?: ErrorTracker): Nullable<Suit_4> {
        return this.matchSpade($$dpth + 1, $$cr);
    }
    public matchClub($$dpth: number, $$cr?: ErrorTracker): Nullable<Club> {
        return this.regexAccept(String.raw`(?:[Cc♣♧])`, $$dpth + 1, $$cr);
    }
    public matchDiamond($$dpth: number, $$cr?: ErrorTracker): Nullable<Diamond> {
        return this.regexAccept(String.raw`(?:[Dd♦♢])`, $$dpth + 1, $$cr);
    }
    public matchHeart($$dpth: number, $$cr?: ErrorTracker): Nullable<Heart> {
        return this.regexAccept(String.raw`(?:[Hh♥♡])`, $$dpth + 1, $$cr);
    }
    public matchSpade($$dpth: number, $$cr?: ErrorTracker): Nullable<Spade> {
        return this.regexAccept(String.raw`(?:[Ss♠♤])`, $$dpth + 1, $$cr);
    }
    public matchNotrump($$dpth: number, $$cr?: ErrorTracker): Nullable<Notrump> {
        return this.run<Notrump>($$dpth,
            () => {
                let $$res: Nullable<Notrump> = null;
                if (true
                    && this.regexAccept(String.raw`(?:[Nn])`, $$dpth + 1, $$cr) !== null
                    && ((this.regexAccept(String.raw`(?:[Tt])`, $$dpth + 1, $$cr)) || true)
                ) {
                    $$res = {kind: ASTKinds.Notrump, };
                }
                return $$res;
            });
    }
    public matchRestrictionList($$dpth: number, $$cr?: ErrorTracker): Nullable<RestrictionList> {
        return this.loop<RestrictionListItem>(() => this.matchRestrictionListItem($$dpth + 1, $$cr), false);
    }
    public matchRestrictionListItem($$dpth: number, $$cr?: ErrorTracker): Nullable<RestrictionListItem> {
        return this.run<RestrictionListItem>($$dpth,
            () => {
                let $scope$restriction: Nullable<Restriction>;
                let $$res: Nullable<RestrictionListItem> = null;
                if (true
                    && ($scope$restriction = this.matchRestriction($$dpth + 1, $$cr)) !== null
                    && ((this.regexAccept(String.raw`(?: )`, $$dpth + 1, $$cr)) || true)
                ) {
                    $$res = {kind: ASTKinds.RestrictionListItem, restriction: $scope$restriction};
                }
                return $$res;
            });
    }
    public matchRestriction($$dpth: number, $$cr?: ErrorTracker): Nullable<Restriction> {
        const fn = () => {
            return this.choice<Restriction>([
                () => this.matchRestriction_1($$dpth + 1, $$cr),
                () => this.matchRestriction_2($$dpth + 1, $$cr),
                () => this.matchRestriction_3($$dpth + 1, $$cr),
                () => this.matchRestriction_4($$dpth + 1, $$cr),
                () => this.matchRestriction_5($$dpth + 1, $$cr),
                () => this.matchRestriction_6($$dpth + 1, $$cr),
                () => this.matchRestriction_7($$dpth + 1, $$cr),
                () => this.matchRestriction_8($$dpth + 1, $$cr),
            ]);
        };
        const $scope$pos = this.mark();
        const memo = this.$scope$Restriction$memo.get($scope$pos.overallPos);
        if(memo !== undefined) {
            this.reset(memo[1]);
            return memo[0];
        }
        const $scope$oldMemoSafe = this.memoSafe;
        this.memoSafe = false;
        this.$scope$Restriction$memo.set($scope$pos.overallPos, [null, $scope$pos]);
        let lastRes: Nullable<Restriction> = null;
        let lastPos: PosInfo = $scope$pos;
        for(;;) {
            this.reset($scope$pos);
            const res = fn();
            const end = this.mark();
            if(end.overallPos <= lastPos.overallPos)
                break;
            lastRes = res;
            lastPos = end;
            this.$scope$Restriction$memo.set($scope$pos.overallPos, [lastRes, lastPos]);
        }
        this.reset(lastPos);
        this.memoSafe = $scope$oldMemoSafe;
        return lastRes;
    }
    public matchRestriction_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Restriction_1> {
        return this.matchRestrictionGroup($$dpth + 1, $$cr);
    }
    public matchRestriction_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Restriction_2> {
        return this.matchRestrictionOr($$dpth + 1, $$cr);
    }
    public matchRestriction_3($$dpth: number, $$cr?: ErrorTracker): Nullable<Restriction_3> {
        return this.matchSuitRange($$dpth + 1, $$cr);
    }
    public matchRestriction_4($$dpth: number, $$cr?: ErrorTracker): Nullable<Restriction_4> {
        return this.matchSuitBound($$dpth + 1, $$cr);
    }
    public matchRestriction_5($$dpth: number, $$cr?: ErrorTracker): Nullable<Restriction_5> {
        return this.matchPointRange($$dpth + 1, $$cr);
    }
    public matchRestriction_6($$dpth: number, $$cr?: ErrorTracker): Nullable<Restriction_6> {
        return this.matchPointBound($$dpth + 1, $$cr);
    }
    public matchRestriction_7($$dpth: number, $$cr?: ErrorTracker): Nullable<Restriction_7> {
        return this.matchDistribution($$dpth + 1, $$cr);
    }
    public matchRestriction_8($$dpth: number, $$cr?: ErrorTracker): Nullable<Restriction_8> {
        return this.matchResponse($$dpth + 1, $$cr);
    }
    public matchRestrictionOr($$dpth: number, $$cr?: ErrorTracker): Nullable<RestrictionOr> {
        return this.run<RestrictionOr>($$dpth,
            () => {
                let $scope$left: Nullable<Restriction>;
                let $scope$right: Nullable<Restriction>;
                let $$res: Nullable<RestrictionOr> = null;
                if (true
                    && ($scope$left = this.matchRestriction($$dpth + 1, $$cr)) !== null
                    && this.matchRestrictionOr_$0($$dpth + 1, $$cr) !== null
                    && ($scope$right = this.matchRestriction($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.RestrictionOr, left: $scope$left, right: $scope$right};
                }
                return $$res;
            });
    }
    public matchRestrictionOr_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<RestrictionOr_$0> {
        return this.choice<RestrictionOr_$0>([
            () => this.matchRestrictionOr_$0_1($$dpth + 1, $$cr),
            () => this.matchRestrictionOr_$0_2($$dpth + 1, $$cr),
        ]);
    }
    public matchRestrictionOr_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<RestrictionOr_$0_1> {
        return this.regexAccept(String.raw`(?: or )`, $$dpth + 1, $$cr);
    }
    public matchRestrictionOr_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<RestrictionOr_$0_2> {
        return this.regexAccept(String.raw`(?: / )`, $$dpth + 1, $$cr);
    }
    public matchRestrictionGroup($$dpth: number, $$cr?: ErrorTracker): Nullable<RestrictionGroup> {
        return this.run<RestrictionGroup>($$dpth,
            () => {
                let $$res: Nullable<RestrictionGroup> = null;
                if (true
                    && this.regexAccept(String.raw`(?:\()`, $$dpth + 1, $$cr) !== null
                    && this.matchRestrictionList($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:\))`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.RestrictionGroup, };
                }
                return $$res;
            });
    }
    public matchPointRange($$dpth: number, $$cr?: ErrorTracker): Nullable<PointRange> {
        return this.run<PointRange>($$dpth,
            () => {
                let $scope$lower: Nullable<Number>;
                let $scope$upper: Nullable<Number>;
                let $$res: Nullable<PointRange> = null;
                if (true
                    && ($scope$lower = this.matchNumber($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:-)`, $$dpth + 1, $$cr) !== null
                    && ($scope$upper = this.matchNumber($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.PointRange, lower: $scope$lower, upper: $scope$upper};
                }
                return $$res;
            });
    }
    public matchPointBound($$dpth: number, $$cr?: ErrorTracker): Nullable<PointBound> {
        return this.run<PointBound>($$dpth,
            () => {
                let $scope$value: Nullable<Number>;
                let $scope$qualifier: Nullable<BoundQualifier>;
                let $$res: Nullable<PointBound> = null;
                if (true
                    && ($scope$value = this.matchNumber($$dpth + 1, $$cr)) !== null
                    && ($scope$qualifier = this.matchBoundQualifier($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.PointBound, value: $scope$value, qualifier: $scope$qualifier};
                }
                return $$res;
            });
    }
    public matchSuitRange($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitRange> {
        return this.run<SuitRange>($$dpth,
            () => {
                let $scope$lower: Nullable<Digit>;
                let $scope$upper: Nullable<Digit>;
                let $scope$suit: Nullable<SuitRangeSpecifier>;
                let $$res: Nullable<SuitRange> = null;
                if (true
                    && ($scope$lower = this.matchDigit($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:-)`, $$dpth + 1, $$cr) !== null
                    && ($scope$upper = this.matchDigit($$dpth + 1, $$cr)) !== null
                    && ($scope$suit = this.matchSuitRangeSpecifier($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.SuitRange, lower: $scope$lower, upper: $scope$upper, suit: $scope$suit};
                }
                return $$res;
            });
    }
    public matchSuitBound($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitBound> {
        return this.run<SuitBound>($$dpth,
            () => {
                let $scope$value: Nullable<Number>;
                let $scope$qualifier: Nullable<BoundQualifier>;
                let $scope$suit: Nullable<SuitRangeSpecifier>;
                let $$res: Nullable<SuitBound> = null;
                if (true
                    && ($scope$value = this.matchNumber($$dpth + 1, $$cr)) !== null
                    && ($scope$qualifier = this.matchBoundQualifier($$dpth + 1, $$cr)) !== null
                    && ($scope$suit = this.matchSuitRangeSpecifier($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.SuitBound, value: $scope$value, qualifier: $scope$qualifier, suit: $scope$suit};
                }
                return $$res;
            });
    }
    public matchSuitRangeSpecifier($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitRangeSpecifier> {
        return this.choice<SuitRangeSpecifier>([
            () => this.matchSuitRangeSpecifier_1($$dpth + 1, $$cr),
            () => this.matchSuitRangeSpecifier_2($$dpth + 1, $$cr),
            () => this.matchSuitRangeSpecifier_3($$dpth + 1, $$cr),
            () => this.matchSuitRangeSpecifier_4($$dpth + 1, $$cr),
            () => this.matchSuitRangeSpecifier_5($$dpth + 1, $$cr),
        ]);
    }
    public matchSuitRangeSpecifier_1($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitRangeSpecifier_1> {
        return this.matchMajor($$dpth + 1, $$cr);
    }
    public matchSuitRangeSpecifier_2($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitRangeSpecifier_2> {
        return this.matchMinor($$dpth + 1, $$cr);
    }
    public matchSuitRangeSpecifier_3($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitRangeSpecifier_3> {
        return this.matchOtherMajor($$dpth + 1, $$cr);
    }
    public matchSuitRangeSpecifier_4($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitRangeSpecifier_4> {
        return this.matchOtherMinor($$dpth + 1, $$cr);
    }
    public matchSuitRangeSpecifier_5($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitRangeSpecifier_5> {
        return this.matchStrain($$dpth + 1, $$cr);
    }
    public matchOtherMajor($$dpth: number, $$cr?: ErrorTracker): Nullable<OtherMajor> {
        return this.regexAccept(String.raw`(?:oM)`, $$dpth + 1, $$cr);
    }
    public matchOtherMinor($$dpth: number, $$cr?: ErrorTracker): Nullable<OtherMinor> {
        return this.regexAccept(String.raw`(?:om)`, $$dpth + 1, $$cr);
    }
    public matchBoundQualifier($$dpth: number, $$cr?: ErrorTracker): Nullable<BoundQualifier> {
        return this.choice<BoundQualifier>([
            () => this.matchBoundQualifier_1($$dpth + 1, $$cr),
            () => this.matchBoundQualifier_2($$dpth + 1, $$cr),
            () => this.matchBoundQualifier_3($$dpth + 1, $$cr),
        ]);
    }
    public matchBoundQualifier_1($$dpth: number, $$cr?: ErrorTracker): Nullable<BoundQualifier_1> {
        return this.matchPlus($$dpth + 1, $$cr);
    }
    public matchBoundQualifier_2($$dpth: number, $$cr?: ErrorTracker): Nullable<BoundQualifier_2> {
        return this.matchMinus($$dpth + 1, $$cr);
    }
    public matchBoundQualifier_3($$dpth: number, $$cr?: ErrorTracker): Nullable<BoundQualifier_3> {
        return this.matchEquals($$dpth + 1, $$cr);
    }
    public matchPlus($$dpth: number, $$cr?: ErrorTracker): Nullable<Plus> {
        return this.regexAccept(String.raw`(?:\+)`, $$dpth + 1, $$cr);
    }
    public matchMinus($$dpth: number, $$cr?: ErrorTracker): Nullable<Minus> {
        return this.regexAccept(String.raw`(?:\-)`, $$dpth + 1, $$cr);
    }
    public matchEquals($$dpth: number, $$cr?: ErrorTracker): Nullable<Equals> {
        return this.choice<Equals>([
            () => this.matchEquals_1($$dpth + 1, $$cr),
            () => this.matchEquals_2($$dpth + 1, $$cr),
        ]);
    }
    public matchEquals_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Equals_1> {
        return this.regexAccept(String.raw`(?:=)`, $$dpth + 1, $$cr);
    }
    public matchEquals_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Equals_2> {
        return this.regexAccept(String.raw`(?:)`, $$dpth + 1, $$cr);
    }
    public matchDistribution($$dpth: number, $$cr?: ErrorTracker): Nullable<Distribution> {
        return this.choice<Distribution>([
            () => this.matchDistribution_1($$dpth + 1, $$cr),
            () => this.matchDistribution_2($$dpth + 1, $$cr),
            () => this.matchDistribution_3($$dpth + 1, $$cr),
        ]);
    }
    public matchDistribution_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Distribution_1> {
        return this.matchBalanced($$dpth + 1, $$cr);
    }
    public matchDistribution_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Distribution_2> {
        return this.matchUnbalanced($$dpth + 1, $$cr);
    }
    public matchDistribution_3($$dpth: number, $$cr?: ErrorTracker): Nullable<Distribution_3> {
        return this.matchShape($$dpth + 1, $$cr);
    }
    public matchBalanced($$dpth: number, $$cr?: ErrorTracker): Nullable<Balanced> {
        return this.regexAccept(String.raw`(?:BAL)`, $$dpth + 1, $$cr);
    }
    public matchUnbalanced($$dpth: number, $$cr?: ErrorTracker): Nullable<Unbalanced> {
        return this.regexAccept(String.raw`(?:unBAL)`, $$dpth + 1, $$cr);
    }
    public matchShape($$dpth: number, $$cr?: ErrorTracker): Nullable<Shape> {
        return this.run<Shape>($$dpth,
            () => {
                let $scope$s: Nullable<Digit>;
                let $scope$h: Nullable<Digit>;
                let $scope$d: Nullable<Digit>;
                let $scope$c: Nullable<Digit>;
                let $$res: Nullable<Shape> = null;
                if (true
                    && ($scope$s = this.matchDigit($$dpth + 1, $$cr)) !== null
                    && ($scope$h = this.matchDigit($$dpth + 1, $$cr)) !== null
                    && ($scope$d = this.matchDigit($$dpth + 1, $$cr)) !== null
                    && ($scope$c = this.matchDigit($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Shape, s: $scope$s, h: $scope$h, d: $scope$d, c: $scope$c};
                }
                return $$res;
            });
    }
    public matchResponse($$dpth: number, $$cr?: ErrorTracker): Nullable<Response> {
        return this.choice<Response>([
            () => this.matchResponse_1($$dpth + 1, $$cr),
            () => this.matchResponse_2($$dpth + 1, $$cr),
            () => this.matchResponse_3($$dpth + 1, $$cr),
            () => this.matchResponse_4($$dpth + 1, $$cr),
        ]);
    }
    public matchResponse_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Response_1> {
        return this.matchForceOneRound($$dpth + 1, $$cr);
    }
    public matchResponse_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Response_2> {
        return this.matchForceGame($$dpth + 1, $$cr);
    }
    public matchResponse_3($$dpth: number, $$cr?: ErrorTracker): Nullable<Response_3> {
        return this.matchForceSlam($$dpth + 1, $$cr);
    }
    public matchResponse_4($$dpth: number, $$cr?: ErrorTracker): Nullable<Response_4> {
        return this.matchPuppet($$dpth + 1, $$cr);
    }
    public matchForceOneRound($$dpth: number, $$cr?: ErrorTracker): Nullable<ForceOneRound> {
        return this.regexAccept(String.raw`(?:F1)`, $$dpth + 1, $$cr);
    }
    public matchForceGame($$dpth: number, $$cr?: ErrorTracker): Nullable<ForceGame> {
        return this.regexAccept(String.raw`(?:FG)`, $$dpth + 1, $$cr);
    }
    public matchForceSlam($$dpth: number, $$cr?: ErrorTracker): Nullable<ForceSlam> {
        return this.regexAccept(String.raw`(?:FS)`, $$dpth + 1, $$cr);
    }
    public matchPuppet($$dpth: number, $$cr?: ErrorTracker): Nullable<Puppet> {
        return this.run<Puppet>($$dpth,
            () => {
                let $scope$level: Nullable<Number>;
                let $scope$strain: Nullable<Strain>;
                let $$res: Nullable<Puppet> = null;
                if (true
                    && ($scope$level = this.matchNumber($$dpth + 1, $$cr)) !== null
                    && ($scope$strain = this.matchStrain($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Puppet, level: $scope$level, strain: $scope$strain};
                }
                return $$res;
            });
    }
    public matchDigit($$dpth: number, $$cr?: ErrorTracker): Nullable<Digit> {
        return this.run<Digit>($$dpth,
            () => {
                let $scope$literal: Nullable<string>;
                let $$res: Nullable<Digit> = null;
                if (true
                    && ($scope$literal = this.regexAccept(String.raw`(?:[0-9])`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new Digit($scope$literal);
                }
                return $$res;
            });
    }
    public matchNumber($$dpth: number, $$cr?: ErrorTracker): Nullable<Number> {
        return this.run<Number>($$dpth,
            () => {
                let $scope$literal: Nullable<string>;
                let $$res: Nullable<Number> = null;
                if (true
                    && ($scope$literal = this.regexAccept(String.raw`(?:[0-9]+)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new Number($scope$literal);
                }
                return $$res;
            });
    }
    public test(): boolean {
        const mrk = this.mark();
        const res = this.matchRule(0);
        const ans = res !== null;
        this.reset(mrk);
        return ans;
    }
    public parse(): ParseResult {
        const mrk = this.mark();
        const res = this.matchRule(0);
        if (res)
            return {ast: res, errs: []};
        this.reset(mrk);
        const rec = new ErrorTracker();
        this.clearMemos();
        this.matchRule(0, rec);
        const err = rec.getErr()
        return {ast: res, errs: err !== null ? [err] : []}
    }
    public mark(): PosInfo {
        return this.pos;
    }
    private loop<T>(func: $$RuleType<T>, star: boolean = false): Nullable<T[]> {
        const mrk = this.mark();
        const res: T[] = [];
        for (;;) {
            const t = func();
            if (t === null) {
                break;
            }
            res.push(t);
        }
        if (star || res.length > 0) {
            return res;
        }
        this.reset(mrk);
        return null;
    }
    private run<T>($$dpth: number, fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn()
        if (res !== null)
            return res;
        this.reset(mrk);
        return null;
    }
    private choice<T>(fns: Array<$$RuleType<T>>): Nullable<T> {
        for (const f of fns) {
            const res = f();
            if (res !== null) {
                return res;
            }
        }
        return null;
    }
    private regexAccept(match: string, dpth: number, cr?: ErrorTracker): Nullable<string> {
        return this.run<string>(dpth,
            () => {
                const reg = new RegExp(match, "y");
                const mrk = this.mark();
                reg.lastIndex = mrk.overallPos;
                const res = this.tryConsume(reg);
                if(cr) {
                    cr.record(mrk, res, {
                        kind: "RegexMatch",
                        // We substring from 3 to len - 1 to strip off the
                        // non-capture group syntax added as a WebKit workaround
                        literal: match.substring(3, match.length - 1),
                        negated: this.negating,
                    });
                }
                return res;
            });
    }
    private tryConsume(reg: RegExp): Nullable<string> {
        const res = reg.exec(this.input);
        if (res) {
            let lineJmp = 0;
            let lind = -1;
            for (let i = 0; i < res[0].length; ++i) {
                if (res[0][i] === "\n") {
                    ++lineJmp;
                    lind = i;
                }
            }
            this.pos = {
                overallPos: reg.lastIndex,
                line: this.pos.line + lineJmp,
                offset: lind === -1 ? this.pos.offset + res[0].length : (res[0].length - lind - 1)
            };
            return res[0];
        }
        return null;
    }
    private noConsume<T>(fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn();
        this.reset(mrk);
        return res;
    }
    private negate<T>(fn: $$RuleType<T>): Nullable<boolean> {
        const mrk = this.mark();
        const oneg = this.negating;
        this.negating = !oneg;
        const res = fn();
        this.negating = oneg;
        this.reset(mrk);
        return res === null ? true : null;
    }
    private memoise<K>(rule: $$RuleType<K>, memo: Map<number, [Nullable<K>, PosInfo]>): Nullable<K> {
        const $scope$pos = this.mark();
        const $scope$memoRes = memo.get($scope$pos.overallPos);
        if(this.memoSafe && $scope$memoRes !== undefined) {
        this.reset($scope$memoRes[1]);
        return $scope$memoRes[0];
        }
        const $scope$result = rule();
        if(this.memoSafe)
        memo.set($scope$pos.overallPos, [$scope$result, this.mark()]);
        return $scope$result;
    }
    private match$EOF(et?: ErrorTracker): Nullable<{kind: ASTKinds.$EOF}> {
        const res: {kind: ASTKinds.$EOF} | null = this.finished() ? { kind: ASTKinds.$EOF } : null;
        if(et)
            et.record(this.mark(), res, { kind: "EOF", negated: this.negating });
        return res;
    }
}
export function parse(s: string): ParseResult {
    const p = new Parser(s);
    return p.parse();
}
export interface ParseResult {
    ast: Nullable<Rule>;
    errs: SyntaxErr[];
}
export interface PosInfo {
    readonly overallPos: number;
    readonly line: number;
    readonly offset: number;
}
export interface RegexMatch {
    readonly kind: "RegexMatch";
    readonly negated: boolean;
    readonly literal: string;
}
export type EOFMatch = { kind: "EOF"; negated: boolean };
export type MatchAttempt = RegexMatch | EOFMatch;
export class SyntaxErr {
    public pos: PosInfo;
    public expmatches: MatchAttempt[];
    constructor(pos: PosInfo, expmatches: MatchAttempt[]) {
        this.pos = pos;
        this.expmatches = [...expmatches];
    }
    public toString(): string {
        return `Syntax Error at line ${this.pos.line}:${this.pos.offset}. Expected one of ${this.expmatches.map(x => x.kind === "EOF" ? " EOF" : ` ${x.negated ? 'not ': ''}'${x.literal}'`)}`;
    }
}
class ErrorTracker {
    private mxpos: PosInfo = {overallPos: -1, line: -1, offset: -1};
    private regexset: Set<string> = new Set();
    private pmatches: MatchAttempt[] = [];
    public record(pos: PosInfo, result: any, att: MatchAttempt) {
        if ((result === null) === att.negated)
            return;
        if (pos.overallPos > this.mxpos.overallPos) {
            this.mxpos = pos;
            this.pmatches = [];
            this.regexset.clear()
        }
        if (this.mxpos.overallPos === pos.overallPos) {
            if(att.kind === "RegexMatch") {
                if(!this.regexset.has(att.literal))
                    this.pmatches.push(att);
                this.regexset.add(att.literal);
            } else {
                this.pmatches.push(att);
            }
        }
    }
    public getErr(): SyntaxErr | null {
        if (this.mxpos.overallPos !== -1)
            return new SyntaxErr(this.mxpos, this.pmatches);
        return null;
    }
}