/* AutoGenerated Code, changes may be overwritten
* INPUT GRAMMAR:
* Start := bid=Bid $
* Bid := level=Digit bid=BidSpecifier ': ' constraints=ConstraintList
* BidSpecifier := Wildcard | SuitSpecifier
* Wildcard := v='x'
* SuitSpecifier := Major | Minor | Strain
* Major := v='M'
* Minor := v='m'
* Strain := Suit | Notrump
* Suit := Club | Diamond | Heart | Spade
* Club := v='[Cc♣♧]'
* Diamond := v='[Dd♦♢]'
* Heart := v='[Hh♥♡]'
* Spade := v='[Ss♠♤]'
* Notrump := v='[Nn]' '[Tt]'?
* ConstraintList := ConstraintListItem+
* ConstraintListItem := constraint=Constraint ' '?
* Constraint := ConstraintAnd | ConstraintOr | Distribution | Response | SuitRange | SuitComparison | SuitBound | PointRange | PointBound 
* ConstraintOr := left=Constraint {' or ' | ' / '} right=Constraint
* ConstraintAnd := '\(' constraints=ConstraintList '\)'
* PointRange := lower=Number '-' upper=Number
* PointBound := value=Number qualifier=BoundQualifier
* SuitRange := lower=Digit '-' upper=Digit suit=SuitRangeSpecifier
* SuitBound := value=Number qualifier=BoundQualifier suit=SuitRangeSpecifier
* SuitRangeSpecifier := Major | Minor | Suit //| OtherMajor | OtherMinor
* OtherMajor := v='oM'
* OtherMinor := v='om'
* SuitComparison := left=Suit op=SuitComparisonOperator right=Suit
* SuitComparisonOperator := v='<' | v='<=' | v='=' | v='>=' | v='>'
* BoundQualifier := Plus | Minus | Equals
* Plus := v='\+'
* Minus := v='\-'
* Equals := v='=' | v=''
* Distribution := Balanced | SemiBalanced | Unbalanced | Shape
* Balanced := v='BAL'
* SemiBalanced := v='semiBAL'
* Unbalanced := v='unBAL'
* Shape := S=Digit H=Digit D=Digit C=Digit
* Response := ForceOneRound | ForceGame | ForceSlam | Relay
* ForceOneRound := v='F1'
* ForceGame := v='FG'
* ForceSlam := v='FS'
* Relay := level=Number strain=Strain
* Digit := literal='[0-9]'
*   .value = number { return parseInt(literal) }
* Number := literal='[0-9]+'
*   .value = number { return parseInt(literal) }
*/
type Nullable<T> = T | null;
type $$RuleType<T> = () => Nullable<T>;
interface ASTNodeIntf {
    kind: ASTKinds;
}
export enum ASTKinds {
    Start = "Start",
    Bid = "Bid",
    BidSpecifier_1 = "BidSpecifier_1",
    BidSpecifier_2 = "BidSpecifier_2",
    Wildcard = "Wildcard",
    SuitSpecifier_1 = "SuitSpecifier_1",
    SuitSpecifier_2 = "SuitSpecifier_2",
    SuitSpecifier_3 = "SuitSpecifier_3",
    Major = "Major",
    Minor = "Minor",
    Strain_1 = "Strain_1",
    Strain_2 = "Strain_2",
    Suit_1 = "Suit_1",
    Suit_2 = "Suit_2",
    Suit_3 = "Suit_3",
    Suit_4 = "Suit_4",
    Club = "Club",
    Diamond = "Diamond",
    Heart = "Heart",
    Spade = "Spade",
    Notrump = "Notrump",
    ConstraintList = "ConstraintList",
    ConstraintListItem = "ConstraintListItem",
    Constraint_1 = "Constraint_1",
    Constraint_2 = "Constraint_2",
    Constraint_3 = "Constraint_3",
    Constraint_4 = "Constraint_4",
    Constraint_5 = "Constraint_5",
    Constraint_6 = "Constraint_6",
    Constraint_7 = "Constraint_7",
    Constraint_8 = "Constraint_8",
    Constraint_9 = "Constraint_9",
    ConstraintOr = "ConstraintOr",
    ConstraintOr_$0_1 = "ConstraintOr_$0_1",
    ConstraintOr_$0_2 = "ConstraintOr_$0_2",
    ConstraintAnd = "ConstraintAnd",
    PointRange = "PointRange",
    PointBound = "PointBound",
    SuitRange = "SuitRange",
    SuitBound = "SuitBound",
    SuitRangeSpecifier_1 = "SuitRangeSpecifier_1",
    SuitRangeSpecifier_2 = "SuitRangeSpecifier_2",
    SuitRangeSpecifier_3 = "SuitRangeSpecifier_3",
    OtherMajor = "OtherMajor",
    OtherMinor = "OtherMinor",
    SuitComparison = "SuitComparison",
    SuitComparisonOperator_1 = "SuitComparisonOperator_1",
    SuitComparisonOperator_2 = "SuitComparisonOperator_2",
    SuitComparisonOperator_3 = "SuitComparisonOperator_3",
    SuitComparisonOperator_4 = "SuitComparisonOperator_4",
    SuitComparisonOperator_5 = "SuitComparisonOperator_5",
    BoundQualifier_1 = "BoundQualifier_1",
    BoundQualifier_2 = "BoundQualifier_2",
    BoundQualifier_3 = "BoundQualifier_3",
    Plus = "Plus",
    Minus = "Minus",
    Equals_1 = "Equals_1",
    Equals_2 = "Equals_2",
    Distribution_1 = "Distribution_1",
    Distribution_2 = "Distribution_2",
    Distribution_3 = "Distribution_3",
    Distribution_4 = "Distribution_4",
    Balanced = "Balanced",
    SemiBalanced = "SemiBalanced",
    Unbalanced = "Unbalanced",
    Shape = "Shape",
    Response_1 = "Response_1",
    Response_2 = "Response_2",
    Response_3 = "Response_3",
    Response_4 = "Response_4",
    ForceOneRound = "ForceOneRound",
    ForceGame = "ForceGame",
    ForceSlam = "ForceSlam",
    Relay = "Relay",
    Digit = "Digit",
    Number = "Number",
    $EOF = "$EOF",
}
export interface Start {
    kind: ASTKinds.Start;
    bid: Bid;
}
export interface Bid {
    kind: ASTKinds.Bid;
    level: Digit;
    bid: BidSpecifier;
    constraints: ConstraintList;
}
export type BidSpecifier = BidSpecifier_1 | BidSpecifier_2;
export type BidSpecifier_1 = Wildcard;
export type BidSpecifier_2 = SuitSpecifier;
export interface Wildcard {
    kind: ASTKinds.Wildcard;
    v: string;
}
export type SuitSpecifier = SuitSpecifier_1 | SuitSpecifier_2 | SuitSpecifier_3;
export type SuitSpecifier_1 = Major;
export type SuitSpecifier_2 = Minor;
export type SuitSpecifier_3 = Strain;
export interface Major {
    kind: ASTKinds.Major;
    v: string;
}
export interface Minor {
    kind: ASTKinds.Minor;
    v: string;
}
export type Strain = Strain_1 | Strain_2;
export type Strain_1 = Suit;
export type Strain_2 = Notrump;
export type Suit = Suit_1 | Suit_2 | Suit_3 | Suit_4;
export type Suit_1 = Club;
export type Suit_2 = Diamond;
export type Suit_3 = Heart;
export type Suit_4 = Spade;
export interface Club {
    kind: ASTKinds.Club;
    v: string;
}
export interface Diamond {
    kind: ASTKinds.Diamond;
    v: string;
}
export interface Heart {
    kind: ASTKinds.Heart;
    v: string;
}
export interface Spade {
    kind: ASTKinds.Spade;
    v: string;
}
export interface Notrump {
    kind: ASTKinds.Notrump;
    v: string;
}
export type ConstraintList = ConstraintListItem[];
export interface ConstraintListItem {
    kind: ASTKinds.ConstraintListItem;
    constraint: Constraint;
}
export type Constraint = Constraint_1 | Constraint_2 | Constraint_3 | Constraint_4 | Constraint_5 | Constraint_6 | Constraint_7 | Constraint_8 | Constraint_9;
export type Constraint_1 = ConstraintAnd;
export type Constraint_2 = ConstraintOr;
export type Constraint_3 = Distribution;
export type Constraint_4 = Response;
export type Constraint_5 = SuitRange;
export type Constraint_6 = SuitComparison;
export type Constraint_7 = SuitBound;
export type Constraint_8 = PointRange;
export type Constraint_9 = PointBound;
export interface ConstraintOr {
    kind: ASTKinds.ConstraintOr;
    left: Constraint;
    right: Constraint;
}
export type ConstraintOr_$0 = ConstraintOr_$0_1 | ConstraintOr_$0_2;
export type ConstraintOr_$0_1 = string;
export type ConstraintOr_$0_2 = string;
export interface ConstraintAnd {
    kind: ASTKinds.ConstraintAnd;
    constraints: ConstraintList;
}
export interface PointRange {
    kind: ASTKinds.PointRange;
    lower: Number;
    upper: Number;
}
export interface PointBound {
    kind: ASTKinds.PointBound;
    value: Number;
    qualifier: BoundQualifier;
}
export interface SuitRange {
    kind: ASTKinds.SuitRange;
    lower: Digit;
    upper: Digit;
    suit: SuitRangeSpecifier;
}
export interface SuitBound {
    kind: ASTKinds.SuitBound;
    value: Number;
    qualifier: BoundQualifier;
    suit: SuitRangeSpecifier;
}
export type SuitRangeSpecifier = SuitRangeSpecifier_1 | SuitRangeSpecifier_2 | SuitRangeSpecifier_3;
export type SuitRangeSpecifier_1 = Major;
export type SuitRangeSpecifier_2 = Minor;
export type SuitRangeSpecifier_3 = Suit;
export interface OtherMajor {
    kind: ASTKinds.OtherMajor;
    v: string;
}
export interface OtherMinor {
    kind: ASTKinds.OtherMinor;
    v: string;
}
export interface SuitComparison {
    kind: ASTKinds.SuitComparison;
    left: Suit;
    op: SuitComparisonOperator;
    right: Suit;
}
export type SuitComparisonOperator = SuitComparisonOperator_1 | SuitComparisonOperator_2 | SuitComparisonOperator_3 | SuitComparisonOperator_4 | SuitComparisonOperator_5;
export interface SuitComparisonOperator_1 {
    kind: ASTKinds.SuitComparisonOperator_1;
    v: string;
}
export interface SuitComparisonOperator_2 {
    kind: ASTKinds.SuitComparisonOperator_2;
    v: string;
}
export interface SuitComparisonOperator_3 {
    kind: ASTKinds.SuitComparisonOperator_3;
    v: string;
}
export interface SuitComparisonOperator_4 {
    kind: ASTKinds.SuitComparisonOperator_4;
    v: string;
}
export interface SuitComparisonOperator_5 {
    kind: ASTKinds.SuitComparisonOperator_5;
    v: string;
}
export type BoundQualifier = BoundQualifier_1 | BoundQualifier_2 | BoundQualifier_3;
export type BoundQualifier_1 = Plus;
export type BoundQualifier_2 = Minus;
export type BoundQualifier_3 = Equals;
export interface Plus {
    kind: ASTKinds.Plus;
    v: string;
}
export interface Minus {
    kind: ASTKinds.Minus;
    v: string;
}
export type Equals = Equals_1 | Equals_2;
export interface Equals_1 {
    kind: ASTKinds.Equals_1;
    v: string;
}
export interface Equals_2 {
    kind: ASTKinds.Equals_2;
    v: string;
}
export type Distribution = Distribution_1 | Distribution_2 | Distribution_3 | Distribution_4;
export type Distribution_1 = Balanced;
export type Distribution_2 = SemiBalanced;
export type Distribution_3 = Unbalanced;
export type Distribution_4 = Shape;
export interface Balanced {
    kind: ASTKinds.Balanced;
    v: string;
}
export interface SemiBalanced {
    kind: ASTKinds.SemiBalanced;
    v: string;
}
export interface Unbalanced {
    kind: ASTKinds.Unbalanced;
    v: string;
}
export interface Shape {
    kind: ASTKinds.Shape;
    S: Digit;
    H: Digit;
    D: Digit;
    C: Digit;
}
export type Response = Response_1 | Response_2 | Response_3 | Response_4;
export type Response_1 = ForceOneRound;
export type Response_2 = ForceGame;
export type Response_3 = ForceSlam;
export type Response_4 = Relay;
export interface ForceOneRound {
    kind: ASTKinds.ForceOneRound;
    v: string;
}
export interface ForceGame {
    kind: ASTKinds.ForceGame;
    v: string;
}
export interface ForceSlam {
    kind: ASTKinds.ForceSlam;
    v: string;
}
export interface Relay {
    kind: ASTKinds.Relay;
    level: Number;
    strain: Strain;
}
export class Digit {
    public kind: ASTKinds.Digit = ASTKinds.Digit;
    public literal: string;
    public value: number;
    constructor(literal: string){
        this.literal = literal;
        this.value = ((): number => {
        return parseInt(literal)
        })();
    }
}
export class Number {
    public kind: ASTKinds.Number = ASTKinds.Number;
    public literal: string;
    public value: number;
    constructor(literal: string){
        this.literal = literal;
        this.value = ((): number => {
        return parseInt(literal)
        })();
    }
}
export class Parser {
    private readonly input: string;
    private pos: PosInfo;
    private negating: boolean = false;
    private memoSafe: boolean = true;
    constructor(input: string) {
        this.pos = {overallPos: 0, line: 1, offset: 0};
        this.input = input;
    }
    public reset(pos: PosInfo) {
        this.pos = pos;
    }
    public finished(): boolean {
        return this.pos.overallPos === this.input.length;
    }
    public clearMemos(): void {
        this.$scope$Constraint$memo.clear();
    }
    protected $scope$Constraint$memo: Map<number, [Nullable<Constraint>, PosInfo]> = new Map();
    public matchStart($$dpth: number, $$cr?: ErrorTracker): Nullable<Start> {
        return this.run<Start>($$dpth,
            () => {
                let $scope$bid: Nullable<Bid>;
                let $$res: Nullable<Start> = null;
                if (true
                    && ($scope$bid = this.matchBid($$dpth + 1, $$cr)) !== null
                    && this.match$EOF($$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.Start, bid: $scope$bid};
                }
                return $$res;
            });
    }
    public matchBid($$dpth: number, $$cr?: ErrorTracker): Nullable<Bid> {
        return this.run<Bid>($$dpth,
            () => {
                let $scope$level: Nullable<Digit>;
                let $scope$bid: Nullable<BidSpecifier>;
                let $scope$constraints: Nullable<ConstraintList>;
                let $$res: Nullable<Bid> = null;
                if (true
                    && ($scope$level = this.matchDigit($$dpth + 1, $$cr)) !== null
                    && ($scope$bid = this.matchBidSpecifier($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:: )`, $$dpth + 1, $$cr) !== null
                    && ($scope$constraints = this.matchConstraintList($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Bid, level: $scope$level, bid: $scope$bid, constraints: $scope$constraints};
                }
                return $$res;
            });
    }
    public matchBidSpecifier($$dpth: number, $$cr?: ErrorTracker): Nullable<BidSpecifier> {
        return this.choice<BidSpecifier>([
            () => this.matchBidSpecifier_1($$dpth + 1, $$cr),
            () => this.matchBidSpecifier_2($$dpth + 1, $$cr),
        ]);
    }
    public matchBidSpecifier_1($$dpth: number, $$cr?: ErrorTracker): Nullable<BidSpecifier_1> {
        return this.matchWildcard($$dpth + 1, $$cr);
    }
    public matchBidSpecifier_2($$dpth: number, $$cr?: ErrorTracker): Nullable<BidSpecifier_2> {
        return this.matchSuitSpecifier($$dpth + 1, $$cr);
    }
    public matchWildcard($$dpth: number, $$cr?: ErrorTracker): Nullable<Wildcard> {
        return this.run<Wildcard>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<Wildcard> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:x)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Wildcard, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchSuitSpecifier($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitSpecifier> {
        return this.choice<SuitSpecifier>([
            () => this.matchSuitSpecifier_1($$dpth + 1, $$cr),
            () => this.matchSuitSpecifier_2($$dpth + 1, $$cr),
            () => this.matchSuitSpecifier_3($$dpth + 1, $$cr),
        ]);
    }
    public matchSuitSpecifier_1($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitSpecifier_1> {
        return this.matchMajor($$dpth + 1, $$cr);
    }
    public matchSuitSpecifier_2($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitSpecifier_2> {
        return this.matchMinor($$dpth + 1, $$cr);
    }
    public matchSuitSpecifier_3($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitSpecifier_3> {
        return this.matchStrain($$dpth + 1, $$cr);
    }
    public matchMajor($$dpth: number, $$cr?: ErrorTracker): Nullable<Major> {
        return this.run<Major>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<Major> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:M)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Major, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchMinor($$dpth: number, $$cr?: ErrorTracker): Nullable<Minor> {
        return this.run<Minor>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<Minor> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:m)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Minor, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchStrain($$dpth: number, $$cr?: ErrorTracker): Nullable<Strain> {
        return this.choice<Strain>([
            () => this.matchStrain_1($$dpth + 1, $$cr),
            () => this.matchStrain_2($$dpth + 1, $$cr),
        ]);
    }
    public matchStrain_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Strain_1> {
        return this.matchSuit($$dpth + 1, $$cr);
    }
    public matchStrain_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Strain_2> {
        return this.matchNotrump($$dpth + 1, $$cr);
    }
    public matchSuit($$dpth: number, $$cr?: ErrorTracker): Nullable<Suit> {
        return this.choice<Suit>([
            () => this.matchSuit_1($$dpth + 1, $$cr),
            () => this.matchSuit_2($$dpth + 1, $$cr),
            () => this.matchSuit_3($$dpth + 1, $$cr),
            () => this.matchSuit_4($$dpth + 1, $$cr),
        ]);
    }
    public matchSuit_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Suit_1> {
        return this.matchClub($$dpth + 1, $$cr);
    }
    public matchSuit_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Suit_2> {
        return this.matchDiamond($$dpth + 1, $$cr);
    }
    public matchSuit_3($$dpth: number, $$cr?: ErrorTracker): Nullable<Suit_3> {
        return this.matchHeart($$dpth + 1, $$cr);
    }
    public matchSuit_4($$dpth: number, $$cr?: ErrorTracker): Nullable<Suit_4> {
        return this.matchSpade($$dpth + 1, $$cr);
    }
    public matchClub($$dpth: number, $$cr?: ErrorTracker): Nullable<Club> {
        return this.run<Club>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<Club> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:[Cc♣♧])`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Club, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchDiamond($$dpth: number, $$cr?: ErrorTracker): Nullable<Diamond> {
        return this.run<Diamond>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<Diamond> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:[Dd♦♢])`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Diamond, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchHeart($$dpth: number, $$cr?: ErrorTracker): Nullable<Heart> {
        return this.run<Heart>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<Heart> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:[Hh♥♡])`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Heart, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchSpade($$dpth: number, $$cr?: ErrorTracker): Nullable<Spade> {
        return this.run<Spade>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<Spade> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:[Ss♠♤])`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Spade, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchNotrump($$dpth: number, $$cr?: ErrorTracker): Nullable<Notrump> {
        return this.run<Notrump>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<Notrump> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:[Nn])`, $$dpth + 1, $$cr)) !== null
                    && ((this.regexAccept(String.raw`(?:[Tt])`, $$dpth + 1, $$cr)) || true)
                ) {
                    $$res = {kind: ASTKinds.Notrump, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchConstraintList($$dpth: number, $$cr?: ErrorTracker): Nullable<ConstraintList> {
        return this.loop<ConstraintListItem>(() => this.matchConstraintListItem($$dpth + 1, $$cr), false);
    }
    public matchConstraintListItem($$dpth: number, $$cr?: ErrorTracker): Nullable<ConstraintListItem> {
        return this.run<ConstraintListItem>($$dpth,
            () => {
                let $scope$constraint: Nullable<Constraint>;
                let $$res: Nullable<ConstraintListItem> = null;
                if (true
                    && ($scope$constraint = this.matchConstraint($$dpth + 1, $$cr)) !== null
                    && ((this.regexAccept(String.raw`(?: )`, $$dpth + 1, $$cr)) || true)
                ) {
                    $$res = {kind: ASTKinds.ConstraintListItem, constraint: $scope$constraint};
                }
                return $$res;
            });
    }
    public matchConstraint($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint> {
        const fn = () => {
            return this.choice<Constraint>([
                () => this.matchConstraint_1($$dpth + 1, $$cr),
                () => this.matchConstraint_2($$dpth + 1, $$cr),
                () => this.matchConstraint_3($$dpth + 1, $$cr),
                () => this.matchConstraint_4($$dpth + 1, $$cr),
                () => this.matchConstraint_5($$dpth + 1, $$cr),
                () => this.matchConstraint_6($$dpth + 1, $$cr),
                () => this.matchConstraint_7($$dpth + 1, $$cr),
                () => this.matchConstraint_8($$dpth + 1, $$cr),
                () => this.matchConstraint_9($$dpth + 1, $$cr),
            ]);
        };
        const $scope$pos = this.mark();
        const memo = this.$scope$Constraint$memo.get($scope$pos.overallPos);
        if(memo !== undefined) {
            this.reset(memo[1]);
            return memo[0];
        }
        const $scope$oldMemoSafe = this.memoSafe;
        this.memoSafe = false;
        this.$scope$Constraint$memo.set($scope$pos.overallPos, [null, $scope$pos]);
        let lastRes: Nullable<Constraint> = null;
        let lastPos: PosInfo = $scope$pos;
        for(;;) {
            this.reset($scope$pos);
            const res = fn();
            const end = this.mark();
            if(end.overallPos <= lastPos.overallPos)
                break;
            lastRes = res;
            lastPos = end;
            this.$scope$Constraint$memo.set($scope$pos.overallPos, [lastRes, lastPos]);
        }
        this.reset(lastPos);
        this.memoSafe = $scope$oldMemoSafe;
        return lastRes;
    }
    public matchConstraint_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_1> {
        return this.matchConstraintAnd($$dpth + 1, $$cr);
    }
    public matchConstraint_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_2> {
        return this.matchConstraintOr($$dpth + 1, $$cr);
    }
    public matchConstraint_3($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_3> {
        return this.matchDistribution($$dpth + 1, $$cr);
    }
    public matchConstraint_4($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_4> {
        return this.matchResponse($$dpth + 1, $$cr);
    }
    public matchConstraint_5($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_5> {
        return this.matchSuitRange($$dpth + 1, $$cr);
    }
    public matchConstraint_6($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_6> {
        return this.matchSuitComparison($$dpth + 1, $$cr);
    }
    public matchConstraint_7($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_7> {
        return this.matchSuitBound($$dpth + 1, $$cr);
    }
    public matchConstraint_8($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_8> {
        return this.matchPointRange($$dpth + 1, $$cr);
    }
    public matchConstraint_9($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_9> {
        return this.matchPointBound($$dpth + 1, $$cr);
    }
    public matchConstraintOr($$dpth: number, $$cr?: ErrorTracker): Nullable<ConstraintOr> {
        return this.run<ConstraintOr>($$dpth,
            () => {
                let $scope$left: Nullable<Constraint>;
                let $scope$right: Nullable<Constraint>;
                let $$res: Nullable<ConstraintOr> = null;
                if (true
                    && ($scope$left = this.matchConstraint($$dpth + 1, $$cr)) !== null
                    && this.matchConstraintOr_$0($$dpth + 1, $$cr) !== null
                    && ($scope$right = this.matchConstraint($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.ConstraintOr, left: $scope$left, right: $scope$right};
                }
                return $$res;
            });
    }
    public matchConstraintOr_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<ConstraintOr_$0> {
        return this.choice<ConstraintOr_$0>([
            () => this.matchConstraintOr_$0_1($$dpth + 1, $$cr),
            () => this.matchConstraintOr_$0_2($$dpth + 1, $$cr),
        ]);
    }
    public matchConstraintOr_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<ConstraintOr_$0_1> {
        return this.regexAccept(String.raw`(?: or )`, $$dpth + 1, $$cr);
    }
    public matchConstraintOr_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<ConstraintOr_$0_2> {
        return this.regexAccept(String.raw`(?: / )`, $$dpth + 1, $$cr);
    }
    public matchConstraintAnd($$dpth: number, $$cr?: ErrorTracker): Nullable<ConstraintAnd> {
        return this.run<ConstraintAnd>($$dpth,
            () => {
                let $scope$constraints: Nullable<ConstraintList>;
                let $$res: Nullable<ConstraintAnd> = null;
                if (true
                    && this.regexAccept(String.raw`(?:\()`, $$dpth + 1, $$cr) !== null
                    && ($scope$constraints = this.matchConstraintList($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:\))`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.ConstraintAnd, constraints: $scope$constraints};
                }
                return $$res;
            });
    }
    public matchPointRange($$dpth: number, $$cr?: ErrorTracker): Nullable<PointRange> {
        return this.run<PointRange>($$dpth,
            () => {
                let $scope$lower: Nullable<Number>;
                let $scope$upper: Nullable<Number>;
                let $$res: Nullable<PointRange> = null;
                if (true
                    && ($scope$lower = this.matchNumber($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:-)`, $$dpth + 1, $$cr) !== null
                    && ($scope$upper = this.matchNumber($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.PointRange, lower: $scope$lower, upper: $scope$upper};
                }
                return $$res;
            });
    }
    public matchPointBound($$dpth: number, $$cr?: ErrorTracker): Nullable<PointBound> {
        return this.run<PointBound>($$dpth,
            () => {
                let $scope$value: Nullable<Number>;
                let $scope$qualifier: Nullable<BoundQualifier>;
                let $$res: Nullable<PointBound> = null;
                if (true
                    && ($scope$value = this.matchNumber($$dpth + 1, $$cr)) !== null
                    && ($scope$qualifier = this.matchBoundQualifier($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.PointBound, value: $scope$value, qualifier: $scope$qualifier};
                }
                return $$res;
            });
    }
    public matchSuitRange($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitRange> {
        return this.run<SuitRange>($$dpth,
            () => {
                let $scope$lower: Nullable<Digit>;
                let $scope$upper: Nullable<Digit>;
                let $scope$suit: Nullable<SuitRangeSpecifier>;
                let $$res: Nullable<SuitRange> = null;
                if (true
                    && ($scope$lower = this.matchDigit($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:-)`, $$dpth + 1, $$cr) !== null
                    && ($scope$upper = this.matchDigit($$dpth + 1, $$cr)) !== null
                    && ($scope$suit = this.matchSuitRangeSpecifier($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.SuitRange, lower: $scope$lower, upper: $scope$upper, suit: $scope$suit};
                }
                return $$res;
            });
    }
    public matchSuitBound($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitBound> {
        return this.run<SuitBound>($$dpth,
            () => {
                let $scope$value: Nullable<Number>;
                let $scope$qualifier: Nullable<BoundQualifier>;
                let $scope$suit: Nullable<SuitRangeSpecifier>;
                let $$res: Nullable<SuitBound> = null;
                if (true
                    && ($scope$value = this.matchNumber($$dpth + 1, $$cr)) !== null
                    && ($scope$qualifier = this.matchBoundQualifier($$dpth + 1, $$cr)) !== null
                    && ($scope$suit = this.matchSuitRangeSpecifier($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.SuitBound, value: $scope$value, qualifier: $scope$qualifier, suit: $scope$suit};
                }
                return $$res;
            });
    }
    public matchSuitRangeSpecifier($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitRangeSpecifier> {
        return this.choice<SuitRangeSpecifier>([
            () => this.matchSuitRangeSpecifier_1($$dpth + 1, $$cr),
            () => this.matchSuitRangeSpecifier_2($$dpth + 1, $$cr),
            () => this.matchSuitRangeSpecifier_3($$dpth + 1, $$cr),
        ]);
    }
    public matchSuitRangeSpecifier_1($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitRangeSpecifier_1> {
        return this.matchMajor($$dpth + 1, $$cr);
    }
    public matchSuitRangeSpecifier_2($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitRangeSpecifier_2> {
        return this.matchMinor($$dpth + 1, $$cr);
    }
    public matchSuitRangeSpecifier_3($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitRangeSpecifier_3> {
        return this.matchSuit($$dpth + 1, $$cr);
    }
    public matchOtherMajor($$dpth: number, $$cr?: ErrorTracker): Nullable<OtherMajor> {
        return this.run<OtherMajor>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<OtherMajor> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:oM)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.OtherMajor, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchOtherMinor($$dpth: number, $$cr?: ErrorTracker): Nullable<OtherMinor> {
        return this.run<OtherMinor>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<OtherMinor> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:om)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.OtherMinor, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchSuitComparison($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitComparison> {
        return this.run<SuitComparison>($$dpth,
            () => {
                let $scope$left: Nullable<Suit>;
                let $scope$op: Nullable<SuitComparisonOperator>;
                let $scope$right: Nullable<Suit>;
                let $$res: Nullable<SuitComparison> = null;
                if (true
                    && ($scope$left = this.matchSuit($$dpth + 1, $$cr)) !== null
                    && ($scope$op = this.matchSuitComparisonOperator($$dpth + 1, $$cr)) !== null
                    && ($scope$right = this.matchSuit($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.SuitComparison, left: $scope$left, op: $scope$op, right: $scope$right};
                }
                return $$res;
            });
    }
    public matchSuitComparisonOperator($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitComparisonOperator> {
        return this.choice<SuitComparisonOperator>([
            () => this.matchSuitComparisonOperator_1($$dpth + 1, $$cr),
            () => this.matchSuitComparisonOperator_2($$dpth + 1, $$cr),
            () => this.matchSuitComparisonOperator_3($$dpth + 1, $$cr),
            () => this.matchSuitComparisonOperator_4($$dpth + 1, $$cr),
            () => this.matchSuitComparisonOperator_5($$dpth + 1, $$cr),
        ]);
    }
    public matchSuitComparisonOperator_1($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitComparisonOperator_1> {
        return this.run<SuitComparisonOperator_1>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<SuitComparisonOperator_1> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:<)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.SuitComparisonOperator_1, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchSuitComparisonOperator_2($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitComparisonOperator_2> {
        return this.run<SuitComparisonOperator_2>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<SuitComparisonOperator_2> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:<=)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.SuitComparisonOperator_2, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchSuitComparisonOperator_3($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitComparisonOperator_3> {
        return this.run<SuitComparisonOperator_3>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<SuitComparisonOperator_3> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:=)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.SuitComparisonOperator_3, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchSuitComparisonOperator_4($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitComparisonOperator_4> {
        return this.run<SuitComparisonOperator_4>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<SuitComparisonOperator_4> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:>=)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.SuitComparisonOperator_4, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchSuitComparisonOperator_5($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitComparisonOperator_5> {
        return this.run<SuitComparisonOperator_5>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<SuitComparisonOperator_5> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:>)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.SuitComparisonOperator_5, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchBoundQualifier($$dpth: number, $$cr?: ErrorTracker): Nullable<BoundQualifier> {
        return this.choice<BoundQualifier>([
            () => this.matchBoundQualifier_1($$dpth + 1, $$cr),
            () => this.matchBoundQualifier_2($$dpth + 1, $$cr),
            () => this.matchBoundQualifier_3($$dpth + 1, $$cr),
        ]);
    }
    public matchBoundQualifier_1($$dpth: number, $$cr?: ErrorTracker): Nullable<BoundQualifier_1> {
        return this.matchPlus($$dpth + 1, $$cr);
    }
    public matchBoundQualifier_2($$dpth: number, $$cr?: ErrorTracker): Nullable<BoundQualifier_2> {
        return this.matchMinus($$dpth + 1, $$cr);
    }
    public matchBoundQualifier_3($$dpth: number, $$cr?: ErrorTracker): Nullable<BoundQualifier_3> {
        return this.matchEquals($$dpth + 1, $$cr);
    }
    public matchPlus($$dpth: number, $$cr?: ErrorTracker): Nullable<Plus> {
        return this.run<Plus>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<Plus> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:\+)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Plus, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchMinus($$dpth: number, $$cr?: ErrorTracker): Nullable<Minus> {
        return this.run<Minus>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<Minus> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:\-)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Minus, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchEquals($$dpth: number, $$cr?: ErrorTracker): Nullable<Equals> {
        return this.choice<Equals>([
            () => this.matchEquals_1($$dpth + 1, $$cr),
            () => this.matchEquals_2($$dpth + 1, $$cr),
        ]);
    }
    public matchEquals_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Equals_1> {
        return this.run<Equals_1>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<Equals_1> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:=)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Equals_1, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchEquals_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Equals_2> {
        return this.run<Equals_2>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<Equals_2> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Equals_2, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchDistribution($$dpth: number, $$cr?: ErrorTracker): Nullable<Distribution> {
        return this.choice<Distribution>([
            () => this.matchDistribution_1($$dpth + 1, $$cr),
            () => this.matchDistribution_2($$dpth + 1, $$cr),
            () => this.matchDistribution_3($$dpth + 1, $$cr),
            () => this.matchDistribution_4($$dpth + 1, $$cr),
        ]);
    }
    public matchDistribution_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Distribution_1> {
        return this.matchBalanced($$dpth + 1, $$cr);
    }
    public matchDistribution_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Distribution_2> {
        return this.matchSemiBalanced($$dpth + 1, $$cr);
    }
    public matchDistribution_3($$dpth: number, $$cr?: ErrorTracker): Nullable<Distribution_3> {
        return this.matchUnbalanced($$dpth + 1, $$cr);
    }
    public matchDistribution_4($$dpth: number, $$cr?: ErrorTracker): Nullable<Distribution_4> {
        return this.matchShape($$dpth + 1, $$cr);
    }
    public matchBalanced($$dpth: number, $$cr?: ErrorTracker): Nullable<Balanced> {
        return this.run<Balanced>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<Balanced> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:BAL)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Balanced, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchSemiBalanced($$dpth: number, $$cr?: ErrorTracker): Nullable<SemiBalanced> {
        return this.run<SemiBalanced>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<SemiBalanced> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:semiBAL)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.SemiBalanced, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchUnbalanced($$dpth: number, $$cr?: ErrorTracker): Nullable<Unbalanced> {
        return this.run<Unbalanced>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<Unbalanced> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:unBAL)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Unbalanced, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchShape($$dpth: number, $$cr?: ErrorTracker): Nullable<Shape> {
        return this.run<Shape>($$dpth,
            () => {
                let $scope$S: Nullable<Digit>;
                let $scope$H: Nullable<Digit>;
                let $scope$D: Nullable<Digit>;
                let $scope$C: Nullable<Digit>;
                let $$res: Nullable<Shape> = null;
                if (true
                    && ($scope$S = this.matchDigit($$dpth + 1, $$cr)) !== null
                    && ($scope$H = this.matchDigit($$dpth + 1, $$cr)) !== null
                    && ($scope$D = this.matchDigit($$dpth + 1, $$cr)) !== null
                    && ($scope$C = this.matchDigit($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Shape, S: $scope$S, H: $scope$H, D: $scope$D, C: $scope$C};
                }
                return $$res;
            });
    }
    public matchResponse($$dpth: number, $$cr?: ErrorTracker): Nullable<Response> {
        return this.choice<Response>([
            () => this.matchResponse_1($$dpth + 1, $$cr),
            () => this.matchResponse_2($$dpth + 1, $$cr),
            () => this.matchResponse_3($$dpth + 1, $$cr),
            () => this.matchResponse_4($$dpth + 1, $$cr),
        ]);
    }
    public matchResponse_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Response_1> {
        return this.matchForceOneRound($$dpth + 1, $$cr);
    }
    public matchResponse_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Response_2> {
        return this.matchForceGame($$dpth + 1, $$cr);
    }
    public matchResponse_3($$dpth: number, $$cr?: ErrorTracker): Nullable<Response_3> {
        return this.matchForceSlam($$dpth + 1, $$cr);
    }
    public matchResponse_4($$dpth: number, $$cr?: ErrorTracker): Nullable<Response_4> {
        return this.matchRelay($$dpth + 1, $$cr);
    }
    public matchForceOneRound($$dpth: number, $$cr?: ErrorTracker): Nullable<ForceOneRound> {
        return this.run<ForceOneRound>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<ForceOneRound> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:F1)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.ForceOneRound, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchForceGame($$dpth: number, $$cr?: ErrorTracker): Nullable<ForceGame> {
        return this.run<ForceGame>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<ForceGame> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:FG)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.ForceGame, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchForceSlam($$dpth: number, $$cr?: ErrorTracker): Nullable<ForceSlam> {
        return this.run<ForceSlam>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<ForceSlam> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:FS)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.ForceSlam, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchRelay($$dpth: number, $$cr?: ErrorTracker): Nullable<Relay> {
        return this.run<Relay>($$dpth,
            () => {
                let $scope$level: Nullable<Number>;
                let $scope$strain: Nullable<Strain>;
                let $$res: Nullable<Relay> = null;
                if (true
                    && ($scope$level = this.matchNumber($$dpth + 1, $$cr)) !== null
                    && ($scope$strain = this.matchStrain($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Relay, level: $scope$level, strain: $scope$strain};
                }
                return $$res;
            });
    }
    public matchDigit($$dpth: number, $$cr?: ErrorTracker): Nullable<Digit> {
        return this.run<Digit>($$dpth,
            () => {
                let $scope$literal: Nullable<string>;
                let $$res: Nullable<Digit> = null;
                if (true
                    && ($scope$literal = this.regexAccept(String.raw`(?:[0-9])`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new Digit($scope$literal);
                }
                return $$res;
            });
    }
    public matchNumber($$dpth: number, $$cr?: ErrorTracker): Nullable<Number> {
        return this.run<Number>($$dpth,
            () => {
                let $scope$literal: Nullable<string>;
                let $$res: Nullable<Number> = null;
                if (true
                    && ($scope$literal = this.regexAccept(String.raw`(?:[0-9]+)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new Number($scope$literal);
                }
                return $$res;
            });
    }
    public test(): boolean {
        const mrk = this.mark();
        const res = this.matchStart(0);
        const ans = res !== null;
        this.reset(mrk);
        return ans;
    }
    public parse(): ParseResult {
        const mrk = this.mark();
        const res = this.matchStart(0);
        if (res)
            return {ast: res, errs: []};
        this.reset(mrk);
        const rec = new ErrorTracker();
        this.clearMemos();
        this.matchStart(0, rec);
        const err = rec.getErr()
        return {ast: res, errs: err !== null ? [err] : []}
    }
    public mark(): PosInfo {
        return this.pos;
    }
    private loop<T>(func: $$RuleType<T>, star: boolean = false): Nullable<T[]> {
        const mrk = this.mark();
        const res: T[] = [];
        for (;;) {
            const t = func();
            if (t === null) {
                break;
            }
            res.push(t);
        }
        if (star || res.length > 0) {
            return res;
        }
        this.reset(mrk);
        return null;
    }
    private run<T>($$dpth: number, fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn()
        if (res !== null)
            return res;
        this.reset(mrk);
        return null;
    }
    private choice<T>(fns: Array<$$RuleType<T>>): Nullable<T> {
        for (const f of fns) {
            const res = f();
            if (res !== null) {
                return res;
            }
        }
        return null;
    }
    private regexAccept(match: string, dpth: number, cr?: ErrorTracker): Nullable<string> {
        return this.run<string>(dpth,
            () => {
                const reg = new RegExp(match, "y");
                const mrk = this.mark();
                reg.lastIndex = mrk.overallPos;
                const res = this.tryConsume(reg);
                if(cr) {
                    cr.record(mrk, res, {
                        kind: "RegexMatch",
                        // We substring from 3 to len - 1 to strip off the
                        // non-capture group syntax added as a WebKit workaround
                        literal: match.substring(3, match.length - 1),
                        negated: this.negating,
                    });
                }
                return res;
            });
    }
    private tryConsume(reg: RegExp): Nullable<string> {
        const res = reg.exec(this.input);
        if (res) {
            let lineJmp = 0;
            let lind = -1;
            for (let i = 0; i < res[0].length; ++i) {
                if (res[0][i] === "\n") {
                    ++lineJmp;
                    lind = i;
                }
            }
            this.pos = {
                overallPos: reg.lastIndex,
                line: this.pos.line + lineJmp,
                offset: lind === -1 ? this.pos.offset + res[0].length : (res[0].length - lind - 1)
            };
            return res[0];
        }
        return null;
    }
    private noConsume<T>(fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn();
        this.reset(mrk);
        return res;
    }
    private negate<T>(fn: $$RuleType<T>): Nullable<boolean> {
        const mrk = this.mark();
        const oneg = this.negating;
        this.negating = !oneg;
        const res = fn();
        this.negating = oneg;
        this.reset(mrk);
        return res === null ? true : null;
    }
    private memoise<K>(rule: $$RuleType<K>, memo: Map<number, [Nullable<K>, PosInfo]>): Nullable<K> {
        const $scope$pos = this.mark();
        const $scope$memoRes = memo.get($scope$pos.overallPos);
        if(this.memoSafe && $scope$memoRes !== undefined) {
        this.reset($scope$memoRes[1]);
        return $scope$memoRes[0];
        }
        const $scope$result = rule();
        if(this.memoSafe)
        memo.set($scope$pos.overallPos, [$scope$result, this.mark()]);
        return $scope$result;
    }
    private match$EOF(et?: ErrorTracker): Nullable<{kind: ASTKinds.$EOF}> {
        const res: {kind: ASTKinds.$EOF} | null = this.finished() ? { kind: ASTKinds.$EOF } : null;
        if(et)
            et.record(this.mark(), res, { kind: "EOF", negated: this.negating });
        return res;
    }
}
export function parse(s: string): ParseResult {
    const p = new Parser(s);
    return p.parse();
}
export interface ParseResult {
    ast: Nullable<Start>;
    errs: SyntaxErr[];
}
export interface PosInfo {
    readonly overallPos: number;
    readonly line: number;
    readonly offset: number;
}
export interface RegexMatch {
    readonly kind: "RegexMatch";
    readonly negated: boolean;
    readonly literal: string;
}
export type EOFMatch = { kind: "EOF"; negated: boolean };
export type MatchAttempt = RegexMatch | EOFMatch;
export class SyntaxErr {
    public pos: PosInfo;
    public expmatches: MatchAttempt[];
    constructor(pos: PosInfo, expmatches: MatchAttempt[]) {
        this.pos = pos;
        this.expmatches = [...expmatches];
    }
    public toString(): string {
        return `Syntax Error at line ${this.pos.line}:${this.pos.offset}. Expected one of ${this.expmatches.map(x => x.kind === "EOF" ? " EOF" : ` ${x.negated ? 'not ': ''}'${x.literal}'`)}`;
    }
}
class ErrorTracker {
    private mxpos: PosInfo = {overallPos: -1, line: -1, offset: -1};
    private regexset: Set<string> = new Set();
    private pmatches: MatchAttempt[] = [];
    public record(pos: PosInfo, result: any, att: MatchAttempt) {
        if ((result === null) === att.negated)
            return;
        if (pos.overallPos > this.mxpos.overallPos) {
            this.mxpos = pos;
            this.pmatches = [];
            this.regexset.clear()
        }
        if (this.mxpos.overallPos === pos.overallPos) {
            if(att.kind === "RegexMatch") {
                if(!this.regexset.has(att.literal))
                    this.pmatches.push(att);
                this.regexset.add(att.literal);
            } else {
                this.pmatches.push(att);
            }
        }
    }
    public getErr(): SyntaxErr | null {
        if (this.mxpos.overallPos !== -1)
            return new SyntaxErr(this.mxpos, this.pmatches);
        return null;
    }
}