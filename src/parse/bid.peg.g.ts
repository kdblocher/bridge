/* AutoGenerated Code, changes may be overwritten
* INPUT GRAMMAR:
* Start := spec=BidSpec $
* BidSpec := bid=Bid constraints=BidSpecConstraintList?
* BidSpecConstraintList := ': ' constraints=ConstraintList
* Bid := ContractBid | NonContractBid
* ContractBid := level=Digit specifier=SuitSpecifier
* SuitSpecifier := Wildcard | Major | Minor | Strain
* Wildcard := v='x'
* Major := v='M'
* Minor := v='m'
* NonContractBid := Pass
* Pass := v='P'
* Strain := Suit | Notrump
* Suit := Club | Diamond | Heart | Spade
* Club := v='[Cc♣♧]'
* Diamond := v='[Dd♦♢]'
* Heart := v='[Hh♥♡]'
* Spade := v='[Ss♠♤]'
* Notrump := v='[Nn]' '[Tt]'?
* Honor := v='[AKQJT]'
* ConstraintList := ConstraintListItem+
* ConstraintListItem := constraint=Constraint ' '?
* Constraint :=
*     Const
*   | Or
*   | And
*   | Not
*   | Otherwise
*   | Distribution
*   | Response
*   | SuitRange
*   | SuitBound
*   | SuitComparison
*   | SuitHonors
*   | SuitTop
*   | SuitRank
*   | PointRange
*   | PointBound
*   | OtherBid
*   | LabelDef
*   | LabelRef
* Const := True | False
* True := v='true'
* False := v='false'
* Or := left=Constraint ' or ' right=Constraint
* And := '\(' constraints=ConstraintList '\)'
* Not := {'not' | '!'} ' '? constraint=Constraint
* Otherwise := v='else'
* PointRange := lower=Number '-' upper=Number
* PointBound := value=Number qualifier=BoundQualifier
* SuitRange := lower=Digit '-' upper=Digit suit=SuitRangeSpecifier
* SuitBound := value=Number qualifier=BoundQualifier suit=SuitRangeSpecifier
* SuitRangeSpecifier := SuitSpecifier //| Major | Minor | OtherMajor | OtherMinor
* // OtherMajor := v='oM'
* // OtherMinor := v='om'
* SuitComparison := left=Suit op=SuitComparisonOperator right=Suit
* SuitComparisonOperator := v='<' | v='<=' | v='=' | v='>=' | v='>'
* SuitHonors := suit=Suit honors=Honor+
* SuitTop := suit=Suit x='[0-5]' '/' y='[1-5]'
* BoundQualifier := Plus | Minus | Equals
* Plus := v='\+'
* Minus := v='\-'
* Equals := v='='
* OtherBid := level=Number strain=Strain
* Distribution := Balanced | SemiBalanced | Unbalanced | AnyShape | SpecificShape
* Balanced := v='BAL'
* SemiBalanced := v='semiBAL'
* Unbalanced := v='unBAL'
* AnyShape := v='[0-9]{4}' '\*'
* SpecificShape := S=Digit H=Digit D=Digit C=Digit
* SuitRank := Primary | Secondary
* Primary := suit=Suit '1'
* Secondary := suit=Suit '2'
* Response := ForceOneRound | ForceGame | ForceSlam | Relay
* ForceOneRound := v='F1'
* ForceGame := v='FG'
* ForceSlam := v='FS'
* Relay := '->' bid=OtherBid
* LabelDef := '\'' label=Label '\': ' constraints=ConstraintList
* LabelRef := '\'' label=Label '\''
* Label := v='[0-9a-zA-z-_]+'
* Digit := literal='[0-9]'
*   .value = number { return parseInt(literal) }
* Number := literal='[0-9]+'
*   .value = number { return parseInt(literal) }
*/
type Nullable<T> = T | null;
type $$RuleType<T> = () => Nullable<T>;
interface ASTNodeIntf {
    kind: ASTKinds;
}
export enum ASTKinds {
    Start = "Start",
    BidSpec = "BidSpec",
    BidSpecConstraintList = "BidSpecConstraintList",
    Bid_1 = "Bid_1",
    Bid_2 = "Bid_2",
    ContractBid = "ContractBid",
    SuitSpecifier_1 = "SuitSpecifier_1",
    SuitSpecifier_2 = "SuitSpecifier_2",
    SuitSpecifier_3 = "SuitSpecifier_3",
    SuitSpecifier_4 = "SuitSpecifier_4",
    Wildcard = "Wildcard",
    Major = "Major",
    Minor = "Minor",
    NonContractBid = "NonContractBid",
    Pass = "Pass",
    Strain_1 = "Strain_1",
    Strain_2 = "Strain_2",
    Suit_1 = "Suit_1",
    Suit_2 = "Suit_2",
    Suit_3 = "Suit_3",
    Suit_4 = "Suit_4",
    Club = "Club",
    Diamond = "Diamond",
    Heart = "Heart",
    Spade = "Spade",
    Notrump = "Notrump",
    Honor = "Honor",
    ConstraintList = "ConstraintList",
    ConstraintListItem = "ConstraintListItem",
    Constraint_1 = "Constraint_1",
    Constraint_2 = "Constraint_2",
    Constraint_3 = "Constraint_3",
    Constraint_4 = "Constraint_4",
    Constraint_5 = "Constraint_5",
    Constraint_6 = "Constraint_6",
    Constraint_7 = "Constraint_7",
    Constraint_8 = "Constraint_8",
    Constraint_9 = "Constraint_9",
    Constraint_10 = "Constraint_10",
    Constraint_11 = "Constraint_11",
    Constraint_12 = "Constraint_12",
    Constraint_13 = "Constraint_13",
    Constraint_14 = "Constraint_14",
    Constraint_15 = "Constraint_15",
    Constraint_16 = "Constraint_16",
    Constraint_17 = "Constraint_17",
    Constraint_18 = "Constraint_18",
    Const_1 = "Const_1",
    Const_2 = "Const_2",
    True = "True",
    False = "False",
    Or = "Or",
    And = "And",
    Not = "Not",
    Not_$0_1 = "Not_$0_1",
    Not_$0_2 = "Not_$0_2",
    Otherwise = "Otherwise",
    PointRange = "PointRange",
    PointBound = "PointBound",
    SuitRange = "SuitRange",
    SuitBound = "SuitBound",
    SuitRangeSpecifier = "SuitRangeSpecifier",
    SuitComparison = "SuitComparison",
    SuitComparisonOperator_1 = "SuitComparisonOperator_1",
    SuitComparisonOperator_2 = "SuitComparisonOperator_2",
    SuitComparisonOperator_3 = "SuitComparisonOperator_3",
    SuitComparisonOperator_4 = "SuitComparisonOperator_4",
    SuitComparisonOperator_5 = "SuitComparisonOperator_5",
    SuitHonors = "SuitHonors",
    SuitTop = "SuitTop",
    BoundQualifier_1 = "BoundQualifier_1",
    BoundQualifier_2 = "BoundQualifier_2",
    BoundQualifier_3 = "BoundQualifier_3",
    Plus = "Plus",
    Minus = "Minus",
    Equals = "Equals",
    OtherBid = "OtherBid",
    Distribution_1 = "Distribution_1",
    Distribution_2 = "Distribution_2",
    Distribution_3 = "Distribution_3",
    Distribution_4 = "Distribution_4",
    Distribution_5 = "Distribution_5",
    Balanced = "Balanced",
    SemiBalanced = "SemiBalanced",
    Unbalanced = "Unbalanced",
    AnyShape = "AnyShape",
    SpecificShape = "SpecificShape",
    SuitRank_1 = "SuitRank_1",
    SuitRank_2 = "SuitRank_2",
    Primary = "Primary",
    Secondary = "Secondary",
    Response_1 = "Response_1",
    Response_2 = "Response_2",
    Response_3 = "Response_3",
    Response_4 = "Response_4",
    ForceOneRound = "ForceOneRound",
    ForceGame = "ForceGame",
    ForceSlam = "ForceSlam",
    Relay = "Relay",
    LabelDef = "LabelDef",
    LabelRef = "LabelRef",
    Label = "Label",
    Digit = "Digit",
    Number = "Number",
    $EOF = "$EOF",
}
export interface Start {
    kind: ASTKinds.Start;
    spec: BidSpec;
}
export interface BidSpec {
    kind: ASTKinds.BidSpec;
    bid: Bid;
    constraints: Nullable<BidSpecConstraintList>;
}
export interface BidSpecConstraintList {
    kind: ASTKinds.BidSpecConstraintList;
    constraints: ConstraintList;
}
export type Bid = Bid_1 | Bid_2;
export type Bid_1 = ContractBid;
export type Bid_2 = NonContractBid;
export interface ContractBid {
    kind: ASTKinds.ContractBid;
    level: Digit;
    specifier: SuitSpecifier;
}
export type SuitSpecifier = SuitSpecifier_1 | SuitSpecifier_2 | SuitSpecifier_3 | SuitSpecifier_4;
export type SuitSpecifier_1 = Wildcard;
export type SuitSpecifier_2 = Major;
export type SuitSpecifier_3 = Minor;
export type SuitSpecifier_4 = Strain;
export interface Wildcard {
    kind: ASTKinds.Wildcard;
    v: string;
}
export interface Major {
    kind: ASTKinds.Major;
    v: string;
}
export interface Minor {
    kind: ASTKinds.Minor;
    v: string;
}
export type NonContractBid = Pass;
export interface Pass {
    kind: ASTKinds.Pass;
    v: string;
}
export type Strain = Strain_1 | Strain_2;
export type Strain_1 = Suit;
export type Strain_2 = Notrump;
export type Suit = Suit_1 | Suit_2 | Suit_3 | Suit_4;
export type Suit_1 = Club;
export type Suit_2 = Diamond;
export type Suit_3 = Heart;
export type Suit_4 = Spade;
export interface Club {
    kind: ASTKinds.Club;
    v: string;
}
export interface Diamond {
    kind: ASTKinds.Diamond;
    v: string;
}
export interface Heart {
    kind: ASTKinds.Heart;
    v: string;
}
export interface Spade {
    kind: ASTKinds.Spade;
    v: string;
}
export interface Notrump {
    kind: ASTKinds.Notrump;
    v: string;
}
export interface Honor {
    kind: ASTKinds.Honor;
    v: string;
}
export type ConstraintList = ConstraintListItem[];
export interface ConstraintListItem {
    kind: ASTKinds.ConstraintListItem;
    constraint: Constraint;
}
export type Constraint = Constraint_1 | Constraint_2 | Constraint_3 | Constraint_4 | Constraint_5 | Constraint_6 | Constraint_7 | Constraint_8 | Constraint_9 | Constraint_10 | Constraint_11 | Constraint_12 | Constraint_13 | Constraint_14 | Constraint_15 | Constraint_16 | Constraint_17 | Constraint_18;
export type Constraint_1 = Const;
export type Constraint_2 = Or;
export type Constraint_3 = And;
export type Constraint_4 = Not;
export type Constraint_5 = Otherwise;
export type Constraint_6 = Distribution;
export type Constraint_7 = Response;
export type Constraint_8 = SuitRange;
export type Constraint_9 = SuitBound;
export type Constraint_10 = SuitComparison;
export type Constraint_11 = SuitHonors;
export type Constraint_12 = SuitTop;
export type Constraint_13 = SuitRank;
export type Constraint_14 = PointRange;
export type Constraint_15 = PointBound;
export type Constraint_16 = OtherBid;
export type Constraint_17 = LabelDef;
export type Constraint_18 = LabelRef;
export type Const = Const_1 | Const_2;
export type Const_1 = True;
export type Const_2 = False;
export interface True {
    kind: ASTKinds.True;
    v: string;
}
export interface False {
    kind: ASTKinds.False;
    v: string;
}
export interface Or {
    kind: ASTKinds.Or;
    left: Constraint;
    right: Constraint;
}
export interface And {
    kind: ASTKinds.And;
    constraints: ConstraintList;
}
export interface Not {
    kind: ASTKinds.Not;
    constraint: Constraint;
}
export type Not_$0 = Not_$0_1 | Not_$0_2;
export type Not_$0_1 = string;
export type Not_$0_2 = string;
export interface Otherwise {
    kind: ASTKinds.Otherwise;
    v: string;
}
export interface PointRange {
    kind: ASTKinds.PointRange;
    lower: Number;
    upper: Number;
}
export interface PointBound {
    kind: ASTKinds.PointBound;
    value: Number;
    qualifier: BoundQualifier;
}
export interface SuitRange {
    kind: ASTKinds.SuitRange;
    lower: Digit;
    upper: Digit;
    suit: SuitRangeSpecifier;
}
export interface SuitBound {
    kind: ASTKinds.SuitBound;
    value: Number;
    qualifier: BoundQualifier;
    suit: SuitRangeSpecifier;
}
export type SuitRangeSpecifier = SuitSpecifier;
export interface SuitComparison {
    kind: ASTKinds.SuitComparison;
    left: Suit;
    op: SuitComparisonOperator;
    right: Suit;
}
export type SuitComparisonOperator = SuitComparisonOperator_1 | SuitComparisonOperator_2 | SuitComparisonOperator_3 | SuitComparisonOperator_4 | SuitComparisonOperator_5;
export interface SuitComparisonOperator_1 {
    kind: ASTKinds.SuitComparisonOperator_1;
    v: string;
}
export interface SuitComparisonOperator_2 {
    kind: ASTKinds.SuitComparisonOperator_2;
    v: string;
}
export interface SuitComparisonOperator_3 {
    kind: ASTKinds.SuitComparisonOperator_3;
    v: string;
}
export interface SuitComparisonOperator_4 {
    kind: ASTKinds.SuitComparisonOperator_4;
    v: string;
}
export interface SuitComparisonOperator_5 {
    kind: ASTKinds.SuitComparisonOperator_5;
    v: string;
}
export interface SuitHonors {
    kind: ASTKinds.SuitHonors;
    suit: Suit;
    honors: Honor[];
}
export interface SuitTop {
    kind: ASTKinds.SuitTop;
    suit: Suit;
    x: string;
    y: string;
}
export type BoundQualifier = BoundQualifier_1 | BoundQualifier_2 | BoundQualifier_3;
export type BoundQualifier_1 = Plus;
export type BoundQualifier_2 = Minus;
export type BoundQualifier_3 = Equals;
export interface Plus {
    kind: ASTKinds.Plus;
    v: string;
}
export interface Minus {
    kind: ASTKinds.Minus;
    v: string;
}
export interface Equals {
    kind: ASTKinds.Equals;
    v: string;
}
export interface OtherBid {
    kind: ASTKinds.OtherBid;
    level: Number;
    strain: Strain;
}
export type Distribution = Distribution_1 | Distribution_2 | Distribution_3 | Distribution_4 | Distribution_5;
export type Distribution_1 = Balanced;
export type Distribution_2 = SemiBalanced;
export type Distribution_3 = Unbalanced;
export type Distribution_4 = AnyShape;
export type Distribution_5 = SpecificShape;
export interface Balanced {
    kind: ASTKinds.Balanced;
    v: string;
}
export interface SemiBalanced {
    kind: ASTKinds.SemiBalanced;
    v: string;
}
export interface Unbalanced {
    kind: ASTKinds.Unbalanced;
    v: string;
}
export interface AnyShape {
    kind: ASTKinds.AnyShape;
    v: string;
}
export interface SpecificShape {
    kind: ASTKinds.SpecificShape;
    S: Digit;
    H: Digit;
    D: Digit;
    C: Digit;
}
export type SuitRank = SuitRank_1 | SuitRank_2;
export type SuitRank_1 = Primary;
export type SuitRank_2 = Secondary;
export interface Primary {
    kind: ASTKinds.Primary;
    suit: Suit;
}
export interface Secondary {
    kind: ASTKinds.Secondary;
    suit: Suit;
}
export type Response = Response_1 | Response_2 | Response_3 | Response_4;
export type Response_1 = ForceOneRound;
export type Response_2 = ForceGame;
export type Response_3 = ForceSlam;
export type Response_4 = Relay;
export interface ForceOneRound {
    kind: ASTKinds.ForceOneRound;
    v: string;
}
export interface ForceGame {
    kind: ASTKinds.ForceGame;
    v: string;
}
export interface ForceSlam {
    kind: ASTKinds.ForceSlam;
    v: string;
}
export interface Relay {
    kind: ASTKinds.Relay;
    bid: OtherBid;
}
export interface LabelDef {
    kind: ASTKinds.LabelDef;
    label: Label;
    constraints: ConstraintList;
}
export interface LabelRef {
    kind: ASTKinds.LabelRef;
    label: Label;
}
export interface Label {
    kind: ASTKinds.Label;
    v: string;
}
export class Digit {
    public kind: ASTKinds.Digit = ASTKinds.Digit;
    public literal: string;
    public value: number;
    constructor(literal: string){
        this.literal = literal;
        this.value = ((): number => {
        return parseInt(literal)
        })();
    }
}
export class Number {
    public kind: ASTKinds.Number = ASTKinds.Number;
    public literal: string;
    public value: number;
    constructor(literal: string){
        this.literal = literal;
        this.value = ((): number => {
        return parseInt(literal)
        })();
    }
}
export class Parser {
    private readonly input: string;
    private pos: PosInfo;
    private negating: boolean = false;
    private memoSafe: boolean = true;
    constructor(input: string) {
        this.pos = {overallPos: 0, line: 1, offset: 0};
        this.input = input;
    }
    public reset(pos: PosInfo) {
        this.pos = pos;
    }
    public finished(): boolean {
        return this.pos.overallPos === this.input.length;
    }
    public clearMemos(): void {
        this.$scope$Constraint$memo.clear();
    }
    protected $scope$Constraint$memo: Map<number, [Nullable<Constraint>, PosInfo]> = new Map();
    public matchStart($$dpth: number, $$cr?: ErrorTracker): Nullable<Start> {
        return this.run<Start>($$dpth,
            () => {
                let $scope$spec: Nullable<BidSpec>;
                let $$res: Nullable<Start> = null;
                if (true
                    && ($scope$spec = this.matchBidSpec($$dpth + 1, $$cr)) !== null
                    && this.match$EOF($$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.Start, spec: $scope$spec};
                }
                return $$res;
            });
    }
    public matchBidSpec($$dpth: number, $$cr?: ErrorTracker): Nullable<BidSpec> {
        return this.run<BidSpec>($$dpth,
            () => {
                let $scope$bid: Nullable<Bid>;
                let $scope$constraints: Nullable<Nullable<BidSpecConstraintList>>;
                let $$res: Nullable<BidSpec> = null;
                if (true
                    && ($scope$bid = this.matchBid($$dpth + 1, $$cr)) !== null
                    && (($scope$constraints = this.matchBidSpecConstraintList($$dpth + 1, $$cr)) || true)
                ) {
                    $$res = {kind: ASTKinds.BidSpec, bid: $scope$bid, constraints: $scope$constraints};
                }
                return $$res;
            });
    }
    public matchBidSpecConstraintList($$dpth: number, $$cr?: ErrorTracker): Nullable<BidSpecConstraintList> {
        return this.run<BidSpecConstraintList>($$dpth,
            () => {
                let $scope$constraints: Nullable<ConstraintList>;
                let $$res: Nullable<BidSpecConstraintList> = null;
                if (true
                    && this.regexAccept(String.raw`(?:: )`, $$dpth + 1, $$cr) !== null
                    && ($scope$constraints = this.matchConstraintList($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.BidSpecConstraintList, constraints: $scope$constraints};
                }
                return $$res;
            });
    }
    public matchBid($$dpth: number, $$cr?: ErrorTracker): Nullable<Bid> {
        return this.choice<Bid>([
            () => this.matchBid_1($$dpth + 1, $$cr),
            () => this.matchBid_2($$dpth + 1, $$cr),
        ]);
    }
    public matchBid_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Bid_1> {
        return this.matchContractBid($$dpth + 1, $$cr);
    }
    public matchBid_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Bid_2> {
        return this.matchNonContractBid($$dpth + 1, $$cr);
    }
    public matchContractBid($$dpth: number, $$cr?: ErrorTracker): Nullable<ContractBid> {
        return this.run<ContractBid>($$dpth,
            () => {
                let $scope$level: Nullable<Digit>;
                let $scope$specifier: Nullable<SuitSpecifier>;
                let $$res: Nullable<ContractBid> = null;
                if (true
                    && ($scope$level = this.matchDigit($$dpth + 1, $$cr)) !== null
                    && ($scope$specifier = this.matchSuitSpecifier($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.ContractBid, level: $scope$level, specifier: $scope$specifier};
                }
                return $$res;
            });
    }
    public matchSuitSpecifier($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitSpecifier> {
        return this.choice<SuitSpecifier>([
            () => this.matchSuitSpecifier_1($$dpth + 1, $$cr),
            () => this.matchSuitSpecifier_2($$dpth + 1, $$cr),
            () => this.matchSuitSpecifier_3($$dpth + 1, $$cr),
            () => this.matchSuitSpecifier_4($$dpth + 1, $$cr),
        ]);
    }
    public matchSuitSpecifier_1($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitSpecifier_1> {
        return this.matchWildcard($$dpth + 1, $$cr);
    }
    public matchSuitSpecifier_2($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitSpecifier_2> {
        return this.matchMajor($$dpth + 1, $$cr);
    }
    public matchSuitSpecifier_3($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitSpecifier_3> {
        return this.matchMinor($$dpth + 1, $$cr);
    }
    public matchSuitSpecifier_4($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitSpecifier_4> {
        return this.matchStrain($$dpth + 1, $$cr);
    }
    public matchWildcard($$dpth: number, $$cr?: ErrorTracker): Nullable<Wildcard> {
        return this.run<Wildcard>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<Wildcard> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:x)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Wildcard, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchMajor($$dpth: number, $$cr?: ErrorTracker): Nullable<Major> {
        return this.run<Major>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<Major> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:M)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Major, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchMinor($$dpth: number, $$cr?: ErrorTracker): Nullable<Minor> {
        return this.run<Minor>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<Minor> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:m)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Minor, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchNonContractBid($$dpth: number, $$cr?: ErrorTracker): Nullable<NonContractBid> {
        return this.matchPass($$dpth + 1, $$cr);
    }
    public matchPass($$dpth: number, $$cr?: ErrorTracker): Nullable<Pass> {
        return this.run<Pass>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<Pass> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:P)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Pass, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchStrain($$dpth: number, $$cr?: ErrorTracker): Nullable<Strain> {
        return this.choice<Strain>([
            () => this.matchStrain_1($$dpth + 1, $$cr),
            () => this.matchStrain_2($$dpth + 1, $$cr),
        ]);
    }
    public matchStrain_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Strain_1> {
        return this.matchSuit($$dpth + 1, $$cr);
    }
    public matchStrain_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Strain_2> {
        return this.matchNotrump($$dpth + 1, $$cr);
    }
    public matchSuit($$dpth: number, $$cr?: ErrorTracker): Nullable<Suit> {
        return this.choice<Suit>([
            () => this.matchSuit_1($$dpth + 1, $$cr),
            () => this.matchSuit_2($$dpth + 1, $$cr),
            () => this.matchSuit_3($$dpth + 1, $$cr),
            () => this.matchSuit_4($$dpth + 1, $$cr),
        ]);
    }
    public matchSuit_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Suit_1> {
        return this.matchClub($$dpth + 1, $$cr);
    }
    public matchSuit_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Suit_2> {
        return this.matchDiamond($$dpth + 1, $$cr);
    }
    public matchSuit_3($$dpth: number, $$cr?: ErrorTracker): Nullable<Suit_3> {
        return this.matchHeart($$dpth + 1, $$cr);
    }
    public matchSuit_4($$dpth: number, $$cr?: ErrorTracker): Nullable<Suit_4> {
        return this.matchSpade($$dpth + 1, $$cr);
    }
    public matchClub($$dpth: number, $$cr?: ErrorTracker): Nullable<Club> {
        return this.run<Club>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<Club> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:[Cc♣♧])`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Club, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchDiamond($$dpth: number, $$cr?: ErrorTracker): Nullable<Diamond> {
        return this.run<Diamond>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<Diamond> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:[Dd♦♢])`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Diamond, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchHeart($$dpth: number, $$cr?: ErrorTracker): Nullable<Heart> {
        return this.run<Heart>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<Heart> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:[Hh♥♡])`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Heart, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchSpade($$dpth: number, $$cr?: ErrorTracker): Nullable<Spade> {
        return this.run<Spade>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<Spade> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:[Ss♠♤])`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Spade, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchNotrump($$dpth: number, $$cr?: ErrorTracker): Nullable<Notrump> {
        return this.run<Notrump>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<Notrump> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:[Nn])`, $$dpth + 1, $$cr)) !== null
                    && ((this.regexAccept(String.raw`(?:[Tt])`, $$dpth + 1, $$cr)) || true)
                ) {
                    $$res = {kind: ASTKinds.Notrump, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchHonor($$dpth: number, $$cr?: ErrorTracker): Nullable<Honor> {
        return this.run<Honor>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<Honor> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:[AKQJT])`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Honor, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchConstraintList($$dpth: number, $$cr?: ErrorTracker): Nullable<ConstraintList> {
        return this.loop<ConstraintListItem>(() => this.matchConstraintListItem($$dpth + 1, $$cr), false);
    }
    public matchConstraintListItem($$dpth: number, $$cr?: ErrorTracker): Nullable<ConstraintListItem> {
        return this.run<ConstraintListItem>($$dpth,
            () => {
                let $scope$constraint: Nullable<Constraint>;
                let $$res: Nullable<ConstraintListItem> = null;
                if (true
                    && ($scope$constraint = this.matchConstraint($$dpth + 1, $$cr)) !== null
                    && ((this.regexAccept(String.raw`(?: )`, $$dpth + 1, $$cr)) || true)
                ) {
                    $$res = {kind: ASTKinds.ConstraintListItem, constraint: $scope$constraint};
                }
                return $$res;
            });
    }
    public matchConstraint($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint> {
        const fn = () => {
            return this.choice<Constraint>([
                () => this.matchConstraint_1($$dpth + 1, $$cr),
                () => this.matchConstraint_2($$dpth + 1, $$cr),
                () => this.matchConstraint_3($$dpth + 1, $$cr),
                () => this.matchConstraint_4($$dpth + 1, $$cr),
                () => this.matchConstraint_5($$dpth + 1, $$cr),
                () => this.matchConstraint_6($$dpth + 1, $$cr),
                () => this.matchConstraint_7($$dpth + 1, $$cr),
                () => this.matchConstraint_8($$dpth + 1, $$cr),
                () => this.matchConstraint_9($$dpth + 1, $$cr),
                () => this.matchConstraint_10($$dpth + 1, $$cr),
                () => this.matchConstraint_11($$dpth + 1, $$cr),
                () => this.matchConstraint_12($$dpth + 1, $$cr),
                () => this.matchConstraint_13($$dpth + 1, $$cr),
                () => this.matchConstraint_14($$dpth + 1, $$cr),
                () => this.matchConstraint_15($$dpth + 1, $$cr),
                () => this.matchConstraint_16($$dpth + 1, $$cr),
                () => this.matchConstraint_17($$dpth + 1, $$cr),
                () => this.matchConstraint_18($$dpth + 1, $$cr),
            ]);
        };
        const $scope$pos = this.mark();
        const memo = this.$scope$Constraint$memo.get($scope$pos.overallPos);
        if(memo !== undefined) {
            this.reset(memo[1]);
            return memo[0];
        }
        const $scope$oldMemoSafe = this.memoSafe;
        this.memoSafe = false;
        this.$scope$Constraint$memo.set($scope$pos.overallPos, [null, $scope$pos]);
        let lastRes: Nullable<Constraint> = null;
        let lastPos: PosInfo = $scope$pos;
        for(;;) {
            this.reset($scope$pos);
            const res = fn();
            const end = this.mark();
            if(end.overallPos <= lastPos.overallPos)
                break;
            lastRes = res;
            lastPos = end;
            this.$scope$Constraint$memo.set($scope$pos.overallPos, [lastRes, lastPos]);
        }
        this.reset(lastPos);
        this.memoSafe = $scope$oldMemoSafe;
        return lastRes;
    }
    public matchConstraint_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_1> {
        return this.matchConst($$dpth + 1, $$cr);
    }
    public matchConstraint_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_2> {
        return this.matchOr($$dpth + 1, $$cr);
    }
    public matchConstraint_3($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_3> {
        return this.matchAnd($$dpth + 1, $$cr);
    }
    public matchConstraint_4($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_4> {
        return this.matchNot($$dpth + 1, $$cr);
    }
    public matchConstraint_5($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_5> {
        return this.matchOtherwise($$dpth + 1, $$cr);
    }
    public matchConstraint_6($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_6> {
        return this.matchDistribution($$dpth + 1, $$cr);
    }
    public matchConstraint_7($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_7> {
        return this.matchResponse($$dpth + 1, $$cr);
    }
    public matchConstraint_8($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_8> {
        return this.matchSuitRange($$dpth + 1, $$cr);
    }
    public matchConstraint_9($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_9> {
        return this.matchSuitBound($$dpth + 1, $$cr);
    }
    public matchConstraint_10($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_10> {
        return this.matchSuitComparison($$dpth + 1, $$cr);
    }
    public matchConstraint_11($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_11> {
        return this.matchSuitHonors($$dpth + 1, $$cr);
    }
    public matchConstraint_12($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_12> {
        return this.matchSuitTop($$dpth + 1, $$cr);
    }
    public matchConstraint_13($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_13> {
        return this.matchSuitRank($$dpth + 1, $$cr);
    }
    public matchConstraint_14($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_14> {
        return this.matchPointRange($$dpth + 1, $$cr);
    }
    public matchConstraint_15($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_15> {
        return this.matchPointBound($$dpth + 1, $$cr);
    }
    public matchConstraint_16($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_16> {
        return this.matchOtherBid($$dpth + 1, $$cr);
    }
    public matchConstraint_17($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_17> {
        return this.matchLabelDef($$dpth + 1, $$cr);
    }
    public matchConstraint_18($$dpth: number, $$cr?: ErrorTracker): Nullable<Constraint_18> {
        return this.matchLabelRef($$dpth + 1, $$cr);
    }
    public matchConst($$dpth: number, $$cr?: ErrorTracker): Nullable<Const> {
        return this.choice<Const>([
            () => this.matchConst_1($$dpth + 1, $$cr),
            () => this.matchConst_2($$dpth + 1, $$cr),
        ]);
    }
    public matchConst_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Const_1> {
        return this.matchTrue($$dpth + 1, $$cr);
    }
    public matchConst_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Const_2> {
        return this.matchFalse($$dpth + 1, $$cr);
    }
    public matchTrue($$dpth: number, $$cr?: ErrorTracker): Nullable<True> {
        return this.run<True>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<True> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:true)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.True, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchFalse($$dpth: number, $$cr?: ErrorTracker): Nullable<False> {
        return this.run<False>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<False> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:false)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.False, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchOr($$dpth: number, $$cr?: ErrorTracker): Nullable<Or> {
        return this.run<Or>($$dpth,
            () => {
                let $scope$left: Nullable<Constraint>;
                let $scope$right: Nullable<Constraint>;
                let $$res: Nullable<Or> = null;
                if (true
                    && ($scope$left = this.matchConstraint($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?: or )`, $$dpth + 1, $$cr) !== null
                    && ($scope$right = this.matchConstraint($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Or, left: $scope$left, right: $scope$right};
                }
                return $$res;
            });
    }
    public matchAnd($$dpth: number, $$cr?: ErrorTracker): Nullable<And> {
        return this.run<And>($$dpth,
            () => {
                let $scope$constraints: Nullable<ConstraintList>;
                let $$res: Nullable<And> = null;
                if (true
                    && this.regexAccept(String.raw`(?:\()`, $$dpth + 1, $$cr) !== null
                    && ($scope$constraints = this.matchConstraintList($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:\))`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.And, constraints: $scope$constraints};
                }
                return $$res;
            });
    }
    public matchNot($$dpth: number, $$cr?: ErrorTracker): Nullable<Not> {
        return this.run<Not>($$dpth,
            () => {
                let $scope$constraint: Nullable<Constraint>;
                let $$res: Nullable<Not> = null;
                if (true
                    && this.matchNot_$0($$dpth + 1, $$cr) !== null
                    && ((this.regexAccept(String.raw`(?: )`, $$dpth + 1, $$cr)) || true)
                    && ($scope$constraint = this.matchConstraint($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Not, constraint: $scope$constraint};
                }
                return $$res;
            });
    }
    public matchNot_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Not_$0> {
        return this.choice<Not_$0>([
            () => this.matchNot_$0_1($$dpth + 1, $$cr),
            () => this.matchNot_$0_2($$dpth + 1, $$cr),
        ]);
    }
    public matchNot_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Not_$0_1> {
        return this.regexAccept(String.raw`(?:not)`, $$dpth + 1, $$cr);
    }
    public matchNot_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Not_$0_2> {
        return this.regexAccept(String.raw`(?:!)`, $$dpth + 1, $$cr);
    }
    public matchOtherwise($$dpth: number, $$cr?: ErrorTracker): Nullable<Otherwise> {
        return this.run<Otherwise>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<Otherwise> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:else)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Otherwise, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchPointRange($$dpth: number, $$cr?: ErrorTracker): Nullable<PointRange> {
        return this.run<PointRange>($$dpth,
            () => {
                let $scope$lower: Nullable<Number>;
                let $scope$upper: Nullable<Number>;
                let $$res: Nullable<PointRange> = null;
                if (true
                    && ($scope$lower = this.matchNumber($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:-)`, $$dpth + 1, $$cr) !== null
                    && ($scope$upper = this.matchNumber($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.PointRange, lower: $scope$lower, upper: $scope$upper};
                }
                return $$res;
            });
    }
    public matchPointBound($$dpth: number, $$cr?: ErrorTracker): Nullable<PointBound> {
        return this.run<PointBound>($$dpth,
            () => {
                let $scope$value: Nullable<Number>;
                let $scope$qualifier: Nullable<BoundQualifier>;
                let $$res: Nullable<PointBound> = null;
                if (true
                    && ($scope$value = this.matchNumber($$dpth + 1, $$cr)) !== null
                    && ($scope$qualifier = this.matchBoundQualifier($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.PointBound, value: $scope$value, qualifier: $scope$qualifier};
                }
                return $$res;
            });
    }
    public matchSuitRange($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitRange> {
        return this.run<SuitRange>($$dpth,
            () => {
                let $scope$lower: Nullable<Digit>;
                let $scope$upper: Nullable<Digit>;
                let $scope$suit: Nullable<SuitRangeSpecifier>;
                let $$res: Nullable<SuitRange> = null;
                if (true
                    && ($scope$lower = this.matchDigit($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:-)`, $$dpth + 1, $$cr) !== null
                    && ($scope$upper = this.matchDigit($$dpth + 1, $$cr)) !== null
                    && ($scope$suit = this.matchSuitRangeSpecifier($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.SuitRange, lower: $scope$lower, upper: $scope$upper, suit: $scope$suit};
                }
                return $$res;
            });
    }
    public matchSuitBound($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitBound> {
        return this.run<SuitBound>($$dpth,
            () => {
                let $scope$value: Nullable<Number>;
                let $scope$qualifier: Nullable<BoundQualifier>;
                let $scope$suit: Nullable<SuitRangeSpecifier>;
                let $$res: Nullable<SuitBound> = null;
                if (true
                    && ($scope$value = this.matchNumber($$dpth + 1, $$cr)) !== null
                    && ($scope$qualifier = this.matchBoundQualifier($$dpth + 1, $$cr)) !== null
                    && ($scope$suit = this.matchSuitRangeSpecifier($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.SuitBound, value: $scope$value, qualifier: $scope$qualifier, suit: $scope$suit};
                }
                return $$res;
            });
    }
    public matchSuitRangeSpecifier($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitRangeSpecifier> {
        return this.matchSuitSpecifier($$dpth + 1, $$cr);
    }
    public matchSuitComparison($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitComparison> {
        return this.run<SuitComparison>($$dpth,
            () => {
                let $scope$left: Nullable<Suit>;
                let $scope$op: Nullable<SuitComparisonOperator>;
                let $scope$right: Nullable<Suit>;
                let $$res: Nullable<SuitComparison> = null;
                if (true
                    && ($scope$left = this.matchSuit($$dpth + 1, $$cr)) !== null
                    && ($scope$op = this.matchSuitComparisonOperator($$dpth + 1, $$cr)) !== null
                    && ($scope$right = this.matchSuit($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.SuitComparison, left: $scope$left, op: $scope$op, right: $scope$right};
                }
                return $$res;
            });
    }
    public matchSuitComparisonOperator($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitComparisonOperator> {
        return this.choice<SuitComparisonOperator>([
            () => this.matchSuitComparisonOperator_1($$dpth + 1, $$cr),
            () => this.matchSuitComparisonOperator_2($$dpth + 1, $$cr),
            () => this.matchSuitComparisonOperator_3($$dpth + 1, $$cr),
            () => this.matchSuitComparisonOperator_4($$dpth + 1, $$cr),
            () => this.matchSuitComparisonOperator_5($$dpth + 1, $$cr),
        ]);
    }
    public matchSuitComparisonOperator_1($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitComparisonOperator_1> {
        return this.run<SuitComparisonOperator_1>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<SuitComparisonOperator_1> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:<)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.SuitComparisonOperator_1, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchSuitComparisonOperator_2($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitComparisonOperator_2> {
        return this.run<SuitComparisonOperator_2>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<SuitComparisonOperator_2> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:<=)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.SuitComparisonOperator_2, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchSuitComparisonOperator_3($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitComparisonOperator_3> {
        return this.run<SuitComparisonOperator_3>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<SuitComparisonOperator_3> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:=)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.SuitComparisonOperator_3, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchSuitComparisonOperator_4($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitComparisonOperator_4> {
        return this.run<SuitComparisonOperator_4>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<SuitComparisonOperator_4> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:>=)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.SuitComparisonOperator_4, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchSuitComparisonOperator_5($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitComparisonOperator_5> {
        return this.run<SuitComparisonOperator_5>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<SuitComparisonOperator_5> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:>)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.SuitComparisonOperator_5, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchSuitHonors($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitHonors> {
        return this.run<SuitHonors>($$dpth,
            () => {
                let $scope$suit: Nullable<Suit>;
                let $scope$honors: Nullable<Honor[]>;
                let $$res: Nullable<SuitHonors> = null;
                if (true
                    && ($scope$suit = this.matchSuit($$dpth + 1, $$cr)) !== null
                    && ($scope$honors = this.loop<Honor>(() => this.matchHonor($$dpth + 1, $$cr), false)) !== null
                ) {
                    $$res = {kind: ASTKinds.SuitHonors, suit: $scope$suit, honors: $scope$honors};
                }
                return $$res;
            });
    }
    public matchSuitTop($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitTop> {
        return this.run<SuitTop>($$dpth,
            () => {
                let $scope$suit: Nullable<Suit>;
                let $scope$x: Nullable<string>;
                let $scope$y: Nullable<string>;
                let $$res: Nullable<SuitTop> = null;
                if (true
                    && ($scope$suit = this.matchSuit($$dpth + 1, $$cr)) !== null
                    && ($scope$x = this.regexAccept(String.raw`(?:[0-5])`, $$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:/)`, $$dpth + 1, $$cr) !== null
                    && ($scope$y = this.regexAccept(String.raw`(?:[1-5])`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.SuitTop, suit: $scope$suit, x: $scope$x, y: $scope$y};
                }
                return $$res;
            });
    }
    public matchBoundQualifier($$dpth: number, $$cr?: ErrorTracker): Nullable<BoundQualifier> {
        return this.choice<BoundQualifier>([
            () => this.matchBoundQualifier_1($$dpth + 1, $$cr),
            () => this.matchBoundQualifier_2($$dpth + 1, $$cr),
            () => this.matchBoundQualifier_3($$dpth + 1, $$cr),
        ]);
    }
    public matchBoundQualifier_1($$dpth: number, $$cr?: ErrorTracker): Nullable<BoundQualifier_1> {
        return this.matchPlus($$dpth + 1, $$cr);
    }
    public matchBoundQualifier_2($$dpth: number, $$cr?: ErrorTracker): Nullable<BoundQualifier_2> {
        return this.matchMinus($$dpth + 1, $$cr);
    }
    public matchBoundQualifier_3($$dpth: number, $$cr?: ErrorTracker): Nullable<BoundQualifier_3> {
        return this.matchEquals($$dpth + 1, $$cr);
    }
    public matchPlus($$dpth: number, $$cr?: ErrorTracker): Nullable<Plus> {
        return this.run<Plus>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<Plus> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:\+)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Plus, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchMinus($$dpth: number, $$cr?: ErrorTracker): Nullable<Minus> {
        return this.run<Minus>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<Minus> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:\-)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Minus, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchEquals($$dpth: number, $$cr?: ErrorTracker): Nullable<Equals> {
        return this.run<Equals>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<Equals> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:=)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Equals, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchOtherBid($$dpth: number, $$cr?: ErrorTracker): Nullable<OtherBid> {
        return this.run<OtherBid>($$dpth,
            () => {
                let $scope$level: Nullable<Number>;
                let $scope$strain: Nullable<Strain>;
                let $$res: Nullable<OtherBid> = null;
                if (true
                    && ($scope$level = this.matchNumber($$dpth + 1, $$cr)) !== null
                    && ($scope$strain = this.matchStrain($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.OtherBid, level: $scope$level, strain: $scope$strain};
                }
                return $$res;
            });
    }
    public matchDistribution($$dpth: number, $$cr?: ErrorTracker): Nullable<Distribution> {
        return this.choice<Distribution>([
            () => this.matchDistribution_1($$dpth + 1, $$cr),
            () => this.matchDistribution_2($$dpth + 1, $$cr),
            () => this.matchDistribution_3($$dpth + 1, $$cr),
            () => this.matchDistribution_4($$dpth + 1, $$cr),
            () => this.matchDistribution_5($$dpth + 1, $$cr),
        ]);
    }
    public matchDistribution_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Distribution_1> {
        return this.matchBalanced($$dpth + 1, $$cr);
    }
    public matchDistribution_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Distribution_2> {
        return this.matchSemiBalanced($$dpth + 1, $$cr);
    }
    public matchDistribution_3($$dpth: number, $$cr?: ErrorTracker): Nullable<Distribution_3> {
        return this.matchUnbalanced($$dpth + 1, $$cr);
    }
    public matchDistribution_4($$dpth: number, $$cr?: ErrorTracker): Nullable<Distribution_4> {
        return this.matchAnyShape($$dpth + 1, $$cr);
    }
    public matchDistribution_5($$dpth: number, $$cr?: ErrorTracker): Nullable<Distribution_5> {
        return this.matchSpecificShape($$dpth + 1, $$cr);
    }
    public matchBalanced($$dpth: number, $$cr?: ErrorTracker): Nullable<Balanced> {
        return this.run<Balanced>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<Balanced> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:BAL)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Balanced, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchSemiBalanced($$dpth: number, $$cr?: ErrorTracker): Nullable<SemiBalanced> {
        return this.run<SemiBalanced>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<SemiBalanced> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:semiBAL)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.SemiBalanced, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchUnbalanced($$dpth: number, $$cr?: ErrorTracker): Nullable<Unbalanced> {
        return this.run<Unbalanced>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<Unbalanced> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:unBAL)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Unbalanced, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchAnyShape($$dpth: number, $$cr?: ErrorTracker): Nullable<AnyShape> {
        return this.run<AnyShape>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<AnyShape> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:[0-9]{4})`, $$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:\*)`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.AnyShape, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchSpecificShape($$dpth: number, $$cr?: ErrorTracker): Nullable<SpecificShape> {
        return this.run<SpecificShape>($$dpth,
            () => {
                let $scope$S: Nullable<Digit>;
                let $scope$H: Nullable<Digit>;
                let $scope$D: Nullable<Digit>;
                let $scope$C: Nullable<Digit>;
                let $$res: Nullable<SpecificShape> = null;
                if (true
                    && ($scope$S = this.matchDigit($$dpth + 1, $$cr)) !== null
                    && ($scope$H = this.matchDigit($$dpth + 1, $$cr)) !== null
                    && ($scope$D = this.matchDigit($$dpth + 1, $$cr)) !== null
                    && ($scope$C = this.matchDigit($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.SpecificShape, S: $scope$S, H: $scope$H, D: $scope$D, C: $scope$C};
                }
                return $$res;
            });
    }
    public matchSuitRank($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitRank> {
        return this.choice<SuitRank>([
            () => this.matchSuitRank_1($$dpth + 1, $$cr),
            () => this.matchSuitRank_2($$dpth + 1, $$cr),
        ]);
    }
    public matchSuitRank_1($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitRank_1> {
        return this.matchPrimary($$dpth + 1, $$cr);
    }
    public matchSuitRank_2($$dpth: number, $$cr?: ErrorTracker): Nullable<SuitRank_2> {
        return this.matchSecondary($$dpth + 1, $$cr);
    }
    public matchPrimary($$dpth: number, $$cr?: ErrorTracker): Nullable<Primary> {
        return this.run<Primary>($$dpth,
            () => {
                let $scope$suit: Nullable<Suit>;
                let $$res: Nullable<Primary> = null;
                if (true
                    && ($scope$suit = this.matchSuit($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:1)`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.Primary, suit: $scope$suit};
                }
                return $$res;
            });
    }
    public matchSecondary($$dpth: number, $$cr?: ErrorTracker): Nullable<Secondary> {
        return this.run<Secondary>($$dpth,
            () => {
                let $scope$suit: Nullable<Suit>;
                let $$res: Nullable<Secondary> = null;
                if (true
                    && ($scope$suit = this.matchSuit($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:2)`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.Secondary, suit: $scope$suit};
                }
                return $$res;
            });
    }
    public matchResponse($$dpth: number, $$cr?: ErrorTracker): Nullable<Response> {
        return this.choice<Response>([
            () => this.matchResponse_1($$dpth + 1, $$cr),
            () => this.matchResponse_2($$dpth + 1, $$cr),
            () => this.matchResponse_3($$dpth + 1, $$cr),
            () => this.matchResponse_4($$dpth + 1, $$cr),
        ]);
    }
    public matchResponse_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Response_1> {
        return this.matchForceOneRound($$dpth + 1, $$cr);
    }
    public matchResponse_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Response_2> {
        return this.matchForceGame($$dpth + 1, $$cr);
    }
    public matchResponse_3($$dpth: number, $$cr?: ErrorTracker): Nullable<Response_3> {
        return this.matchForceSlam($$dpth + 1, $$cr);
    }
    public matchResponse_4($$dpth: number, $$cr?: ErrorTracker): Nullable<Response_4> {
        return this.matchRelay($$dpth + 1, $$cr);
    }
    public matchForceOneRound($$dpth: number, $$cr?: ErrorTracker): Nullable<ForceOneRound> {
        return this.run<ForceOneRound>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<ForceOneRound> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:F1)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.ForceOneRound, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchForceGame($$dpth: number, $$cr?: ErrorTracker): Nullable<ForceGame> {
        return this.run<ForceGame>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<ForceGame> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:FG)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.ForceGame, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchForceSlam($$dpth: number, $$cr?: ErrorTracker): Nullable<ForceSlam> {
        return this.run<ForceSlam>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<ForceSlam> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:FS)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.ForceSlam, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchRelay($$dpth: number, $$cr?: ErrorTracker): Nullable<Relay> {
        return this.run<Relay>($$dpth,
            () => {
                let $scope$bid: Nullable<OtherBid>;
                let $$res: Nullable<Relay> = null;
                if (true
                    && this.regexAccept(String.raw`(?:->)`, $$dpth + 1, $$cr) !== null
                    && ($scope$bid = this.matchOtherBid($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Relay, bid: $scope$bid};
                }
                return $$res;
            });
    }
    public matchLabelDef($$dpth: number, $$cr?: ErrorTracker): Nullable<LabelDef> {
        return this.run<LabelDef>($$dpth,
            () => {
                let $scope$label: Nullable<Label>;
                let $scope$constraints: Nullable<ConstraintList>;
                let $$res: Nullable<LabelDef> = null;
                if (true
                    && this.regexAccept(String.raw`(?:\')`, $$dpth + 1, $$cr) !== null
                    && ($scope$label = this.matchLabel($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:\': )`, $$dpth + 1, $$cr) !== null
                    && ($scope$constraints = this.matchConstraintList($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.LabelDef, label: $scope$label, constraints: $scope$constraints};
                }
                return $$res;
            });
    }
    public matchLabelRef($$dpth: number, $$cr?: ErrorTracker): Nullable<LabelRef> {
        return this.run<LabelRef>($$dpth,
            () => {
                let $scope$label: Nullable<Label>;
                let $$res: Nullable<LabelRef> = null;
                if (true
                    && this.regexAccept(String.raw`(?:\')`, $$dpth + 1, $$cr) !== null
                    && ($scope$label = this.matchLabel($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:\')`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.LabelRef, label: $scope$label};
                }
                return $$res;
            });
    }
    public matchLabel($$dpth: number, $$cr?: ErrorTracker): Nullable<Label> {
        return this.run<Label>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<Label> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:[0-9a-zA-z-_]+)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Label, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchDigit($$dpth: number, $$cr?: ErrorTracker): Nullable<Digit> {
        return this.run<Digit>($$dpth,
            () => {
                let $scope$literal: Nullable<string>;
                let $$res: Nullable<Digit> = null;
                if (true
                    && ($scope$literal = this.regexAccept(String.raw`(?:[0-9])`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new Digit($scope$literal);
                }
                return $$res;
            });
    }
    public matchNumber($$dpth: number, $$cr?: ErrorTracker): Nullable<Number> {
        return this.run<Number>($$dpth,
            () => {
                let $scope$literal: Nullable<string>;
                let $$res: Nullable<Number> = null;
                if (true
                    && ($scope$literal = this.regexAccept(String.raw`(?:[0-9]+)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new Number($scope$literal);
                }
                return $$res;
            });
    }
    public test(): boolean {
        const mrk = this.mark();
        const res = this.matchStart(0);
        const ans = res !== null;
        this.reset(mrk);
        return ans;
    }
    public parse(): ParseResult {
        const mrk = this.mark();
        const res = this.matchStart(0);
        if (res)
            return {ast: res, errs: []};
        this.reset(mrk);
        const rec = new ErrorTracker();
        this.clearMemos();
        this.matchStart(0, rec);
        const err = rec.getErr()
        return {ast: res, errs: err !== null ? [err] : []}
    }
    public mark(): PosInfo {
        return this.pos;
    }
    private loop<T>(func: $$RuleType<T>, star: boolean = false): Nullable<T[]> {
        const mrk = this.mark();
        const res: T[] = [];
        for (;;) {
            const t = func();
            if (t === null) {
                break;
            }
            res.push(t);
        }
        if (star || res.length > 0) {
            return res;
        }
        this.reset(mrk);
        return null;
    }
    private run<T>($$dpth: number, fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn()
        if (res !== null)
            return res;
        this.reset(mrk);
        return null;
    }
    private choice<T>(fns: Array<$$RuleType<T>>): Nullable<T> {
        for (const f of fns) {
            const res = f();
            if (res !== null) {
                return res;
            }
        }
        return null;
    }
    private regexAccept(match: string, dpth: number, cr?: ErrorTracker): Nullable<string> {
        return this.run<string>(dpth,
            () => {
                const reg = new RegExp(match, "y");
                const mrk = this.mark();
                reg.lastIndex = mrk.overallPos;
                const res = this.tryConsume(reg);
                if(cr) {
                    cr.record(mrk, res, {
                        kind: "RegexMatch",
                        // We substring from 3 to len - 1 to strip off the
                        // non-capture group syntax added as a WebKit workaround
                        literal: match.substring(3, match.length - 1),
                        negated: this.negating,
                    });
                }
                return res;
            });
    }
    private tryConsume(reg: RegExp): Nullable<string> {
        const res = reg.exec(this.input);
        if (res) {
            let lineJmp = 0;
            let lind = -1;
            for (let i = 0; i < res[0].length; ++i) {
                if (res[0][i] === "\n") {
                    ++lineJmp;
                    lind = i;
                }
            }
            this.pos = {
                overallPos: reg.lastIndex,
                line: this.pos.line + lineJmp,
                offset: lind === -1 ? this.pos.offset + res[0].length : (res[0].length - lind - 1)
            };
            return res[0];
        }
        return null;
    }
    private noConsume<T>(fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn();
        this.reset(mrk);
        return res;
    }
    private negate<T>(fn: $$RuleType<T>): Nullable<boolean> {
        const mrk = this.mark();
        const oneg = this.negating;
        this.negating = !oneg;
        const res = fn();
        this.negating = oneg;
        this.reset(mrk);
        return res === null ? true : null;
    }
    private memoise<K>(rule: $$RuleType<K>, memo: Map<number, [Nullable<K>, PosInfo]>): Nullable<K> {
        const $scope$pos = this.mark();
        const $scope$memoRes = memo.get($scope$pos.overallPos);
        if(this.memoSafe && $scope$memoRes !== undefined) {
        this.reset($scope$memoRes[1]);
        return $scope$memoRes[0];
        }
        const $scope$result = rule();
        if(this.memoSafe)
        memo.set($scope$pos.overallPos, [$scope$result, this.mark()]);
        return $scope$result;
    }
    private match$EOF(et?: ErrorTracker): Nullable<{kind: ASTKinds.$EOF}> {
        const res: {kind: ASTKinds.$EOF} | null = this.finished() ? { kind: ASTKinds.$EOF } : null;
        if(et)
            et.record(this.mark(), res, { kind: "EOF", negated: this.negating });
        return res;
    }
}
export function parse(s: string): ParseResult {
    const p = new Parser(s);
    return p.parse();
}
export interface ParseResult {
    ast: Nullable<Start>;
    errs: SyntaxErr[];
}
export interface PosInfo {
    readonly overallPos: number;
    readonly line: number;
    readonly offset: number;
}
export interface RegexMatch {
    readonly kind: "RegexMatch";
    readonly negated: boolean;
    readonly literal: string;
}
export type EOFMatch = { kind: "EOF"; negated: boolean };
export type MatchAttempt = RegexMatch | EOFMatch;
export class SyntaxErr {
    public pos: PosInfo;
    public expmatches: MatchAttempt[];
    constructor(pos: PosInfo, expmatches: MatchAttempt[]) {
        this.pos = pos;
        this.expmatches = [...expmatches];
    }
    public toString(): string {
        return `Syntax Error at line ${this.pos.line}:${this.pos.offset}. Expected one of ${this.expmatches.map(x => x.kind === "EOF" ? " EOF" : ` ${x.negated ? 'not ': ''}'${x.literal}'`)}`;
    }
}
class ErrorTracker {
    private mxpos: PosInfo = {overallPos: -1, line: -1, offset: -1};
    private regexset: Set<string> = new Set();
    private pmatches: MatchAttempt[] = [];
    public record(pos: PosInfo, result: any, att: MatchAttempt) {
        if ((result === null) === att.negated)
            return;
        if (pos.overallPos > this.mxpos.overallPos) {
            this.mxpos = pos;
            this.pmatches = [];
            this.regexset.clear()
        }
        if (this.mxpos.overallPos === pos.overallPos) {
            if(att.kind === "RegexMatch") {
                if(!this.regexset.has(att.literal))
                    this.pmatches.push(att);
                this.regexset.add(att.literal);
            } else {
                this.pmatches.push(att);
            }
        }
    }
    public getErr(): SyntaxErr | null {
        if (this.mxpos.overallPos !== -1)
            return new SyntaxErr(this.mxpos, this.pmatches);
        return null;
    }
}